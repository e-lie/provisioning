---
apiVersion: rbac.authorization.k8s.io/v1beta1
kind: ClusterRole
metadata:
  annotations: {}
  labels:
    name: cert-manager-edit
  name: cert-manager-edit
rules:
- apiGroups:
  - cert-manager.io
  resources:
  - certificates
  - certificaterequests
  - issuers
  verbs:
  - create
  - delete
  - deletecollection
  - patch
  - update
---
apiVersion: rbac.authorization.k8s.io/v1beta1
kind: ClusterRoleBinding
metadata:
  annotations: {}
  labels:
    name: cert-manager-issuers
  name: cert-manager-issuers
roleRef:
  apiGroup: rbac.authorization.k8s.io
  kind: ClusterRole
  name: cert-manager-issuers
subjects:
- kind: ServiceAccount
  name: cert-manager
  namespace: kubeprod
---
apiVersion: rbac.authorization.k8s.io/v1beta1
kind: RoleBinding
metadata:
  annotations: {}
  labels:
    name: cert-manager-leaderelection
  name: cert-manager:leaderelection
  namespace: kubeprod
roleRef:
  apiGroup: rbac.authorization.k8s.io
  kind: Role
  name: cert-manager:leaderelection
subjects:
- kind: ServiceAccount
  name: cert-manager
  namespace: kubeprod
---
apiVersion: cert-manager.io/v1alpha2
kind: ClusterIssuer
metadata:
  annotations: {}
  labels:
    name: letsencrypt-prod
  name: letsencrypt-prod
spec:
  acme:
    email: eliegavoty@free.fr
    privateKeySecretRef:
      name: letsencrypt-prod
    server: https://acme-v02.api.letsencrypt.org/directory
    solvers:
    - http01:
        ingress:
          class: nginx
---
apiVersion: rbac.authorization.k8s.io/v1beta1
kind: ClusterRole
metadata:
  annotations: {}
  labels:
    name: cert-manager-orders
  name: cert-manager-orders
rules:
- apiGroups:
  - acme.cert-manager.io
  resources:
  - orders
  - orders/status
  verbs:
  - update
- apiGroups:
  - acme.cert-manager.io
  resources:
  - orders
  - challenges
  verbs:
  - get
  - list
  - watch
- apiGroups:
  - cert-manager.io
  resources:
  - clusterissuers
  - issuers
  verbs:
  - get
  - list
  - watch
- apiGroups:
  - acme.cert-manager.io
  resources:
  - challenges
  verbs:
  - create
  - delete
- apiGroups:
  - acme.cert-manager.io
  resources:
  - orders/finalizers
  verbs:
  - update
- apiGroups:
  - ""
  resources:
  - secrets
  verbs:
  - get
  - list
  - watch
- apiGroups:
  - ""
  resources:
  - events
  verbs:
  - create
  - patch
---
apiVersion: rbac.authorization.k8s.io/v1beta1
kind: ClusterRoleBinding
metadata:
  annotations: {}
  labels:
    name: cert-manager-orders
  name: cert-manager-orders
roleRef:
  apiGroup: rbac.authorization.k8s.io
  kind: ClusterRole
  name: cert-manager-orders
subjects:
- kind: ServiceAccount
  name: cert-manager
  namespace: kubeprod
---
apiVersion: rbac.authorization.k8s.io/v1beta1
kind: ClusterRole
metadata:
  annotations: {}
  labels:
    name: cert-manager-certificates
  name: cert-manager-certificates
rules:
- apiGroups:
  - cert-manager.io
  resources:
  - certificates
  - certificates/status
  - certificaterequests
  - certificaterequests/status
  verbs:
  - update
- apiGroups:
  - cert-manager.io
  resources:
  - certificates
  - certificaterequests
  - clusterissuers
  - issuers
  verbs:
  - get
  - list
  - watch
- apiGroups:
  - cert-manager.io
  resources:
  - certificates/finalizers
  - certificaterequests/finalizers
  verbs:
  - update
- apiGroups:
  - acme.cert-manager.io
  resources:
  - orders
  verbs:
  - create
  - delete
  - get
  - list
  - watch
- apiGroups:
  - ""
  resources:
  - secrets
  verbs:
  - get
  - list
  - watch
  - create
  - update
  - delete
- apiGroups:
  - ""
  resources:
  - events
  verbs:
  - create
  - patch
---
apiVersion: rbac.authorization.k8s.io/v1beta1
kind: ClusterRoleBinding
metadata:
  annotations: {}
  labels:
    name: cert-manager-certificates
  name: cert-manager-certificates
roleRef:
  apiGroup: rbac.authorization.k8s.io
  kind: ClusterRole
  name: cert-manager-certificates
subjects:
- kind: ServiceAccount
  name: cert-manager
  namespace: kubeprod
---
apiVersion: rbac.authorization.k8s.io/v1beta1
kind: ClusterRoleBinding
metadata:
  annotations: {}
  labels:
    name: cert-manager-clusterissuers
  name: cert-manager-clusterissuers
roleRef:
  apiGroup: rbac.authorization.k8s.io
  kind: ClusterRole
  name: cert-manager-clusterissuers
subjects:
- kind: ServiceAccount
  name: cert-manager
  namespace: kubeprod
---
apiVersion: rbac.authorization.k8s.io/v1beta1
kind: ClusterRole
metadata:
  annotations: {}
  labels:
    name: cert-manager-ingress-shim
  name: cert-manager-ingress-shim
rules:
- apiGroups:
  - cert-manager.io
  resources:
  - certificates
  - certificaterequests
  verbs:
  - create
  - update
  - delete
- apiGroups:
  - cert-manager.io
  resources:
  - certificates
  - certificaterequests
  - issuers
  - clusterissuers
  verbs:
  - get
  - list
  - watch
- apiGroups:
  - extensions
  resources:
  - ingresses
  verbs:
  - get
  - list
  - watch
- apiGroups:
  - extensions
  resources:
  - ingresses/finalizers
  verbs:
  - update
- apiGroups:
  - ""
  resources:
  - events
  verbs:
  - create
  - patch
---
apiVersion: rbac.authorization.k8s.io/v1beta1
kind: ClusterRole
metadata:
  annotations: {}
  labels:
    name: cert-manager-clusterissuers
  name: cert-manager-clusterissuers
rules:
- apiGroups:
  - cert-manager.io
  resources:
  - clusterissuers
  - clusterissuers/status
  verbs:
  - update
- apiGroups:
  - cert-manager.io
  resources:
  - clusterissuers
  verbs:
  - get
  - list
  - watch
- apiGroups:
  - ""
  resources:
  - secrets
  verbs:
  - get
  - list
  - watch
  - create
  - update
  - delete
- apiGroups:
  - ""
  resources:
  - events
  verbs:
  - create
  - patch
---
apiVersion: rbac.authorization.k8s.io/v1beta1
kind: ClusterRole
metadata:
  annotations: {}
  labels:
    name: cert-manager-issuers
  name: cert-manager-issuers
rules:
- apiGroups:
  - cert-manager.io
  resources:
  - issuers
  - issuers/status
  verbs:
  - update
- apiGroups:
  - cert-manager.io
  resources:
  - issuers
  verbs:
  - get
  - list
  - watch
- apiGroups:
  - ""
  resources:
  - secrets
  verbs:
  - get
  - list
  - watch
  - create
  - update
  - delete
- apiGroups:
  - ""
  resources:
  - events
  verbs:
  - create
  - patch
---
apiVersion: v1
kind: ServiceAccount
metadata:
  annotations: {}
  labels:
    name: cert-manager
  name: cert-manager
  namespace: kubeprod
---
apiVersion: rbac.authorization.k8s.io/v1beta1
kind: ClusterRoleBinding
metadata:
  annotations: {}
  labels:
    name: cert-manager-ingress-shim
  name: cert-manager-ingress-shim
roleRef:
  apiGroup: rbac.authorization.k8s.io
  kind: ClusterRole
  name: cert-manager-ingress-shim
subjects:
- kind: ServiceAccount
  name: cert-manager
  namespace: kubeprod
---
apiVersion: rbac.authorization.k8s.io/v1beta1
kind: Role
metadata:
  annotations: {}
  labels:
    name: cert-manager-leaderelection
  name: cert-manager:leaderelection
  namespace: kubeprod
rules:
- apiGroups:
  - ""
  resources:
  - configmaps
  verbs:
  - get
  - create
  - update
  - patch
---
apiVersion: cert-manager.io/v1alpha2
kind: ClusterIssuer
metadata:
  annotations: {}
  labels:
    name: letsencrypt-staging
  name: letsencrypt-staging
spec:
  acme:
    email: eliegavoty@free.fr
    privateKeySecretRef:
      name: letsencrypt-staging
    server: https://acme-staging-v02.api.letsencrypt.org/directory
    solvers:
    - http01:
        ingress:
          class: nginx
---
apiVersion: rbac.authorization.k8s.io/v1beta1
kind: ClusterRole
metadata:
  annotations: {}
  labels:
    name: cert-manager-view
  name: cert-manager-view
rules:
- apiGroups:
  - cert-manager.io
  resources:
  - certificates
  - certificaterequests
  - issuers
  verbs:
  - get
  - list
  - watch
---
apiVersion: apiextensions.k8s.io/v1beta1
kind: CustomResourceDefinition
metadata:
  name: certificaterequests.cert-manager.io
spec:
  additionalPrinterColumns:
  - JSONPath: .status.conditions[?(@.type=="Ready")].status
    name: Ready
    type: string
  - JSONPath: .spec.issuerRef.name
    name: Issuer
    priority: 1
    type: string
  - JSONPath: .status.conditions[?(@.type=="Ready")].message
    name: Status
    priority: 1
    type: string
  - JSONPath: .metadata.creationTimestamp
    description: CreationTimestamp is a timestamp representing the server time when
      this object was created. It is not guaranteed to be set in happens-before order
      across separate operations. Clients may not set this value. It is represented
      in RFC3339 form and is in UTC.
    name: Age
    type: date
  group: cert-manager.io
  names:
    kind: CertificateRequest
    listKind: CertificateRequestList
    plural: certificaterequests
    shortNames:
    - cr
    - crs
    singular: certificaterequest
  scope: Namespaced
  subresources:
    status: {}
  validation:
    openAPIV3Schema:
      description: CertificateRequest is a type to represent a Certificate Signing
        Request
      properties:
        apiVersion:
          description: 'APIVersion defines the versioned schema of this representation
            of an object. Servers should convert recognized schemas to the latest
            internal value, and may reject unrecognized values. More info: https://git.k8s.io/community/contributors/devel/sig-architecture/api-conventions.md#resources'
          type: string
        kind:
          description: 'Kind is a string value representing the REST resource this
            object represents. Servers may infer this from the endpoint the client
            submits requests to. Cannot be updated. In CamelCase. More info: https://git.k8s.io/community/contributors/devel/sig-architecture/api-conventions.md#types-kinds'
          type: string
        metadata:
          type: object
        spec:
          description: CertificateRequestSpec defines the desired state of CertificateRequest
          properties:
            csr:
              description: Byte slice containing the PEM encoded CertificateSigningRequest
              format: byte
              type: string
            duration:
              description: Requested certificate default Duration
              type: string
            isCA:
              description: IsCA will mark the resulting certificate as valid for signing.
                This implies that the 'cert sign' usage is set
              type: boolean
            issuerRef:
              description: IssuerRef is a reference to the issuer for this CertificateRequest.  If
                the 'kind' field is not set, or set to 'Issuer', an Issuer resource
                with the given name in the same namespace as the CertificateRequest
                will be used.  If the 'kind' field is set to 'ClusterIssuer', a ClusterIssuer
                with the provided name will be used. The 'name' field in this stanza
                is required at all times. The group field refers to the API group
                of the issuer which defaults to 'cert-manager.io' if empty.
              properties:
                group:
                  type: string
                kind:
                  type: string
                name:
                  type: string
              required:
              - name
              type: object
            usages:
              description: Usages is the set of x509 actions that are enabled for
                a given key. Defaults are ('digital signature', 'key encipherment')
                if empty
              items:
                description: 'KeyUsage specifies valid usage contexts for keys. See:
                  https://tools.ietf.org/html/rfc5280#section-4.2.1.3      https://tools.ietf.org/html/rfc5280#section-4.2.1.12
                  Valid KeyUsage values are as follows: "signing", "digital signature",
                  "content commitment", "key encipherment", "key agreement", "data
                  encipherment", "cert sign", "crl sign", "encipher only", "decipher
                  only", "any", "server auth", "client auth", "code signing", "email
                  protection", "s/mime", "ipsec end system", "ipsec tunnel", "ipsec
                  user", "timestamping", "ocsp signing", "microsoft sgc", "netscape
                  sgc"'
                enum:
                - signing
                - digital signature
                - content commitment
                - key encipherment
                - key agreement
                - data encipherment
                - cert sign
                - crl sign
                - encipher only
                - decipher only
                - any
                - server auth
                - client auth
                - code signing
                - email protection
                - s/mime
                - ipsec end system
                - ipsec tunnel
                - ipsec user
                - timestamping
                - ocsp signing
                - microsoft sgc
                - netscape sgc
                type: string
              type: array
          required:
          - csr
          - issuerRef
          type: object
        status:
          description: CertificateStatus defines the observed state of CertificateRequest
            and resulting signed certificate.
          properties:
            ca:
              description: Byte slice containing the PEM encoded certificate authority
                of the signed certificate.
              format: byte
              type: string
            certificate:
              description: Byte slice containing a PEM encoded signed certificate
                resulting from the given certificate signing request.
              format: byte
              type: string
            conditions:
              items:
                description: CertificateRequestCondition contains condition information
                  for a CertificateRequest.
                properties:
                  lastTransitionTime:
                    description: LastTransitionTime is the timestamp corresponding
                      to the last status change of this condition.
                    format: date-time
                    type: string
                  message:
                    description: Message is a human readable description of the details
                      of the last transition, complementing reason.
                    type: string
                  reason:
                    description: Reason is a brief machine readable explanation for
                      the condition's last transition.
                    type: string
                  status:
                    description: Status of the condition, one of ('True', 'False',
                      'Unknown').
                    enum:
                    - "True"
                    - "False"
                    - Unknown
                    type: string
                  type:
                    description: Type of the condition, currently ('Ready').
                    type: string
                required:
                - status
                - type
                type: object
              type: array
            failureTime:
              description: FailureTime stores the time that this CertificateRequest
                failed. This is used to influence garbage collection and back-off.
              format: date-time
              type: string
          type: object
      type: object
  version: v1alpha2
  versions:
  - name: v1alpha2
    served: true
    storage: true
---
apiVersion: apiextensions.k8s.io/v1beta1
kind: CustomResourceDefinition
metadata:
  name: certificates.cert-manager.io
spec:
  additionalPrinterColumns:
  - JSONPath: .status.conditions[?(@.type=="Ready")].status
    name: Ready
    type: string
  - JSONPath: .spec.secretName
    name: Secret
    type: string
  - JSONPath: .spec.issuerRef.name
    name: Issuer
    priority: 1
    type: string
  - JSONPath: .status.conditions[?(@.type=="Ready")].message
    name: Status
    priority: 1
    type: string
  - JSONPath: .metadata.creationTimestamp
    description: CreationTimestamp is a timestamp representing the server time when
      this object was created. It is not guaranteed to be set in happens-before order
      across separate operations. Clients may not set this value. It is represented
      in RFC3339 form and is in UTC.
    name: Age
    type: date
  group: cert-manager.io
  names:
    kind: Certificate
    listKind: CertificateList
    plural: certificates
    shortNames:
    - cert
    - certs
    singular: certificate
  scope: Namespaced
  subresources:
    status: {}
  validation:
    openAPIV3Schema:
      description: Certificate is a type to represent a Certificate from ACME
      properties:
        apiVersion:
          description: 'APIVersion defines the versioned schema of this representation
            of an object. Servers should convert recognized schemas to the latest
            internal value, and may reject unrecognized values. More info: https://git.k8s.io/community/contributors/devel/sig-architecture/api-conventions.md#resources'
          type: string
        kind:
          description: 'Kind is a string value representing the REST resource this
            object represents. Servers may infer this from the endpoint the client
            submits requests to. Cannot be updated. In CamelCase. More info: https://git.k8s.io/community/contributors/devel/sig-architecture/api-conventions.md#types-kinds'
          type: string
        metadata:
          type: object
        spec:
          description: CertificateSpec defines the desired state of Certificate. A
            valid Certificate requires at least one of a CommonName, DNSName, or URISAN
            to be valid.
          properties:
            commonName:
              description: CommonName is a common name to be used on the Certificate.
                The CommonName should have a length of 64 characters or fewer to avoid
                generating invalid CSRs.
              type: string
            dnsNames:
              description: DNSNames is a list of subject alt names to be used on the
                Certificate.
              items:
                type: string
              type: array
            duration:
              description: Certificate default Duration
              type: string
            ipAddresses:
              description: IPAddresses is a list of IP addresses to be used on the
                Certificate
              items:
                type: string
              type: array
            isCA:
              description: IsCA will mark this Certificate as valid for signing. This
                implies that the 'cert sign' usage is set
              type: boolean
            issuerRef:
              description: IssuerRef is a reference to the issuer for this certificate.
                If the 'kind' field is not set, or set to 'Issuer', an Issuer resource
                with the given name in the same namespace as the Certificate will
                be used. If the 'kind' field is set to 'ClusterIssuer', a ClusterIssuer
                with the provided name will be used. The 'name' field in this stanza
                is required at all times.
              properties:
                group:
                  type: string
                kind:
                  type: string
                name:
                  type: string
              required:
              - name
              type: object
            keyAlgorithm:
              description: KeyAlgorithm is the private key algorithm of the corresponding
                private key for this certificate. If provided, allowed values are
                either "rsa" or "ecdsa" If KeyAlgorithm is specified and KeySize is
                not provided, key size of 256 will be used for "ecdsa" key algorithm
                and key size of 2048 will be used for "rsa" key algorithm.
              enum:
              - rsa
              - ecdsa
              type: string
            keyEncoding:
              description: KeyEncoding is the private key cryptography standards (PKCS)
                for this certificate's private key to be encoded in. If provided,
                allowed values are "pkcs1" and "pkcs8" standing for PKCS#1 and PKCS#8,
                respectively. If KeyEncoding is not specified, then PKCS#1 will be
                used by default.
              enum:
              - pkcs1
              - pkcs8
              type: string
            keySize:
              description: KeySize is the key bit size of the corresponding private
                key for this certificate. If provided, value must be between 2048
                and 8192 inclusive when KeyAlgorithm is empty or is set to "rsa",
                and value must be one of (256, 384, 521) when KeyAlgorithm is set
                to "ecdsa".
              type: integer
            organization:
              description: Organization is the organization to be used on the Certificate
              items:
                type: string
              type: array
            renewBefore:
              description: Certificate renew before expiration duration
              type: string
            secretName:
              description: SecretName is the name of the secret resource to store
                this secret in
              type: string
            uriSANs:
              description: URISANs is a list of URI Subject Alternative Names to be
                set on this Certificate.
              items:
                type: string
              type: array
            usages:
              description: Usages is the set of x509 actions that are enabled for
                a given key. Defaults are ('digital signature', 'key encipherment')
                if empty
              items:
                description: 'KeyUsage specifies valid usage contexts for keys. See:
                  https://tools.ietf.org/html/rfc5280#section-4.2.1.3      https://tools.ietf.org/html/rfc5280#section-4.2.1.12
                  Valid KeyUsage values are as follows: "signing", "digital signature",
                  "content commitment", "key encipherment", "key agreement", "data
                  encipherment", "cert sign", "crl sign", "encipher only", "decipher
                  only", "any", "server auth", "client auth", "code signing", "email
                  protection", "s/mime", "ipsec end system", "ipsec tunnel", "ipsec
                  user", "timestamping", "ocsp signing", "microsoft sgc", "netscape
                  sgc"'
                enum:
                - signing
                - digital signature
                - content commitment
                - key encipherment
                - key agreement
                - data encipherment
                - cert sign
                - crl sign
                - encipher only
                - decipher only
                - any
                - server auth
                - client auth
                - code signing
                - email protection
                - s/mime
                - ipsec end system
                - ipsec tunnel
                - ipsec user
                - timestamping
                - ocsp signing
                - microsoft sgc
                - netscape sgc
                type: string
              type: array
          required:
          - issuerRef
          - secretName
          type: object
        status:
          description: CertificateStatus defines the observed state of Certificate
          properties:
            conditions:
              items:
                description: CertificateCondition contains condition information for
                  an Certificate.
                properties:
                  lastTransitionTime:
                    description: LastTransitionTime is the timestamp corresponding
                      to the last status change of this condition.
                    format: date-time
                    type: string
                  message:
                    description: Message is a human readable description of the details
                      of the last transition, complementing reason.
                    type: string
                  reason:
                    description: Reason is a brief machine readable explanation for
                      the condition's last transition.
                    type: string
                  status:
                    description: Status of the condition, one of ('True', 'False',
                      'Unknown').
                    enum:
                    - "True"
                    - "False"
                    - Unknown
                    type: string
                  type:
                    description: Type of the condition, currently ('Ready').
                    type: string
                required:
                - status
                - type
                type: object
              type: array
            lastFailureTime:
              format: date-time
              type: string
            notAfter:
              description: The expiration time of the certificate stored in the secret
                named by this resource in spec.secretName.
              format: date-time
              type: string
          type: object
      type: object
  version: v1alpha2
  versions:
  - name: v1alpha2
    served: true
    storage: true
---
apiVersion: apiextensions.k8s.io/v1beta1
kind: CustomResourceDefinition
metadata:
  name: challenges.acme.cert-manager.io
spec:
  additionalPrinterColumns:
  - JSONPath: .status.state
    name: State
    type: string
  - JSONPath: .spec.dnsName
    name: Domain
    type: string
  - JSONPath: .status.reason
    name: Reason
    priority: 1
    type: string
  - JSONPath: .metadata.creationTimestamp
    description: CreationTimestamp is a timestamp representing the server time when
      this object was created. It is not guaranteed to be set in happens-before order
      across separate operations. Clients may not set this value. It is represented
      in RFC3339 form and is in UTC.
    name: Age
    type: date
  group: acme.cert-manager.io
  names:
    kind: Challenge
    listKind: ChallengeList
    plural: challenges
    singular: challenge
  scope: Namespaced
  subresources:
    status: {}
  validation:
    openAPIV3Schema:
      description: Challenge is a type to represent a Challenge request with an ACME
        server
      properties:
        apiVersion:
          description: 'APIVersion defines the versioned schema of this representation
            of an object. Servers should convert recognized schemas to the latest
            internal value, and may reject unrecognized values. More info: https://git.k8s.io/community/contributors/devel/sig-architecture/api-conventions.md#resources'
          type: string
        kind:
          description: 'Kind is a string value representing the REST resource this
            object represents. Servers may infer this from the endpoint the client
            submits requests to. Cannot be updated. In CamelCase. More info: https://git.k8s.io/community/contributors/devel/sig-architecture/api-conventions.md#types-kinds'
          type: string
        metadata:
          type: object
        spec:
          properties:
            authzURL:
              description: AuthzURL is the URL to the ACME Authorization resource
                that this challenge is a part of.
              type: string
            dnsName:
              description: DNSName is the identifier that this challenge is for, e.g.
                example.com.
              type: string
            issuerRef:
              description: IssuerRef references a properly configured ACME-type Issuer
                which should be used to create this Challenge. If the Issuer does
                not exist, processing will be retried. If the Issuer is not an 'ACME'
                Issuer, an error will be returned and the Challenge will be marked
                as failed.
              properties:
                group:
                  type: string
                kind:
                  type: string
                name:
                  type: string
              required:
              - name
              type: object
            key:
              description: Key is the ACME challenge key for this challenge
              type: string
            solver:
              description: Solver contains the domain solving configuration that should
                be used to solve this challenge resource.
              properties:
                dns01:
                  properties:
                    acmedns:
                      description: ACMEIssuerDNS01ProviderAcmeDNS is a structure containing
                        the configuration for ACME-DNS servers
                      properties:
                        accountSecretRef:
                          properties:
                            key:
                              description: The key of the secret to select from. Must
                                be a valid secret key.
                              type: string
                            name:
                              description: 'Name of the referent. More info: https://kubernetes.io/docs/concepts/overview/working-with-objects/names/#names
                                TODO: Add other useful fields. apiVersion, kind, uid?'
                              type: string
                          required:
                          - name
                          type: object
                        host:
                          type: string
                      required:
                      - accountSecretRef
                      - host
                      type: object
                    akamai:
                      description: ACMEIssuerDNS01ProviderAkamai is a structure containing
                        the DNS configuration for Akamai DNS—Zone Record Management
                        API
                      properties:
                        accessTokenSecretRef:
                          properties:
                            key:
                              description: The key of the secret to select from. Must
                                be a valid secret key.
                              type: string
                            name:
                              description: 'Name of the referent. More info: https://kubernetes.io/docs/concepts/overview/working-with-objects/names/#names
                                TODO: Add other useful fields. apiVersion, kind, uid?'
                              type: string
                          required:
                          - name
                          type: object
                        clientSecretSecretRef:
                          properties:
                            key:
                              description: The key of the secret to select from. Must
                                be a valid secret key.
                              type: string
                            name:
                              description: 'Name of the referent. More info: https://kubernetes.io/docs/concepts/overview/working-with-objects/names/#names
                                TODO: Add other useful fields. apiVersion, kind, uid?'
                              type: string
                          required:
                          - name
                          type: object
                        clientTokenSecretRef:
                          properties:
                            key:
                              description: The key of the secret to select from. Must
                                be a valid secret key.
                              type: string
                            name:
                              description: 'Name of the referent. More info: https://kubernetes.io/docs/concepts/overview/working-with-objects/names/#names
                                TODO: Add other useful fields. apiVersion, kind, uid?'
                              type: string
                          required:
                          - name
                          type: object
                        serviceConsumerDomain:
                          type: string
                      required:
                      - accessTokenSecretRef
                      - clientSecretSecretRef
                      - clientTokenSecretRef
                      - serviceConsumerDomain
                      type: object
                    azuredns:
                      description: ACMEIssuerDNS01ProviderAzureDNS is a structure
                        containing the configuration for Azure DNS
                      properties:
                        clientID:
                          type: string
                        clientSecretSecretRef:
                          properties:
                            key:
                              description: The key of the secret to select from. Must
                                be a valid secret key.
                              type: string
                            name:
                              description: 'Name of the referent. More info: https://kubernetes.io/docs/concepts/overview/working-with-objects/names/#names
                                TODO: Add other useful fields. apiVersion, kind, uid?'
                              type: string
                          required:
                          - name
                          type: object
                        environment:
                          enum:
                          - AzurePublicCloud
                          - AzureChinaCloud
                          - AzureGermanCloud
                          - AzureUSGovernmentCloud
                          type: string
                        hostedZoneName:
                          type: string
                        resourceGroupName:
                          type: string
                        subscriptionID:
                          type: string
                        tenantID:
                          type: string
                      required:
                      - clientID
                      - clientSecretSecretRef
                      - resourceGroupName
                      - subscriptionID
                      - tenantID
                      type: object
                    clouddns:
                      description: ACMEIssuerDNS01ProviderCloudDNS is a structure
                        containing the DNS configuration for Google Cloud DNS
                      properties:
                        project:
                          type: string
                        serviceAccountSecretRef:
                          properties:
                            key:
                              description: The key of the secret to select from. Must
                                be a valid secret key.
                              type: string
                            name:
                              description: 'Name of the referent. More info: https://kubernetes.io/docs/concepts/overview/working-with-objects/names/#names
                                TODO: Add other useful fields. apiVersion, kind, uid?'
                              type: string
                          required:
                          - name
                          type: object
                      required:
                      - project
                      type: object
                    cloudflare:
                      description: ACMEIssuerDNS01ProviderCloudflare is a structure
                        containing the DNS configuration for Cloudflare
                      properties:
                        apiKeySecretRef:
                          properties:
                            key:
                              description: The key of the secret to select from. Must
                                be a valid secret key.
                              type: string
                            name:
                              description: 'Name of the referent. More info: https://kubernetes.io/docs/concepts/overview/working-with-objects/names/#names
                                TODO: Add other useful fields. apiVersion, kind, uid?'
                              type: string
                          required:
                          - name
                          type: object
                        apiTokenSecretRef:
                          properties:
                            key:
                              description: The key of the secret to select from. Must
                                be a valid secret key.
                              type: string
                            name:
                              description: 'Name of the referent. More info: https://kubernetes.io/docs/concepts/overview/working-with-objects/names/#names
                                TODO: Add other useful fields. apiVersion, kind, uid?'
                              type: string
                          required:
                          - name
                          type: object
                        email:
                          type: string
                      required:
                      - email
                      type: object
                    cnameStrategy:
                      description: CNAMEStrategy configures how the DNS01 provider
                        should handle CNAME records when found in DNS zones.
                      enum:
                      - None
                      - Follow
                      type: string
                    digitalocean:
                      description: ACMEIssuerDNS01ProviderDigitalOcean is a structure
                        containing the DNS configuration for DigitalOcean Domains
                      properties:
                        tokenSecretRef:
                          properties:
                            key:
                              description: The key of the secret to select from. Must
                                be a valid secret key.
                              type: string
                            name:
                              description: 'Name of the referent. More info: https://kubernetes.io/docs/concepts/overview/working-with-objects/names/#names
                                TODO: Add other useful fields. apiVersion, kind, uid?'
                              type: string
                          required:
                          - name
                          type: object
                      required:
                      - tokenSecretRef
                      type: object
                    rfc2136:
                      description: ACMEIssuerDNS01ProviderRFC2136 is a structure containing
                        the configuration for RFC2136 DNS
                      properties:
                        nameserver:
                          description: 'The IP address of the DNS supporting RFC2136.
                            Required. Note: FQDN is not a valid value, only IP.'
                          type: string
                        tsigAlgorithm:
                          description: 'The TSIG Algorithm configured in the DNS supporting
                            RFC2136. Used only when ``tsigSecretSecretRef`` and ``tsigKeyName``
                            are defined. Supported values are (case-insensitive):
                            ``HMACMD5`` (default), ``HMACSHA1``, ``HMACSHA256`` or
                            ``HMACSHA512``.'
                          type: string
                        tsigKeyName:
                          description: The TSIG Key name configured in the DNS. If
                            ``tsigSecretSecretRef`` is defined, this field is required.
                          type: string
                        tsigSecretSecretRef:
                          description: The name of the secret containing the TSIG
                            value. If ``tsigKeyName`` is defined, this field is required.
                          properties:
                            key:
                              description: The key of the secret to select from. Must
                                be a valid secret key.
                              type: string
                            name:
                              description: 'Name of the referent. More info: https://kubernetes.io/docs/concepts/overview/working-with-objects/names/#names
                                TODO: Add other useful fields. apiVersion, kind, uid?'
                              type: string
                          required:
                          - name
                          type: object
                      required:
                      - nameserver
                      type: object
                    route53:
                      description: ACMEIssuerDNS01ProviderRoute53 is a structure containing
                        the Route 53 configuration for AWS
                      properties:
                        accessKeyID:
                          description: 'The AccessKeyID is used for authentication.
                            If not set we fall-back to using env vars, shared credentials
                            file or AWS Instance metadata see: https://docs.aws.amazon.com/sdk-for-go/v1/developer-guide/configuring-sdk.html#specifying-credentials'
                          type: string
                        hostedZoneID:
                          description: If set, the provider will manage only this
                            zone in Route53 and will not do an lookup using the route53:ListHostedZonesByName
                            api call.
                          type: string
                        region:
                          description: Always set the region when using AccessKeyID
                            and SecretAccessKey
                          type: string
                        role:
                          description: Role is a Role ARN which the Route53 provider
                            will assume using either the explicit credentials AccessKeyID/SecretAccessKey
                            or the inferred credentials from environment variables,
                            shared credentials file or AWS Instance metadata
                          type: string
                        secretAccessKeySecretRef:
                          description: The SecretAccessKey is used for authentication.
                            If not set we fall-back to using env vars, shared credentials
                            file or AWS Instance metadata https://docs.aws.amazon.com/sdk-for-go/v1/developer-guide/configuring-sdk.html#specifying-credentials
                          properties:
                            key:
                              description: The key of the secret to select from. Must
                                be a valid secret key.
                              type: string
                            name:
                              description: 'Name of the referent. More info: https://kubernetes.io/docs/concepts/overview/working-with-objects/names/#names
                                TODO: Add other useful fields. apiVersion, kind, uid?'
                              type: string
                          required:
                          - name
                          type: object
                      required:
                      - region
                      type: object
                    webhook:
                      description: ACMEIssuerDNS01ProviderWebhook specifies configuration
                        for a webhook DNS01 provider, including where to POST ChallengePayload
                        resources.
                      properties:
                        config:
                          description: Additional configuration that should be passed
                            to the webhook apiserver when challenges are processed.
                            This can contain arbitrary JSON data. Secret values should
                            not be specified in this stanza. If secret values are
                            needed (e.g. credentials for a DNS service), you should
                            use a SecretKeySelector to reference a Secret resource.
                            For details on the schema of this field, consult the webhook
                            provider implementation's documentation.
                        groupName:
                          description: The API group name that should be used when
                            POSTing ChallengePayload resources to the webhook apiserver.
                            This should be the same as the GroupName specified in
                            the webhook provider implementation.
                          type: string
                        solverName:
                          description: The name of the solver to use, as defined in
                            the webhook provider implementation. This will typically
                            be the name of the provider, e.g. 'cloudflare'.
                          type: string
                      required:
                      - groupName
                      - solverName
                      type: object
                  type: object
                http01:
                  description: ACMEChallengeSolverHTTP01 contains configuration detailing
                    how to solve HTTP01 challenges within a Kubernetes cluster. Typically
                    this is accomplished through creating 'routes' of some description
                    that configure ingress controllers to direct traffic to 'solver
                    pods', which are responsible for responding to the ACME server's
                    HTTP requests.
                  properties:
                    ingress:
                      description: The ingress based HTTP01 challenge solver will
                        solve challenges by creating or modifying Ingress resources
                        in order to route requests for '/.well-known/acme-challenge/XYZ'
                        to 'challenge solver' pods that are provisioned by cert-manager
                        for each Challenge to be completed.
                      properties:
                        class:
                          description: The ingress class to use when creating Ingress
                            resources to solve ACME challenges that use this challenge
                            solver. Only one of 'class' or 'name' may be specified.
                          type: string
                        name:
                          description: The name of the ingress resource that should
                            have ACME challenge solving routes inserted into it in
                            order to solve HTTP01 challenges. This is typically used
                            in conjunction with ingress controllers like ingress-gce,
                            which maintains a 1:1 mapping between external IPs and
                            ingress resources.
                          type: string
                        podTemplate:
                          description: Optional pod template used to configure the
                            ACME challenge solver pods used for HTTP01 challenges
                          properties:
                            metadata:
                              description: ObjectMeta overrides for the pod used to
                                solve HTTP01 challenges. Only the 'labels' and 'annotations'
                                fields may be set. If labels or annotations overlap
                                with in-built values, the values here will override
                                the in-built values.
                              properties:
                                annotations:
                                  additionalProperties:
                                    type: string
                                  description: Annotations that should be added to
                                    the create ACME HTTP01 solver pods.
                                  type: object
                                labels:
                                  additionalProperties:
                                    type: string
                                  description: Labels that should be added to the
                                    created ACME HTTP01 solver pods.
                                  type: object
                              type: object
                            spec:
                              description: PodSpec defines overrides for the HTTP01
                                challenge solver pod. Only the 'nodeSelector', 'affinity'
                                and 'tolerations' fields are supported currently.
                                All other fields will be ignored.
                              properties:
                                affinity:
                                  description: If specified, the pod's scheduling
                                    constraints
                                  properties:
                                    nodeAffinity:
                                      description: Describes node affinity scheduling
                                        rules for the pod.
                                      properties:
                                        preferredDuringSchedulingIgnoredDuringExecution:
                                          description: The scheduler will prefer to
                                            schedule pods to nodes that satisfy the
                                            affinity expressions specified by this
                                            field, but it may choose a node that violates
                                            one or more of the expressions. The node
                                            that is most preferred is the one with
                                            the greatest sum of weights, i.e. for
                                            each node that meets all of the scheduling
                                            requirements (resource request, requiredDuringScheduling
                                            affinity expressions, etc.), compute a
                                            sum by iterating through the elements
                                            of this field and adding "weight" to the
                                            sum if the node matches the corresponding
                                            matchExpressions; the node(s) with the
                                            highest sum are the most preferred.
                                          items:
                                            description: An empty preferred scheduling
                                              term matches all objects with implicit
                                              weight 0 (i.e. it's a no-op). A null
                                              preferred scheduling term matches no
                                              objects (i.e. is also a no-op).
                                            properties:
                                              preference:
                                                description: A node selector term,
                                                  associated with the corresponding
                                                  weight.
                                                properties:
                                                  matchExpressions:
                                                    description: A list of node selector
                                                      requirements by node's labels.
                                                    items:
                                                      description: A node selector
                                                        requirement is a selector
                                                        that contains values, a key,
                                                        and an operator that relates
                                                        the key and values.
                                                      properties:
                                                        key:
                                                          description: The label key
                                                            that the selector applies
                                                            to.
                                                          type: string
                                                        operator:
                                                          description: Represents
                                                            a key's relationship to
                                                            a set of values. Valid
                                                            operators are In, NotIn,
                                                            Exists, DoesNotExist.
                                                            Gt, and Lt.
                                                          type: string
                                                        values:
                                                          description: An array of
                                                            string values. If the
                                                            operator is In or NotIn,
                                                            the values array must
                                                            be non-empty. If the operator
                                                            is Exists or DoesNotExist,
                                                            the values array must
                                                            be empty. If the operator
                                                            is Gt or Lt, the values
                                                            array must have a single
                                                            element, which will be
                                                            interpreted as an integer.
                                                            This array is replaced
                                                            during a strategic merge
                                                            patch.
                                                          items:
                                                            type: string
                                                          type: array
                                                      required:
                                                      - key
                                                      - operator
                                                      type: object
                                                    type: array
                                                  matchFields:
                                                    description: A list of node selector
                                                      requirements by node's fields.
                                                    items:
                                                      description: A node selector
                                                        requirement is a selector
                                                        that contains values, a key,
                                                        and an operator that relates
                                                        the key and values.
                                                      properties:
                                                        key:
                                                          description: The label key
                                                            that the selector applies
                                                            to.
                                                          type: string
                                                        operator:
                                                          description: Represents
                                                            a key's relationship to
                                                            a set of values. Valid
                                                            operators are In, NotIn,
                                                            Exists, DoesNotExist.
                                                            Gt, and Lt.
                                                          type: string
                                                        values:
                                                          description: An array of
                                                            string values. If the
                                                            operator is In or NotIn,
                                                            the values array must
                                                            be non-empty. If the operator
                                                            is Exists or DoesNotExist,
                                                            the values array must
                                                            be empty. If the operator
                                                            is Gt or Lt, the values
                                                            array must have a single
                                                            element, which will be
                                                            interpreted as an integer.
                                                            This array is replaced
                                                            during a strategic merge
                                                            patch.
                                                          items:
                                                            type: string
                                                          type: array
                                                      required:
                                                      - key
                                                      - operator
                                                      type: object
                                                    type: array
                                                type: object
                                              weight:
                                                description: Weight associated with
                                                  matching the corresponding nodeSelectorTerm,
                                                  in the range 1-100.
                                                format: int32
                                                type: integer
                                            required:
                                            - preference
                                            - weight
                                            type: object
                                          type: array
                                        requiredDuringSchedulingIgnoredDuringExecution:
                                          description: If the affinity requirements
                                            specified by this field are not met at
                                            scheduling time, the pod will not be scheduled
                                            onto the node. If the affinity requirements
                                            specified by this field cease to be met
                                            at some point during pod execution (e.g.
                                            due to an update), the system may or may
                                            not try to eventually evict the pod from
                                            its node.
                                          properties:
                                            nodeSelectorTerms:
                                              description: Required. A list of node
                                                selector terms. The terms are ORed.
                                              items:
                                                description: A null or empty node
                                                  selector term matches no objects.
                                                  The requirements of them are ANDed.
                                                  The TopologySelectorTerm type implements
                                                  a subset of the NodeSelectorTerm.
                                                properties:
                                                  matchExpressions:
                                                    description: A list of node selector
                                                      requirements by node's labels.
                                                    items:
                                                      description: A node selector
                                                        requirement is a selector
                                                        that contains values, a key,
                                                        and an operator that relates
                                                        the key and values.
                                                      properties:
                                                        key:
                                                          description: The label key
                                                            that the selector applies
                                                            to.
                                                          type: string
                                                        operator:
                                                          description: Represents
                                                            a key's relationship to
                                                            a set of values. Valid
                                                            operators are In, NotIn,
                                                            Exists, DoesNotExist.
                                                            Gt, and Lt.
                                                          type: string
                                                        values:
                                                          description: An array of
                                                            string values. If the
                                                            operator is In or NotIn,
                                                            the values array must
                                                            be non-empty. If the operator
                                                            is Exists or DoesNotExist,
                                                            the values array must
                                                            be empty. If the operator
                                                            is Gt or Lt, the values
                                                            array must have a single
                                                            element, which will be
                                                            interpreted as an integer.
                                                            This array is replaced
                                                            during a strategic merge
                                                            patch.
                                                          items:
                                                            type: string
                                                          type: array
                                                      required:
                                                      - key
                                                      - operator
                                                      type: object
                                                    type: array
                                                  matchFields:
                                                    description: A list of node selector
                                                      requirements by node's fields.
                                                    items:
                                                      description: A node selector
                                                        requirement is a selector
                                                        that contains values, a key,
                                                        and an operator that relates
                                                        the key and values.
                                                      properties:
                                                        key:
                                                          description: The label key
                                                            that the selector applies
                                                            to.
                                                          type: string
                                                        operator:
                                                          description: Represents
                                                            a key's relationship to
                                                            a set of values. Valid
                                                            operators are In, NotIn,
                                                            Exists, DoesNotExist.
                                                            Gt, and Lt.
                                                          type: string
                                                        values:
                                                          description: An array of
                                                            string values. If the
                                                            operator is In or NotIn,
                                                            the values array must
                                                            be non-empty. If the operator
                                                            is Exists or DoesNotExist,
                                                            the values array must
                                                            be empty. If the operator
                                                            is Gt or Lt, the values
                                                            array must have a single
                                                            element, which will be
                                                            interpreted as an integer.
                                                            This array is replaced
                                                            during a strategic merge
                                                            patch.
                                                          items:
                                                            type: string
                                                          type: array
                                                      required:
                                                      - key
                                                      - operator
                                                      type: object
                                                    type: array
                                                type: object
                                              type: array
                                          required:
                                          - nodeSelectorTerms
                                          type: object
                                      type: object
                                    podAffinity:
                                      description: Describes pod affinity scheduling
                                        rules (e.g. co-locate this pod in the same
                                        node, zone, etc. as some other pod(s)).
                                      properties:
                                        preferredDuringSchedulingIgnoredDuringExecution:
                                          description: The scheduler will prefer to
                                            schedule pods to nodes that satisfy the
                                            affinity expressions specified by this
                                            field, but it may choose a node that violates
                                            one or more of the expressions. The node
                                            that is most preferred is the one with
                                            the greatest sum of weights, i.e. for
                                            each node that meets all of the scheduling
                                            requirements (resource request, requiredDuringScheduling
                                            affinity expressions, etc.), compute a
                                            sum by iterating through the elements
                                            of this field and adding "weight" to the
                                            sum if the node has pods which matches
                                            the corresponding podAffinityTerm; the
                                            node(s) with the highest sum are the most
                                            preferred.
                                          items:
                                            description: The weights of all of the
                                              matched WeightedPodAffinityTerm fields
                                              are added per-node to find the most
                                              preferred node(s)
                                            properties:
                                              podAffinityTerm:
                                                description: Required. A pod affinity
                                                  term, associated with the corresponding
                                                  weight.
                                                properties:
                                                  labelSelector:
                                                    description: A label query over
                                                      a set of resources, in this
                                                      case pods.
                                                    properties:
                                                      matchExpressions:
                                                        description: matchExpressions
                                                          is a list of label selector
                                                          requirements. The requirements
                                                          are ANDed.
                                                        items:
                                                          description: A label selector
                                                            requirement is a selector
                                                            that contains values,
                                                            a key, and an operator
                                                            that relates the key and
                                                            values.
                                                          properties:
                                                            key:
                                                              description: key is
                                                                the label key that
                                                                the selector applies
                                                                to.
                                                              type: string
                                                            operator:
                                                              description: operator
                                                                represents a key's
                                                                relationship to a
                                                                set of values. Valid
                                                                operators are In,
                                                                NotIn, Exists and
                                                                DoesNotExist.
                                                              type: string
                                                            values:
                                                              description: values
                                                                is an array of string
                                                                values. If the operator
                                                                is In or NotIn, the
                                                                values array must
                                                                be non-empty. If the
                                                                operator is Exists
                                                                or DoesNotExist, the
                                                                values array must
                                                                be empty. This array
                                                                is replaced during
                                                                a strategic merge
                                                                patch.
                                                              items:
                                                                type: string
                                                              type: array
                                                          required:
                                                          - key
                                                          - operator
                                                          type: object
                                                        type: array
                                                      matchLabels:
                                                        additionalProperties:
                                                          type: string
                                                        description: matchLabels is
                                                          a map of {key,value} pairs.
                                                          A single {key,value} in
                                                          the matchLabels map is equivalent
                                                          to an element of matchExpressions,
                                                          whose key field is "key",
                                                          the operator is "In", and
                                                          the values array contains
                                                          only "value". The requirements
                                                          are ANDed.
                                                        type: object
                                                    type: object
                                                  namespaces:
                                                    description: namespaces specifies
                                                      which namespaces the labelSelector
                                                      applies to (matches against);
                                                      null or empty list means "this
                                                      pod's namespace"
                                                    items:
                                                      type: string
                                                    type: array
                                                  topologyKey:
                                                    description: This pod should be
                                                      co-located (affinity) or not
                                                      co-located (anti-affinity) with
                                                      the pods matching the labelSelector
                                                      in the specified namespaces,
                                                      where co-located is defined
                                                      as running on a node whose value
                                                      of the label with key topologyKey
                                                      matches that of any node on
                                                      which any of the selected pods
                                                      is running. Empty topologyKey
                                                      is not allowed.
                                                    type: string
                                                required:
                                                - topologyKey
                                                type: object
                                              weight:
                                                description: weight associated with
                                                  matching the corresponding podAffinityTerm,
                                                  in the range 1-100.
                                                format: int32
                                                type: integer
                                            required:
                                            - podAffinityTerm
                                            - weight
                                            type: object
                                          type: array
                                        requiredDuringSchedulingIgnoredDuringExecution:
                                          description: If the affinity requirements
                                            specified by this field are not met at
                                            scheduling time, the pod will not be scheduled
                                            onto the node. If the affinity requirements
                                            specified by this field cease to be met
                                            at some point during pod execution (e.g.
                                            due to a pod label update), the system
                                            may or may not try to eventually evict
                                            the pod from its node. When there are
                                            multiple elements, the lists of nodes
                                            corresponding to each podAffinityTerm
                                            are intersected, i.e. all terms must be
                                            satisfied.
                                          items:
                                            description: Defines a set of pods (namely
                                              those matching the labelSelector relative
                                              to the given namespace(s)) that this
                                              pod should be co-located (affinity)
                                              or not co-located (anti-affinity) with,
                                              where co-located is defined as running
                                              on a node whose value of the label with
                                              key <topologyKey> matches that of any
                                              node on which a pod of the set of pods
                                              is running
                                            properties:
                                              labelSelector:
                                                description: A label query over a
                                                  set of resources, in this case pods.
                                                properties:
                                                  matchExpressions:
                                                    description: matchExpressions
                                                      is a list of label selector
                                                      requirements. The requirements
                                                      are ANDed.
                                                    items:
                                                      description: A label selector
                                                        requirement is a selector
                                                        that contains values, a key,
                                                        and an operator that relates
                                                        the key and values.
                                                      properties:
                                                        key:
                                                          description: key is the
                                                            label key that the selector
                                                            applies to.
                                                          type: string
                                                        operator:
                                                          description: operator represents
                                                            a key's relationship to
                                                            a set of values. Valid
                                                            operators are In, NotIn,
                                                            Exists and DoesNotExist.
                                                          type: string
                                                        values:
                                                          description: values is an
                                                            array of string values.
                                                            If the operator is In
                                                            or NotIn, the values array
                                                            must be non-empty. If
                                                            the operator is Exists
                                                            or DoesNotExist, the values
                                                            array must be empty. This
                                                            array is replaced during
                                                            a strategic merge patch.
                                                          items:
                                                            type: string
                                                          type: array
                                                      required:
                                                      - key
                                                      - operator
                                                      type: object
                                                    type: array
                                                  matchLabels:
                                                    additionalProperties:
                                                      type: string
                                                    description: matchLabels is a
                                                      map of {key,value} pairs. A
                                                      single {key,value} in the matchLabels
                                                      map is equivalent to an element
                                                      of matchExpressions, whose key
                                                      field is "key", the operator
                                                      is "In", and the values array
                                                      contains only "value". The requirements
                                                      are ANDed.
                                                    type: object
                                                type: object
                                              namespaces:
                                                description: namespaces specifies
                                                  which namespaces the labelSelector
                                                  applies to (matches against); null
                                                  or empty list means "this pod's
                                                  namespace"
                                                items:
                                                  type: string
                                                type: array
                                              topologyKey:
                                                description: This pod should be co-located
                                                  (affinity) or not co-located (anti-affinity)
                                                  with the pods matching the labelSelector
                                                  in the specified namespaces, where
                                                  co-located is defined as running
                                                  on a node whose value of the label
                                                  with key topologyKey matches that
                                                  of any node on which any of the
                                                  selected pods is running. Empty
                                                  topologyKey is not allowed.
                                                type: string
                                            required:
                                            - topologyKey
                                            type: object
                                          type: array
                                      type: object
                                    podAntiAffinity:
                                      description: Describes pod anti-affinity scheduling
                                        rules (e.g. avoid putting this pod in the
                                        same node, zone, etc. as some other pod(s)).
                                      properties:
                                        preferredDuringSchedulingIgnoredDuringExecution:
                                          description: The scheduler will prefer to
                                            schedule pods to nodes that satisfy the
                                            anti-affinity expressions specified by
                                            this field, but it may choose a node that
                                            violates one or more of the expressions.
                                            The node that is most preferred is the
                                            one with the greatest sum of weights,
                                            i.e. for each node that meets all of the
                                            scheduling requirements (resource request,
                                            requiredDuringScheduling anti-affinity
                                            expressions, etc.), compute a sum by iterating
                                            through the elements of this field and
                                            adding "weight" to the sum if the node
                                            has pods which matches the corresponding
                                            podAffinityTerm; the node(s) with the
                                            highest sum are the most preferred.
                                          items:
                                            description: The weights of all of the
                                              matched WeightedPodAffinityTerm fields
                                              are added per-node to find the most
                                              preferred node(s)
                                            properties:
                                              podAffinityTerm:
                                                description: Required. A pod affinity
                                                  term, associated with the corresponding
                                                  weight.
                                                properties:
                                                  labelSelector:
                                                    description: A label query over
                                                      a set of resources, in this
                                                      case pods.
                                                    properties:
                                                      matchExpressions:
                                                        description: matchExpressions
                                                          is a list of label selector
                                                          requirements. The requirements
                                                          are ANDed.
                                                        items:
                                                          description: A label selector
                                                            requirement is a selector
                                                            that contains values,
                                                            a key, and an operator
                                                            that relates the key and
                                                            values.
                                                          properties:
                                                            key:
                                                              description: key is
                                                                the label key that
                                                                the selector applies
                                                                to.
                                                              type: string
                                                            operator:
                                                              description: operator
                                                                represents a key's
                                                                relationship to a
                                                                set of values. Valid
                                                                operators are In,
                                                                NotIn, Exists and
                                                                DoesNotExist.
                                                              type: string
                                                            values:
                                                              description: values
                                                                is an array of string
                                                                values. If the operator
                                                                is In or NotIn, the
                                                                values array must
                                                                be non-empty. If the
                                                                operator is Exists
                                                                or DoesNotExist, the
                                                                values array must
                                                                be empty. This array
                                                                is replaced during
                                                                a strategic merge
                                                                patch.
                                                              items:
                                                                type: string
                                                              type: array
                                                          required:
                                                          - key
                                                          - operator
                                                          type: object
                                                        type: array
                                                      matchLabels:
                                                        additionalProperties:
                                                          type: string
                                                        description: matchLabels is
                                                          a map of {key,value} pairs.
                                                          A single {key,value} in
                                                          the matchLabels map is equivalent
                                                          to an element of matchExpressions,
                                                          whose key field is "key",
                                                          the operator is "In", and
                                                          the values array contains
                                                          only "value". The requirements
                                                          are ANDed.
                                                        type: object
                                                    type: object
                                                  namespaces:
                                                    description: namespaces specifies
                                                      which namespaces the labelSelector
                                                      applies to (matches against);
                                                      null or empty list means "this
                                                      pod's namespace"
                                                    items:
                                                      type: string
                                                    type: array
                                                  topologyKey:
                                                    description: This pod should be
                                                      co-located (affinity) or not
                                                      co-located (anti-affinity) with
                                                      the pods matching the labelSelector
                                                      in the specified namespaces,
                                                      where co-located is defined
                                                      as running on a node whose value
                                                      of the label with key topologyKey
                                                      matches that of any node on
                                                      which any of the selected pods
                                                      is running. Empty topologyKey
                                                      is not allowed.
                                                    type: string
                                                required:
                                                - topologyKey
                                                type: object
                                              weight:
                                                description: weight associated with
                                                  matching the corresponding podAffinityTerm,
                                                  in the range 1-100.
                                                format: int32
                                                type: integer
                                            required:
                                            - podAffinityTerm
                                            - weight
                                            type: object
                                          type: array
                                        requiredDuringSchedulingIgnoredDuringExecution:
                                          description: If the anti-affinity requirements
                                            specified by this field are not met at
                                            scheduling time, the pod will not be scheduled
                                            onto the node. If the anti-affinity requirements
                                            specified by this field cease to be met
                                            at some point during pod execution (e.g.
                                            due to a pod label update), the system
                                            may or may not try to eventually evict
                                            the pod from its node. When there are
                                            multiple elements, the lists of nodes
                                            corresponding to each podAffinityTerm
                                            are intersected, i.e. all terms must be
                                            satisfied.
                                          items:
                                            description: Defines a set of pods (namely
                                              those matching the labelSelector relative
                                              to the given namespace(s)) that this
                                              pod should be co-located (affinity)
                                              or not co-located (anti-affinity) with,
                                              where co-located is defined as running
                                              on a node whose value of the label with
                                              key <topologyKey> matches that of any
                                              node on which a pod of the set of pods
                                              is running
                                            properties:
                                              labelSelector:
                                                description: A label query over a
                                                  set of resources, in this case pods.
                                                properties:
                                                  matchExpressions:
                                                    description: matchExpressions
                                                      is a list of label selector
                                                      requirements. The requirements
                                                      are ANDed.
                                                    items:
                                                      description: A label selector
                                                        requirement is a selector
                                                        that contains values, a key,
                                                        and an operator that relates
                                                        the key and values.
                                                      properties:
                                                        key:
                                                          description: key is the
                                                            label key that the selector
                                                            applies to.
                                                          type: string
                                                        operator:
                                                          description: operator represents
                                                            a key's relationship to
                                                            a set of values. Valid
                                                            operators are In, NotIn,
                                                            Exists and DoesNotExist.
                                                          type: string
                                                        values:
                                                          description: values is an
                                                            array of string values.
                                                            If the operator is In
                                                            or NotIn, the values array
                                                            must be non-empty. If
                                                            the operator is Exists
                                                            or DoesNotExist, the values
                                                            array must be empty. This
                                                            array is replaced during
                                                            a strategic merge patch.
                                                          items:
                                                            type: string
                                                          type: array
                                                      required:
                                                      - key
                                                      - operator
                                                      type: object
                                                    type: array
                                                  matchLabels:
                                                    additionalProperties:
                                                      type: string
                                                    description: matchLabels is a
                                                      map of {key,value} pairs. A
                                                      single {key,value} in the matchLabels
                                                      map is equivalent to an element
                                                      of matchExpressions, whose key
                                                      field is "key", the operator
                                                      is "In", and the values array
                                                      contains only "value". The requirements
                                                      are ANDed.
                                                    type: object
                                                type: object
                                              namespaces:
                                                description: namespaces specifies
                                                  which namespaces the labelSelector
                                                  applies to (matches against); null
                                                  or empty list means "this pod's
                                                  namespace"
                                                items:
                                                  type: string
                                                type: array
                                              topologyKey:
                                                description: This pod should be co-located
                                                  (affinity) or not co-located (anti-affinity)
                                                  with the pods matching the labelSelector
                                                  in the specified namespaces, where
                                                  co-located is defined as running
                                                  on a node whose value of the label
                                                  with key topologyKey matches that
                                                  of any node on which any of the
                                                  selected pods is running. Empty
                                                  topologyKey is not allowed.
                                                type: string
                                            required:
                                            - topologyKey
                                            type: object
                                          type: array
                                      type: object
                                  type: object
                                nodeSelector:
                                  additionalProperties:
                                    type: string
                                  description: 'NodeSelector is a selector which must
                                    be true for the pod to fit on a node. Selector
                                    which must match a node''s labels for the pod
                                    to be scheduled on that node. More info: https://kubernetes.io/docs/concepts/configuration/assign-pod-node/'
                                  type: object
                                tolerations:
                                  description: If specified, the pod's tolerations.
                                  items:
                                    description: The pod this Toleration is attached
                                      to tolerates any taint that matches the triple
                                      <key,value,effect> using the matching operator
                                      <operator>.
                                    properties:
                                      effect:
                                        description: Effect indicates the taint effect
                                          to match. Empty means match all taint effects.
                                          When specified, allowed values are NoSchedule,
                                          PreferNoSchedule and NoExecute.
                                        type: string
                                      key:
                                        description: Key is the taint key that the
                                          toleration applies to. Empty means match
                                          all taint keys. If the key is empty, operator
                                          must be Exists; this combination means to
                                          match all values and all keys.
                                        type: string
                                      operator:
                                        description: Operator represents a key's relationship
                                          to the value. Valid operators are Exists
                                          and Equal. Defaults to Equal. Exists is
                                          equivalent to wildcard for value, so that
                                          a pod can tolerate all taints of a particular
                                          category.
                                        type: string
                                      tolerationSeconds:
                                        description: TolerationSeconds represents
                                          the period of time the toleration (which
                                          must be of effect NoExecute, otherwise this
                                          field is ignored) tolerates the taint. By
                                          default, it is not set, which means tolerate
                                          the taint forever (do not evict). Zero and
                                          negative values will be treated as 0 (evict
                                          immediately) by the system.
                                        format: int64
                                        type: integer
                                      value:
                                        description: Value is the taint value the
                                          toleration matches to. If the operator is
                                          Exists, the value should be empty, otherwise
                                          just a regular string.
                                        type: string
                                    type: object
                                  type: array
                              type: object
                          type: object
                        serviceType:
                          description: Optional service type for Kubernetes solver
                            service
                          type: string
                      type: object
                  type: object
                selector:
                  description: Selector selects a set of DNSNames on the Certificate
                    resource that should be solved using this challenge solver.
                  properties:
                    dnsNames:
                      description: List of DNSNames that this solver will be used
                        to solve. If specified and a match is found, a dnsNames selector
                        will take precedence over a dnsZones selector. If multiple
                        solvers match with the same dnsNames value, the solver with
                        the most matching labels in matchLabels will be selected.
                        If neither has more matches, the solver defined earlier in
                        the list will be selected.
                      items:
                        type: string
                      type: array
                    dnsZones:
                      description: List of DNSZones that this solver will be used
                        to solve. The most specific DNS zone match specified here
                        will take precedence over other DNS zone matches, so a solver
                        specifying sys.example.com will be selected over one specifying
                        example.com for the domain www.sys.example.com. If multiple
                        solvers match with the same dnsZones value, the solver with
                        the most matching labels in matchLabels will be selected.
                        If neither has more matches, the solver defined earlier in
                        the list will be selected.
                      items:
                        type: string
                      type: array
                    matchLabels:
                      additionalProperties:
                        type: string
                      description: A label selector that is used to refine the set
                        of certificate's that this challenge solver will apply to.
                      type: object
                  type: object
              type: object
            token:
              description: Token is the ACME challenge token for this challenge.
              type: string
            type:
              description: Type is the type of ACME challenge this resource represents,
                e.g. "dns01" or "http01"
              type: string
            url:
              description: URL is the URL of the ACME Challenge resource for this
                challenge. This can be used to lookup details about the status of
                this challenge.
              type: string
            wildcard:
              description: Wildcard will be true if this challenge is for a wildcard
                identifier, for example '*.example.com'
              type: boolean
          required:
          - authzURL
          - dnsName
          - issuerRef
          - key
          - token
          - type
          - url
          type: object
        status:
          properties:
            presented:
              description: Presented will be set to true if the challenge values for
                this challenge are currently 'presented'. This *does not* imply the
                self check is passing. Only that the values have been 'submitted'
                for the appropriate challenge mechanism (i.e. the DNS01 TXT record
                has been presented, or the HTTP01 configuration has been configured).
              type: boolean
            processing:
              description: Processing is used to denote whether this challenge should
                be processed or not. This field will only be set to true by the 'scheduling'
                component. It will only be set to false by the 'challenges' controller,
                after the challenge has reached a final state or timed out. If this
                field is set to false, the challenge controller will not take any
                more action.
              type: boolean
            reason:
              description: Reason contains human readable information on why the Challenge
                is in the current state.
              type: string
            state:
              description: State contains the current 'state' of the challenge. If
                not set, the state of the challenge is unknown.
              enum:
              - valid
              - ready
              - pending
              - processing
              - invalid
              - expired
              - errored
              type: string
          type: object
      required:
      - metadata
      type: object
  version: v1alpha2
  versions:
  - name: v1alpha2
    served: true
    storage: true
---
apiVersion: apiextensions.k8s.io/v1beta1
kind: CustomResourceDefinition
metadata:
  name: clusterissuers.cert-manager.io
spec:
  additionalPrinterColumns:
  - JSONPath: .status.conditions[?(@.type=="Ready")].status
    name: Ready
    type: string
  - JSONPath: .status.conditions[?(@.type=="Ready")].message
    name: Status
    priority: 1
    type: string
  - JSONPath: .metadata.creationTimestamp
    description: CreationTimestamp is a timestamp representing the server time when
      this object was created. It is not guaranteed to be set in happens-before order
      across separate operations. Clients may not set this value. It is represented
      in RFC3339 form and is in UTC.
    name: Age
    type: date
  group: cert-manager.io
  names:
    kind: ClusterIssuer
    listKind: ClusterIssuerList
    plural: clusterissuers
    singular: clusterissuer
  scope: Cluster
  subresources:
    status: {}
  validation:
    openAPIV3Schema:
      properties:
        apiVersion:
          description: 'APIVersion defines the versioned schema of this representation
            of an object. Servers should convert recognized schemas to the latest
            internal value, and may reject unrecognized values. More info: https://git.k8s.io/community/contributors/devel/sig-architecture/api-conventions.md#resources'
          type: string
        kind:
          description: 'Kind is a string value representing the REST resource this
            object represents. Servers may infer this from the endpoint the client
            submits requests to. Cannot be updated. In CamelCase. More info: https://git.k8s.io/community/contributors/devel/sig-architecture/api-conventions.md#types-kinds'
          type: string
        metadata:
          type: object
        spec:
          description: IssuerSpec is the specification of an Issuer. This includes
            any configuration required for the issuer.
          properties:
            acme:
              description: ACMEIssuer contains the specification for an ACME issuer
              properties:
                email:
                  description: Email is the email for this account
                  type: string
                privateKeySecretRef:
                  description: PrivateKey is the name of a secret containing the private
                    key for this user account.
                  properties:
                    key:
                      description: The key of the secret to select from. Must be a
                        valid secret key.
                      type: string
                    name:
                      description: 'Name of the referent. More info: https://kubernetes.io/docs/concepts/overview/working-with-objects/names/#names
                        TODO: Add other useful fields. apiVersion, kind, uid?'
                      type: string
                  required:
                  - name
                  type: object
                server:
                  description: Server is the ACME server URL
                  type: string
                skipTLSVerify:
                  description: If true, skip verifying the ACME server TLS certificate
                  type: boolean
                solvers:
                  description: Solvers is a list of challenge solvers that will be
                    used to solve ACME challenges for the matching domains.
                  items:
                    properties:
                      dns01:
                        properties:
                          acmedns:
                            description: ACMEIssuerDNS01ProviderAcmeDNS is a structure
                              containing the configuration for ACME-DNS servers
                            properties:
                              accountSecretRef:
                                properties:
                                  key:
                                    description: The key of the secret to select from.
                                      Must be a valid secret key.
                                    type: string
                                  name:
                                    description: 'Name of the referent. More info:
                                      https://kubernetes.io/docs/concepts/overview/working-with-objects/names/#names
                                      TODO: Add other useful fields. apiVersion, kind,
                                      uid?'
                                    type: string
                                required:
                                - name
                                type: object
                              host:
                                type: string
                            required:
                            - accountSecretRef
                            - host
                            type: object
                          akamai:
                            description: ACMEIssuerDNS01ProviderAkamai is a structure
                              containing the DNS configuration for Akamai DNS—Zone
                              Record Management API
                            properties:
                              accessTokenSecretRef:
                                properties:
                                  key:
                                    description: The key of the secret to select from.
                                      Must be a valid secret key.
                                    type: string
                                  name:
                                    description: 'Name of the referent. More info:
                                      https://kubernetes.io/docs/concepts/overview/working-with-objects/names/#names
                                      TODO: Add other useful fields. apiVersion, kind,
                                      uid?'
                                    type: string
                                required:
                                - name
                                type: object
                              clientSecretSecretRef:
                                properties:
                                  key:
                                    description: The key of the secret to select from.
                                      Must be a valid secret key.
                                    type: string
                                  name:
                                    description: 'Name of the referent. More info:
                                      https://kubernetes.io/docs/concepts/overview/working-with-objects/names/#names
                                      TODO: Add other useful fields. apiVersion, kind,
                                      uid?'
                                    type: string
                                required:
                                - name
                                type: object
                              clientTokenSecretRef:
                                properties:
                                  key:
                                    description: The key of the secret to select from.
                                      Must be a valid secret key.
                                    type: string
                                  name:
                                    description: 'Name of the referent. More info:
                                      https://kubernetes.io/docs/concepts/overview/working-with-objects/names/#names
                                      TODO: Add other useful fields. apiVersion, kind,
                                      uid?'
                                    type: string
                                required:
                                - name
                                type: object
                              serviceConsumerDomain:
                                type: string
                            required:
                            - accessTokenSecretRef
                            - clientSecretSecretRef
                            - clientTokenSecretRef
                            - serviceConsumerDomain
                            type: object
                          azuredns:
                            description: ACMEIssuerDNS01ProviderAzureDNS is a structure
                              containing the configuration for Azure DNS
                            properties:
                              clientID:
                                type: string
                              clientSecretSecretRef:
                                properties:
                                  key:
                                    description: The key of the secret to select from.
                                      Must be a valid secret key.
                                    type: string
                                  name:
                                    description: 'Name of the referent. More info:
                                      https://kubernetes.io/docs/concepts/overview/working-with-objects/names/#names
                                      TODO: Add other useful fields. apiVersion, kind,
                                      uid?'
                                    type: string
                                required:
                                - name
                                type: object
                              environment:
                                enum:
                                - AzurePublicCloud
                                - AzureChinaCloud
                                - AzureGermanCloud
                                - AzureUSGovernmentCloud
                                type: string
                              hostedZoneName:
                                type: string
                              resourceGroupName:
                                type: string
                              subscriptionID:
                                type: string
                              tenantID:
                                type: string
                            required:
                            - clientID
                            - clientSecretSecretRef
                            - resourceGroupName
                            - subscriptionID
                            - tenantID
                            type: object
                          clouddns:
                            description: ACMEIssuerDNS01ProviderCloudDNS is a structure
                              containing the DNS configuration for Google Cloud DNS
                            properties:
                              project:
                                type: string
                              serviceAccountSecretRef:
                                properties:
                                  key:
                                    description: The key of the secret to select from.
                                      Must be a valid secret key.
                                    type: string
                                  name:
                                    description: 'Name of the referent. More info:
                                      https://kubernetes.io/docs/concepts/overview/working-with-objects/names/#names
                                      TODO: Add other useful fields. apiVersion, kind,
                                      uid?'
                                    type: string
                                required:
                                - name
                                type: object
                            required:
                            - project
                            type: object
                          cloudflare:
                            description: ACMEIssuerDNS01ProviderCloudflare is a structure
                              containing the DNS configuration for Cloudflare
                            properties:
                              apiKeySecretRef:
                                properties:
                                  key:
                                    description: The key of the secret to select from.
                                      Must be a valid secret key.
                                    type: string
                                  name:
                                    description: 'Name of the referent. More info:
                                      https://kubernetes.io/docs/concepts/overview/working-with-objects/names/#names
                                      TODO: Add other useful fields. apiVersion, kind,
                                      uid?'
                                    type: string
                                required:
                                - name
                                type: object
                              apiTokenSecretRef:
                                properties:
                                  key:
                                    description: The key of the secret to select from.
                                      Must be a valid secret key.
                                    type: string
                                  name:
                                    description: 'Name of the referent. More info:
                                      https://kubernetes.io/docs/concepts/overview/working-with-objects/names/#names
                                      TODO: Add other useful fields. apiVersion, kind,
                                      uid?'
                                    type: string
                                required:
                                - name
                                type: object
                              email:
                                type: string
                            required:
                            - email
                            type: object
                          cnameStrategy:
                            description: CNAMEStrategy configures how the DNS01 provider
                              should handle CNAME records when found in DNS zones.
                            enum:
                            - None
                            - Follow
                            type: string
                          digitalocean:
                            description: ACMEIssuerDNS01ProviderDigitalOcean is a
                              structure containing the DNS configuration for DigitalOcean
                              Domains
                            properties:
                              tokenSecretRef:
                                properties:
                                  key:
                                    description: The key of the secret to select from.
                                      Must be a valid secret key.
                                    type: string
                                  name:
                                    description: 'Name of the referent. More info:
                                      https://kubernetes.io/docs/concepts/overview/working-with-objects/names/#names
                                      TODO: Add other useful fields. apiVersion, kind,
                                      uid?'
                                    type: string
                                required:
                                - name
                                type: object
                            required:
                            - tokenSecretRef
                            type: object
                          rfc2136:
                            description: ACMEIssuerDNS01ProviderRFC2136 is a structure
                              containing the configuration for RFC2136 DNS
                            properties:
                              nameserver:
                                description: 'The IP address of the DNS supporting
                                  RFC2136. Required. Note: FQDN is not a valid value,
                                  only IP.'
                                type: string
                              tsigAlgorithm:
                                description: 'The TSIG Algorithm configured in the
                                  DNS supporting RFC2136. Used only when ``tsigSecretSecretRef``
                                  and ``tsigKeyName`` are defined. Supported values
                                  are (case-insensitive): ``HMACMD5`` (default), ``HMACSHA1``,
                                  ``HMACSHA256`` or ``HMACSHA512``.'
                                type: string
                              tsigKeyName:
                                description: The TSIG Key name configured in the DNS.
                                  If ``tsigSecretSecretRef`` is defined, this field
                                  is required.
                                type: string
                              tsigSecretSecretRef:
                                description: The name of the secret containing the
                                  TSIG value. If ``tsigKeyName`` is defined, this
                                  field is required.
                                properties:
                                  key:
                                    description: The key of the secret to select from.
                                      Must be a valid secret key.
                                    type: string
                                  name:
                                    description: 'Name of the referent. More info:
                                      https://kubernetes.io/docs/concepts/overview/working-with-objects/names/#names
                                      TODO: Add other useful fields. apiVersion, kind,
                                      uid?'
                                    type: string
                                required:
                                - name
                                type: object
                            required:
                            - nameserver
                            type: object
                          route53:
                            description: ACMEIssuerDNS01ProviderRoute53 is a structure
                              containing the Route 53 configuration for AWS
                            properties:
                              accessKeyID:
                                description: 'The AccessKeyID is used for authentication.
                                  If not set we fall-back to using env vars, shared
                                  credentials file or AWS Instance metadata see: https://docs.aws.amazon.com/sdk-for-go/v1/developer-guide/configuring-sdk.html#specifying-credentials'
                                type: string
                              hostedZoneID:
                                description: If set, the provider will manage only
                                  this zone in Route53 and will not do an lookup using
                                  the route53:ListHostedZonesByName api call.
                                type: string
                              region:
                                description: Always set the region when using AccessKeyID
                                  and SecretAccessKey
                                type: string
                              role:
                                description: Role is a Role ARN which the Route53
                                  provider will assume using either the explicit credentials
                                  AccessKeyID/SecretAccessKey or the inferred credentials
                                  from environment variables, shared credentials file
                                  or AWS Instance metadata
                                type: string
                              secretAccessKeySecretRef:
                                description: The SecretAccessKey is used for authentication.
                                  If not set we fall-back to using env vars, shared
                                  credentials file or AWS Instance metadata https://docs.aws.amazon.com/sdk-for-go/v1/developer-guide/configuring-sdk.html#specifying-credentials
                                properties:
                                  key:
                                    description: The key of the secret to select from.
                                      Must be a valid secret key.
                                    type: string
                                  name:
                                    description: 'Name of the referent. More info:
                                      https://kubernetes.io/docs/concepts/overview/working-with-objects/names/#names
                                      TODO: Add other useful fields. apiVersion, kind,
                                      uid?'
                                    type: string
                                required:
                                - name
                                type: object
                            required:
                            - region
                            type: object
                          webhook:
                            description: ACMEIssuerDNS01ProviderWebhook specifies
                              configuration for a webhook DNS01 provider, including
                              where to POST ChallengePayload resources.
                            properties:
                              config:
                                description: Additional configuration that should
                                  be passed to the webhook apiserver when challenges
                                  are processed. This can contain arbitrary JSON data.
                                  Secret values should not be specified in this stanza.
                                  If secret values are needed (e.g. credentials for
                                  a DNS service), you should use a SecretKeySelector
                                  to reference a Secret resource. For details on the
                                  schema of this field, consult the webhook provider
                                  implementation's documentation.
                                x-kubernetes-preserve-unknown-fields: true
                              groupName:
                                description: The API group name that should be used
                                  when POSTing ChallengePayload resources to the webhook
                                  apiserver. This should be the same as the GroupName
                                  specified in the webhook provider implementation.
                                type: string
                              solverName:
                                description: The name of the solver to use, as defined
                                  in the webhook provider implementation. This will
                                  typically be the name of the provider, e.g. 'cloudflare'.
                                type: string
                            required:
                            - groupName
                            - solverName
                            type: object
                        type: object
                      http01:
                        description: ACMEChallengeSolverHTTP01 contains configuration
                          detailing how to solve HTTP01 challenges within a Kubernetes
                          cluster. Typically this is accomplished through creating
                          'routes' of some description that configure ingress controllers
                          to direct traffic to 'solver pods', which are responsible
                          for responding to the ACME server's HTTP requests.
                        properties:
                          ingress:
                            description: The ingress based HTTP01 challenge solver
                              will solve challenges by creating or modifying Ingress
                              resources in order to route requests for '/.well-known/acme-challenge/XYZ'
                              to 'challenge solver' pods that are provisioned by cert-manager
                              for each Challenge to be completed.
                            properties:
                              class:
                                description: The ingress class to use when creating
                                  Ingress resources to solve ACME challenges that
                                  use this challenge solver. Only one of 'class' or
                                  'name' may be specified.
                                type: string
                              name:
                                description: The name of the ingress resource that
                                  should have ACME challenge solving routes inserted
                                  into it in order to solve HTTP01 challenges. This
                                  is typically used in conjunction with ingress controllers
                                  like ingress-gce, which maintains a 1:1 mapping
                                  between external IPs and ingress resources.
                                type: string
                              podTemplate:
                                description: Optional pod template used to configure
                                  the ACME challenge solver pods used for HTTP01 challenges
                                properties:
                                  metadata:
                                    description: ObjectMeta overrides for the pod
                                      used to solve HTTP01 challenges. Only the 'labels'
                                      and 'annotations' fields may be set. If labels
                                      or annotations overlap with in-built values,
                                      the values here will override the in-built values.
                                    properties:
                                      annotations:
                                        additionalProperties:
                                          type: string
                                        description: Annotations that should be added
                                          to the create ACME HTTP01 solver pods.
                                        type: object
                                      labels:
                                        additionalProperties:
                                          type: string
                                        description: Labels that should be added to
                                          the created ACME HTTP01 solver pods.
                                        type: object
                                    type: object
                                  spec:
                                    description: PodSpec defines overrides for the
                                      HTTP01 challenge solver pod. Only the 'nodeSelector',
                                      'affinity' and 'tolerations' fields are supported
                                      currently. All other fields will be ignored.
                                    properties:
                                      affinity:
                                        description: If specified, the pod's scheduling
                                          constraints
                                        properties:
                                          nodeAffinity:
                                            description: Describes node affinity scheduling
                                              rules for the pod.
                                            properties:
                                              preferredDuringSchedulingIgnoredDuringExecution:
                                                description: The scheduler will prefer
                                                  to schedule pods to nodes that satisfy
                                                  the affinity expressions specified
                                                  by this field, but it may choose
                                                  a node that violates one or more
                                                  of the expressions. The node that
                                                  is most preferred is the one with
                                                  the greatest sum of weights, i.e.
                                                  for each node that meets all of
                                                  the scheduling requirements (resource
                                                  request, requiredDuringScheduling
                                                  affinity expressions, etc.), compute
                                                  a sum by iterating through the elements
                                                  of this field and adding "weight"
                                                  to the sum if the node matches the
                                                  corresponding matchExpressions;
                                                  the node(s) with the highest sum
                                                  are the most preferred.
                                                items:
                                                  description: An empty preferred
                                                    scheduling term matches all objects
                                                    with implicit weight 0 (i.e. it's
                                                    a no-op). A null preferred scheduling
                                                    term matches no objects (i.e.
                                                    is also a no-op).
                                                  properties:
                                                    preference:
                                                      description: A node selector
                                                        term, associated with the
                                                        corresponding weight.
                                                      properties:
                                                        matchExpressions:
                                                          description: A list of node
                                                            selector requirements
                                                            by node's labels.
                                                          items:
                                                            description: A node selector
                                                              requirement is a selector
                                                              that contains values,
                                                              a key, and an operator
                                                              that relates the key
                                                              and values.
                                                            properties:
                                                              key:
                                                                description: The label
                                                                  key that the selector
                                                                  applies to.
                                                                type: string
                                                              operator:
                                                                description: Represents
                                                                  a key's relationship
                                                                  to a set of values.
                                                                  Valid operators
                                                                  are In, NotIn, Exists,
                                                                  DoesNotExist. Gt,
                                                                  and Lt.
                                                                type: string
                                                              values:
                                                                description: An array
                                                                  of string values.
                                                                  If the operator
                                                                  is In or NotIn,
                                                                  the values array
                                                                  must be non-empty.
                                                                  If the operator
                                                                  is Exists or DoesNotExist,
                                                                  the values array
                                                                  must be empty. If
                                                                  the operator is
                                                                  Gt or Lt, the values
                                                                  array must have
                                                                  a single element,
                                                                  which will be interpreted
                                                                  as an integer. This
                                                                  array is replaced
                                                                  during a strategic
                                                                  merge patch.
                                                                items:
                                                                  type: string
                                                                type: array
                                                            required:
                                                            - key
                                                            - operator
                                                            type: object
                                                          type: array
                                                        matchFields:
                                                          description: A list of node
                                                            selector requirements
                                                            by node's fields.
                                                          items:
                                                            description: A node selector
                                                              requirement is a selector
                                                              that contains values,
                                                              a key, and an operator
                                                              that relates the key
                                                              and values.
                                                            properties:
                                                              key:
                                                                description: The label
                                                                  key that the selector
                                                                  applies to.
                                                                type: string
                                                              operator:
                                                                description: Represents
                                                                  a key's relationship
                                                                  to a set of values.
                                                                  Valid operators
                                                                  are In, NotIn, Exists,
                                                                  DoesNotExist. Gt,
                                                                  and Lt.
                                                                type: string
                                                              values:
                                                                description: An array
                                                                  of string values.
                                                                  If the operator
                                                                  is In or NotIn,
                                                                  the values array
                                                                  must be non-empty.
                                                                  If the operator
                                                                  is Exists or DoesNotExist,
                                                                  the values array
                                                                  must be empty. If
                                                                  the operator is
                                                                  Gt or Lt, the values
                                                                  array must have
                                                                  a single element,
                                                                  which will be interpreted
                                                                  as an integer. This
                                                                  array is replaced
                                                                  during a strategic
                                                                  merge patch.
                                                                items:
                                                                  type: string
                                                                type: array
                                                            required:
                                                            - key
                                                            - operator
                                                            type: object
                                                          type: array
                                                      type: object
                                                    weight:
                                                      description: Weight associated
                                                        with matching the corresponding
                                                        nodeSelectorTerm, in the range
                                                        1-100.
                                                      format: int32
                                                      type: integer
                                                  required:
                                                  - preference
                                                  - weight
                                                  type: object
                                                type: array
                                              requiredDuringSchedulingIgnoredDuringExecution:
                                                description: If the affinity requirements
                                                  specified by this field are not
                                                  met at scheduling time, the pod
                                                  will not be scheduled onto the node.
                                                  If the affinity requirements specified
                                                  by this field cease to be met at
                                                  some point during pod execution
                                                  (e.g. due to an update), the system
                                                  may or may not try to eventually
                                                  evict the pod from its node.
                                                properties:
                                                  nodeSelectorTerms:
                                                    description: Required. A list
                                                      of node selector terms. The
                                                      terms are ORed.
                                                    items:
                                                      description: A null or empty
                                                        node selector term matches
                                                        no objects. The requirements
                                                        of them are ANDed. The TopologySelectorTerm
                                                        type implements a subset of
                                                        the NodeSelectorTerm.
                                                      properties:
                                                        matchExpressions:
                                                          description: A list of node
                                                            selector requirements
                                                            by node's labels.
                                                          items:
                                                            description: A node selector
                                                              requirement is a selector
                                                              that contains values,
                                                              a key, and an operator
                                                              that relates the key
                                                              and values.
                                                            properties:
                                                              key:
                                                                description: The label
                                                                  key that the selector
                                                                  applies to.
                                                                type: string
                                                              operator:
                                                                description: Represents
                                                                  a key's relationship
                                                                  to a set of values.
                                                                  Valid operators
                                                                  are In, NotIn, Exists,
                                                                  DoesNotExist. Gt,
                                                                  and Lt.
                                                                type: string
                                                              values:
                                                                description: An array
                                                                  of string values.
                                                                  If the operator
                                                                  is In or NotIn,
                                                                  the values array
                                                                  must be non-empty.
                                                                  If the operator
                                                                  is Exists or DoesNotExist,
                                                                  the values array
                                                                  must be empty. If
                                                                  the operator is
                                                                  Gt or Lt, the values
                                                                  array must have
                                                                  a single element,
                                                                  which will be interpreted
                                                                  as an integer. This
                                                                  array is replaced
                                                                  during a strategic
                                                                  merge patch.
                                                                items:
                                                                  type: string
                                                                type: array
                                                            required:
                                                            - key
                                                            - operator
                                                            type: object
                                                          type: array
                                                        matchFields:
                                                          description: A list of node
                                                            selector requirements
                                                            by node's fields.
                                                          items:
                                                            description: A node selector
                                                              requirement is a selector
                                                              that contains values,
                                                              a key, and an operator
                                                              that relates the key
                                                              and values.
                                                            properties:
                                                              key:
                                                                description: The label
                                                                  key that the selector
                                                                  applies to.
                                                                type: string
                                                              operator:
                                                                description: Represents
                                                                  a key's relationship
                                                                  to a set of values.
                                                                  Valid operators
                                                                  are In, NotIn, Exists,
                                                                  DoesNotExist. Gt,
                                                                  and Lt.
                                                                type: string
                                                              values:
                                                                description: An array
                                                                  of string values.
                                                                  If the operator
                                                                  is In or NotIn,
                                                                  the values array
                                                                  must be non-empty.
                                                                  If the operator
                                                                  is Exists or DoesNotExist,
                                                                  the values array
                                                                  must be empty. If
                                                                  the operator is
                                                                  Gt or Lt, the values
                                                                  array must have
                                                                  a single element,
                                                                  which will be interpreted
                                                                  as an integer. This
                                                                  array is replaced
                                                                  during a strategic
                                                                  merge patch.
                                                                items:
                                                                  type: string
                                                                type: array
                                                            required:
                                                            - key
                                                            - operator
                                                            type: object
                                                          type: array
                                                      type: object
                                                    type: array
                                                required:
                                                - nodeSelectorTerms
                                                type: object
                                            type: object
                                          podAffinity:
                                            description: Describes pod affinity scheduling
                                              rules (e.g. co-locate this pod in the
                                              same node, zone, etc. as some other
                                              pod(s)).
                                            properties:
                                              preferredDuringSchedulingIgnoredDuringExecution:
                                                description: The scheduler will prefer
                                                  to schedule pods to nodes that satisfy
                                                  the affinity expressions specified
                                                  by this field, but it may choose
                                                  a node that violates one or more
                                                  of the expressions. The node that
                                                  is most preferred is the one with
                                                  the greatest sum of weights, i.e.
                                                  for each node that meets all of
                                                  the scheduling requirements (resource
                                                  request, requiredDuringScheduling
                                                  affinity expressions, etc.), compute
                                                  a sum by iterating through the elements
                                                  of this field and adding "weight"
                                                  to the sum if the node has pods
                                                  which matches the corresponding
                                                  podAffinityTerm; the node(s) with
                                                  the highest sum are the most preferred.
                                                items:
                                                  description: The weights of all
                                                    of the matched WeightedPodAffinityTerm
                                                    fields are added per-node to find
                                                    the most preferred node(s)
                                                  properties:
                                                    podAffinityTerm:
                                                      description: Required. A pod
                                                        affinity term, associated
                                                        with the corresponding weight.
                                                      properties:
                                                        labelSelector:
                                                          description: A label query
                                                            over a set of resources,
                                                            in this case pods.
                                                          properties:
                                                            matchExpressions:
                                                              description: matchExpressions
                                                                is a list of label
                                                                selector requirements.
                                                                The requirements are
                                                                ANDed.
                                                              items:
                                                                description: A label
                                                                  selector requirement
                                                                  is a selector that
                                                                  contains values,
                                                                  a key, and an operator
                                                                  that relates the
                                                                  key and values.
                                                                properties:
                                                                  key:
                                                                    description: key
                                                                      is the label
                                                                      key that the
                                                                      selector applies
                                                                      to.
                                                                    type: string
                                                                  operator:
                                                                    description: operator
                                                                      represents a
                                                                      key's relationship
                                                                      to a set of
                                                                      values. Valid
                                                                      operators are
                                                                      In, NotIn, Exists
                                                                      and DoesNotExist.
                                                                    type: string
                                                                  values:
                                                                    description: values
                                                                      is an array
                                                                      of string values.
                                                                      If the operator
                                                                      is In or NotIn,
                                                                      the values array
                                                                      must be non-empty.
                                                                      If the operator
                                                                      is Exists or
                                                                      DoesNotExist,
                                                                      the values array
                                                                      must be empty.
                                                                      This array is
                                                                      replaced during
                                                                      a strategic
                                                                      merge patch.
                                                                    items:
                                                                      type: string
                                                                    type: array
                                                                required:
                                                                - key
                                                                - operator
                                                                type: object
                                                              type: array
                                                            matchLabels:
                                                              additionalProperties:
                                                                type: string
                                                              description: matchLabels
                                                                is a map of {key,value}
                                                                pairs. A single {key,value}
                                                                in the matchLabels
                                                                map is equivalent
                                                                to an element of matchExpressions,
                                                                whose key field is
                                                                "key", the operator
                                                                is "In", and the values
                                                                array contains only
                                                                "value". The requirements
                                                                are ANDed.
                                                              type: object
                                                          type: object
                                                        namespaces:
                                                          description: namespaces
                                                            specifies which namespaces
                                                            the labelSelector applies
                                                            to (matches against);
                                                            null or empty list means
                                                            "this pod's namespace"
                                                          items:
                                                            type: string
                                                          type: array
                                                        topologyKey:
                                                          description: This pod should
                                                            be co-located (affinity)
                                                            or not co-located (anti-affinity)
                                                            with the pods matching
                                                            the labelSelector in the
                                                            specified namespaces,
                                                            where co-located is defined
                                                            as running on a node whose
                                                            value of the label with
                                                            key topologyKey matches
                                                            that of any node on which
                                                            any of the selected pods
                                                            is running. Empty topologyKey
                                                            is not allowed.
                                                          type: string
                                                      required:
                                                      - topologyKey
                                                      type: object
                                                    weight:
                                                      description: weight associated
                                                        with matching the corresponding
                                                        podAffinityTerm, in the range
                                                        1-100.
                                                      format: int32
                                                      type: integer
                                                  required:
                                                  - podAffinityTerm
                                                  - weight
                                                  type: object
                                                type: array
                                              requiredDuringSchedulingIgnoredDuringExecution:
                                                description: If the affinity requirements
                                                  specified by this field are not
                                                  met at scheduling time, the pod
                                                  will not be scheduled onto the node.
                                                  If the affinity requirements specified
                                                  by this field cease to be met at
                                                  some point during pod execution
                                                  (e.g. due to a pod label update),
                                                  the system may or may not try to
                                                  eventually evict the pod from its
                                                  node. When there are multiple elements,
                                                  the lists of nodes corresponding
                                                  to each podAffinityTerm are intersected,
                                                  i.e. all terms must be satisfied.
                                                items:
                                                  description: Defines a set of pods
                                                    (namely those matching the labelSelector
                                                    relative to the given namespace(s))
                                                    that this pod should be co-located
                                                    (affinity) or not co-located (anti-affinity)
                                                    with, where co-located is defined
                                                    as running on a node whose value
                                                    of the label with key <topologyKey>
                                                    matches that of any node on which
                                                    a pod of the set of pods is running
                                                  properties:
                                                    labelSelector:
                                                      description: A label query over
                                                        a set of resources, in this
                                                        case pods.
                                                      properties:
                                                        matchExpressions:
                                                          description: matchExpressions
                                                            is a list of label selector
                                                            requirements. The requirements
                                                            are ANDed.
                                                          items:
                                                            description: A label selector
                                                              requirement is a selector
                                                              that contains values,
                                                              a key, and an operator
                                                              that relates the key
                                                              and values.
                                                            properties:
                                                              key:
                                                                description: key is
                                                                  the label key that
                                                                  the selector applies
                                                                  to.
                                                                type: string
                                                              operator:
                                                                description: operator
                                                                  represents a key's
                                                                  relationship to
                                                                  a set of values.
                                                                  Valid operators
                                                                  are In, NotIn, Exists
                                                                  and DoesNotExist.
                                                                type: string
                                                              values:
                                                                description: values
                                                                  is an array of string
                                                                  values. If the operator
                                                                  is In or NotIn,
                                                                  the values array
                                                                  must be non-empty.
                                                                  If the operator
                                                                  is Exists or DoesNotExist,
                                                                  the values array
                                                                  must be empty. This
                                                                  array is replaced
                                                                  during a strategic
                                                                  merge patch.
                                                                items:
                                                                  type: string
                                                                type: array
                                                            required:
                                                            - key
                                                            - operator
                                                            type: object
                                                          type: array
                                                        matchLabels:
                                                          additionalProperties:
                                                            type: string
                                                          description: matchLabels
                                                            is a map of {key,value}
                                                            pairs. A single {key,value}
                                                            in the matchLabels map
                                                            is equivalent to an element
                                                            of matchExpressions, whose
                                                            key field is "key", the
                                                            operator is "In", and
                                                            the values array contains
                                                            only "value". The requirements
                                                            are ANDed.
                                                          type: object
                                                      type: object
                                                    namespaces:
                                                      description: namespaces specifies
                                                        which namespaces the labelSelector
                                                        applies to (matches against);
                                                        null or empty list means "this
                                                        pod's namespace"
                                                      items:
                                                        type: string
                                                      type: array
                                                    topologyKey:
                                                      description: This pod should
                                                        be co-located (affinity) or
                                                        not co-located (anti-affinity)
                                                        with the pods matching the
                                                        labelSelector in the specified
                                                        namespaces, where co-located
                                                        is defined as running on a
                                                        node whose value of the label
                                                        with key topologyKey matches
                                                        that of any node on which
                                                        any of the selected pods is
                                                        running. Empty topologyKey
                                                        is not allowed.
                                                      type: string
                                                  required:
                                                  - topologyKey
                                                  type: object
                                                type: array
                                            type: object
                                          podAntiAffinity:
                                            description: Describes pod anti-affinity
                                              scheduling rules (e.g. avoid putting
                                              this pod in the same node, zone, etc.
                                              as some other pod(s)).
                                            properties:
                                              preferredDuringSchedulingIgnoredDuringExecution:
                                                description: The scheduler will prefer
                                                  to schedule pods to nodes that satisfy
                                                  the anti-affinity expressions specified
                                                  by this field, but it may choose
                                                  a node that violates one or more
                                                  of the expressions. The node that
                                                  is most preferred is the one with
                                                  the greatest sum of weights, i.e.
                                                  for each node that meets all of
                                                  the scheduling requirements (resource
                                                  request, requiredDuringScheduling
                                                  anti-affinity expressions, etc.),
                                                  compute a sum by iterating through
                                                  the elements of this field and adding
                                                  "weight" to the sum if the node
                                                  has pods which matches the corresponding
                                                  podAffinityTerm; the node(s) with
                                                  the highest sum are the most preferred.
                                                items:
                                                  description: The weights of all
                                                    of the matched WeightedPodAffinityTerm
                                                    fields are added per-node to find
                                                    the most preferred node(s)
                                                  properties:
                                                    podAffinityTerm:
                                                      description: Required. A pod
                                                        affinity term, associated
                                                        with the corresponding weight.
                                                      properties:
                                                        labelSelector:
                                                          description: A label query
                                                            over a set of resources,
                                                            in this case pods.
                                                          properties:
                                                            matchExpressions:
                                                              description: matchExpressions
                                                                is a list of label
                                                                selector requirements.
                                                                The requirements are
                                                                ANDed.
                                                              items:
                                                                description: A label
                                                                  selector requirement
                                                                  is a selector that
                                                                  contains values,
                                                                  a key, and an operator
                                                                  that relates the
                                                                  key and values.
                                                                properties:
                                                                  key:
                                                                    description: key
                                                                      is the label
                                                                      key that the
                                                                      selector applies
                                                                      to.
                                                                    type: string
                                                                  operator:
                                                                    description: operator
                                                                      represents a
                                                                      key's relationship
                                                                      to a set of
                                                                      values. Valid
                                                                      operators are
                                                                      In, NotIn, Exists
                                                                      and DoesNotExist.
                                                                    type: string
                                                                  values:
                                                                    description: values
                                                                      is an array
                                                                      of string values.
                                                                      If the operator
                                                                      is In or NotIn,
                                                                      the values array
                                                                      must be non-empty.
                                                                      If the operator
                                                                      is Exists or
                                                                      DoesNotExist,
                                                                      the values array
                                                                      must be empty.
                                                                      This array is
                                                                      replaced during
                                                                      a strategic
                                                                      merge patch.
                                                                    items:
                                                                      type: string
                                                                    type: array
                                                                required:
                                                                - key
                                                                - operator
                                                                type: object
                                                              type: array
                                                            matchLabels:
                                                              additionalProperties:
                                                                type: string
                                                              description: matchLabels
                                                                is a map of {key,value}
                                                                pairs. A single {key,value}
                                                                in the matchLabels
                                                                map is equivalent
                                                                to an element of matchExpressions,
                                                                whose key field is
                                                                "key", the operator
                                                                is "In", and the values
                                                                array contains only
                                                                "value". The requirements
                                                                are ANDed.
                                                              type: object
                                                          type: object
                                                        namespaces:
                                                          description: namespaces
                                                            specifies which namespaces
                                                            the labelSelector applies
                                                            to (matches against);
                                                            null or empty list means
                                                            "this pod's namespace"
                                                          items:
                                                            type: string
                                                          type: array
                                                        topologyKey:
                                                          description: This pod should
                                                            be co-located (affinity)
                                                            or not co-located (anti-affinity)
                                                            with the pods matching
                                                            the labelSelector in the
                                                            specified namespaces,
                                                            where co-located is defined
                                                            as running on a node whose
                                                            value of the label with
                                                            key topologyKey matches
                                                            that of any node on which
                                                            any of the selected pods
                                                            is running. Empty topologyKey
                                                            is not allowed.
                                                          type: string
                                                      required:
                                                      - topologyKey
                                                      type: object
                                                    weight:
                                                      description: weight associated
                                                        with matching the corresponding
                                                        podAffinityTerm, in the range
                                                        1-100.
                                                      format: int32
                                                      type: integer
                                                  required:
                                                  - podAffinityTerm
                                                  - weight
                                                  type: object
                                                type: array
                                              requiredDuringSchedulingIgnoredDuringExecution:
                                                description: If the anti-affinity
                                                  requirements specified by this field
                                                  are not met at scheduling time,
                                                  the pod will not be scheduled onto
                                                  the node. If the anti-affinity requirements
                                                  specified by this field cease to
                                                  be met at some point during pod
                                                  execution (e.g. due to a pod label
                                                  update), the system may or may not
                                                  try to eventually evict the pod
                                                  from its node. When there are multiple
                                                  elements, the lists of nodes corresponding
                                                  to each podAffinityTerm are intersected,
                                                  i.e. all terms must be satisfied.
                                                items:
                                                  description: Defines a set of pods
                                                    (namely those matching the labelSelector
                                                    relative to the given namespace(s))
                                                    that this pod should be co-located
                                                    (affinity) or not co-located (anti-affinity)
                                                    with, where co-located is defined
                                                    as running on a node whose value
                                                    of the label with key <topologyKey>
                                                    matches that of any node on which
                                                    a pod of the set of pods is running
                                                  properties:
                                                    labelSelector:
                                                      description: A label query over
                                                        a set of resources, in this
                                                        case pods.
                                                      properties:
                                                        matchExpressions:
                                                          description: matchExpressions
                                                            is a list of label selector
                                                            requirements. The requirements
                                                            are ANDed.
                                                          items:
                                                            description: A label selector
                                                              requirement is a selector
                                                              that contains values,
                                                              a key, and an operator
                                                              that relates the key
                                                              and values.
                                                            properties:
                                                              key:
                                                                description: key is
                                                                  the label key that
                                                                  the selector applies
                                                                  to.
                                                                type: string
                                                              operator:
                                                                description: operator
                                                                  represents a key's
                                                                  relationship to
                                                                  a set of values.
                                                                  Valid operators
                                                                  are In, NotIn, Exists
                                                                  and DoesNotExist.
                                                                type: string
                                                              values:
                                                                description: values
                                                                  is an array of string
                                                                  values. If the operator
                                                                  is In or NotIn,
                                                                  the values array
                                                                  must be non-empty.
                                                                  If the operator
                                                                  is Exists or DoesNotExist,
                                                                  the values array
                                                                  must be empty. This
                                                                  array is replaced
                                                                  during a strategic
                                                                  merge patch.
                                                                items:
                                                                  type: string
                                                                type: array
                                                            required:
                                                            - key
                                                            - operator
                                                            type: object
                                                          type: array
                                                        matchLabels:
                                                          additionalProperties:
                                                            type: string
                                                          description: matchLabels
                                                            is a map of {key,value}
                                                            pairs. A single {key,value}
                                                            in the matchLabels map
                                                            is equivalent to an element
                                                            of matchExpressions, whose
                                                            key field is "key", the
                                                            operator is "In", and
                                                            the values array contains
                                                            only "value". The requirements
                                                            are ANDed.
                                                          type: object
                                                      type: object
                                                    namespaces:
                                                      description: namespaces specifies
                                                        which namespaces the labelSelector
                                                        applies to (matches against);
                                                        null or empty list means "this
                                                        pod's namespace"
                                                      items:
                                                        type: string
                                                      type: array
                                                    topologyKey:
                                                      description: This pod should
                                                        be co-located (affinity) or
                                                        not co-located (anti-affinity)
                                                        with the pods matching the
                                                        labelSelector in the specified
                                                        namespaces, where co-located
                                                        is defined as running on a
                                                        node whose value of the label
                                                        with key topologyKey matches
                                                        that of any node on which
                                                        any of the selected pods is
                                                        running. Empty topologyKey
                                                        is not allowed.
                                                      type: string
                                                  required:
                                                  - topologyKey
                                                  type: object
                                                type: array
                                            type: object
                                        type: object
                                      nodeSelector:
                                        additionalProperties:
                                          type: string
                                        description: 'NodeSelector is a selector which
                                          must be true for the pod to fit on a node.
                                          Selector which must match a node''s labels
                                          for the pod to be scheduled on that node.
                                          More info: https://kubernetes.io/docs/concepts/configuration/assign-pod-node/'
                                        type: object
                                      tolerations:
                                        description: If specified, the pod's tolerations.
                                        items:
                                          description: The pod this Toleration is
                                            attached to tolerates any taint that matches
                                            the triple <key,value,effect> using the
                                            matching operator <operator>.
                                          properties:
                                            effect:
                                              description: Effect indicates the taint
                                                effect to match. Empty means match
                                                all taint effects. When specified,
                                                allowed values are NoSchedule, PreferNoSchedule
                                                and NoExecute.
                                              type: string
                                            key:
                                              description: Key is the taint key that
                                                the toleration applies to. Empty means
                                                match all taint keys. If the key is
                                                empty, operator must be Exists; this
                                                combination means to match all values
                                                and all keys.
                                              type: string
                                            operator:
                                              description: Operator represents a key's
                                                relationship to the value. Valid operators
                                                are Exists and Equal. Defaults to
                                                Equal. Exists is equivalent to wildcard
                                                for value, so that a pod can tolerate
                                                all taints of a particular category.
                                              type: string
                                            tolerationSeconds:
                                              description: TolerationSeconds represents
                                                the period of time the toleration
                                                (which must be of effect NoExecute,
                                                otherwise this field is ignored) tolerates
                                                the taint. By default, it is not set,
                                                which means tolerate the taint forever
                                                (do not evict). Zero and negative
                                                values will be treated as 0 (evict
                                                immediately) by the system.
                                              format: int64
                                              type: integer
                                            value:
                                              description: Value is the taint value
                                                the toleration matches to. If the
                                                operator is Exists, the value should
                                                be empty, otherwise just a regular
                                                string.
                                              type: string
                                          type: object
                                        type: array
                                    type: object
                                type: object
                              serviceType:
                                description: Optional service type for Kubernetes
                                  solver service
                                type: string
                            type: object
                        type: object
                      selector:
                        description: Selector selects a set of DNSNames on the Certificate
                          resource that should be solved using this challenge solver.
                        properties:
                          dnsNames:
                            description: List of DNSNames that this solver will be
                              used to solve. If specified and a match is found, a
                              dnsNames selector will take precedence over a dnsZones
                              selector. If multiple solvers match with the same dnsNames
                              value, the solver with the most matching labels in matchLabels
                              will be selected. If neither has more matches, the solver
                              defined earlier in the list will be selected.
                            items:
                              type: string
                            type: array
                          dnsZones:
                            description: List of DNSZones that this solver will be
                              used to solve. The most specific DNS zone match specified
                              here will take precedence over other DNS zone matches,
                              so a solver specifying sys.example.com will be selected
                              over one specifying example.com for the domain www.sys.example.com.
                              If multiple solvers match with the same dnsZones value,
                              the solver with the most matching labels in matchLabels
                              will be selected. If neither has more matches, the solver
                              defined earlier in the list will be selected.
                            items:
                              type: string
                            type: array
                          matchLabels:
                            additionalProperties:
                              type: string
                            description: A label selector that is used to refine the
                              set of certificate's that this challenge solver will
                              apply to.
                            type: object
                        type: object
                    type: object
                  type: array
              required:
              - privateKeySecretRef
              - server
              type: object
            ca:
              properties:
                secretName:
                  description: SecretName is the name of the secret used to sign Certificates
                    issued by this Issuer.
                  type: string
              required:
              - secretName
              type: object
            selfSigned:
              type: object
            vault:
              properties:
                auth:
                  description: Vault authentication
                  properties:
                    appRole:
                      description: This Secret contains a AppRole and Secret
                      properties:
                        path:
                          description: Where the authentication path is mounted in
                            Vault.
                          type: string
                        roleId:
                          type: string
                        secretRef:
                          properties:
                            key:
                              description: The key of the secret to select from. Must
                                be a valid secret key.
                              type: string
                            name:
                              description: 'Name of the referent. More info: https://kubernetes.io/docs/concepts/overview/working-with-objects/names/#names
                                TODO: Add other useful fields. apiVersion, kind, uid?'
                              type: string
                          required:
                          - name
                          type: object
                      required:
                      - path
                      - roleId
                      - secretRef
                      type: object
                    kubernetes:
                      description: This contains a Role and Secret with a ServiceAccount
                        token to authenticate with vault.
                      properties:
                        mountPath:
                          description: The Vault mountPath here is the mount path
                            to use when authenticating with Vault. For example, setting
                            a value to `/v1/auth/foo`, will use the path `/v1/auth/foo/login`
                            to authenticate with Vault. If unspecified, the default
                            value "/v1/auth/kubernetes" will be used.
                          type: string
                        role:
                          description: A required field containing the Vault Role
                            to assume. A Role binds a Kubernetes ServiceAccount with
                            a set of Vault policies.
                          type: string
                        secretRef:
                          description: The required Secret field containing a Kubernetes
                            ServiceAccount JWT used for authenticating with Vault.
                            Use of 'ambient credentials' is not supported.
                          properties:
                            key:
                              description: The key of the secret to select from. Must
                                be a valid secret key.
                              type: string
                            name:
                              description: 'Name of the referent. More info: https://kubernetes.io/docs/concepts/overview/working-with-objects/names/#names
                                TODO: Add other useful fields. apiVersion, kind, uid?'
                              type: string
                          required:
                          - name
                          type: object
                      required:
                      - role
                      - secretRef
                      type: object
                    tokenSecretRef:
                      description: This Secret contains the Vault token key
                      properties:
                        key:
                          description: The key of the secret to select from. Must
                            be a valid secret key.
                          type: string
                        name:
                          description: 'Name of the referent. More info: https://kubernetes.io/docs/concepts/overview/working-with-objects/names/#names
                            TODO: Add other useful fields. apiVersion, kind, uid?'
                          type: string
                      required:
                      - name
                      type: object
                  type: object
                caBundle:
                  description: Base64 encoded CA bundle to validate Vault server certificate.
                    Only used if the Server URL is using HTTPS protocol. This parameter
                    is ignored for plain HTTP protocol connection. If not set the
                    system root certificates are used to validate the TLS connection.
                  format: byte
                  type: string
                path:
                  description: Vault URL path to the certificate role
                  type: string
                server:
                  description: Server is the vault connection address
                  type: string
              required:
              - auth
              - path
              - server
              type: object
            venafi:
              description: VenafiIssuer describes issuer configuration details for
                Venafi Cloud.
              properties:
                cloud:
                  description: Cloud specifies the Venafi cloud configuration settings.
                    Only one of TPP or Cloud may be specified.
                  properties:
                    apiTokenSecretRef:
                      description: APITokenSecretRef is a secret key selector for
                        the Venafi Cloud API token.
                      properties:
                        key:
                          description: The key of the secret to select from. Must
                            be a valid secret key.
                          type: string
                        name:
                          description: 'Name of the referent. More info: https://kubernetes.io/docs/concepts/overview/working-with-objects/names/#names
                            TODO: Add other useful fields. apiVersion, kind, uid?'
                          type: string
                      required:
                      - name
                      type: object
                    url:
                      description: URL is the base URL for Venafi Cloud
                      type: string
                  required:
                  - apiTokenSecretRef
                  - url
                  type: object
                tpp:
                  description: TPP specifies Trust Protection Platform configuration
                    settings. Only one of TPP or Cloud may be specified.
                  properties:
                    caBundle:
                      description: CABundle is a PEM encoded TLS certifiate to use
                        to verify connections to the TPP instance. If specified, system
                        roots will not be used and the issuing CA for the TPP instance
                        must be verifiable using the provided root. If not specified,
                        the connection will be verified using the cert-manager system
                        root certificates.
                      format: byte
                      type: string
                    credentialsRef:
                      description: CredentialsRef is a reference to a Secret containing
                        the username and password for the TPP server. The secret must
                        contain two keys, 'username' and 'password'.
                      properties:
                        name:
                          description: 'Name of the referent. More info: https://kubernetes.io/docs/concepts/overview/working-with-objects/names/#names
                            TODO: Add other useful fields. apiVersion, kind, uid?'
                          type: string
                      required:
                      - name
                      type: object
                    url:
                      description: URL is the base URL for the Venafi TPP instance
                      type: string
                  required:
                  - credentialsRef
                  - url
                  type: object
                zone:
                  description: Zone is the Venafi Policy Zone to use for this issuer.
                    All requests made to the Venafi platform will be restricted by
                    the named zone policy. This field is required.
                  type: string
              required:
              - zone
              type: object
          type: object
        status:
          description: IssuerStatus contains status information about an Issuer
          properties:
            acme:
              properties:
                lastRegisteredEmail:
                  description: LastRegisteredEmail is the email associated with the
                    latest registered ACME account, in order to track changes made
                    to registered account associated with the  Issuer
                  type: string
                uri:
                  description: URI is the unique account identifier, which can also
                    be used to retrieve account details from the CA
                  type: string
              type: object
            conditions:
              items:
                description: IssuerCondition contains condition information for an
                  Issuer.
                properties:
                  lastTransitionTime:
                    description: LastTransitionTime is the timestamp corresponding
                      to the last status change of this condition.
                    format: date-time
                    type: string
                  message:
                    description: Message is a human readable description of the details
                      of the last transition, complementing reason.
                    type: string
                  reason:
                    description: Reason is a brief machine readable explanation for
                      the condition's last transition.
                    type: string
                  status:
                    description: Status of the condition, one of ('True', 'False',
                      'Unknown').
                    enum:
                    - "True"
                    - "False"
                    - Unknown
                    type: string
                  type:
                    description: Type of the condition, currently ('Ready').
                    type: string
                required:
                - status
                - type
                type: object
              type: array
          type: object
      type: object
  version: v1alpha2
  versions:
  - name: v1alpha2
    served: true
    storage: true
---
apiVersion: apiextensions.k8s.io/v1beta1
kind: CustomResourceDefinition
metadata:
  name: issuers.cert-manager.io
spec:
  additionalPrinterColumns:
  - JSONPath: .status.conditions[?(@.type=="Ready")].status
    name: Ready
    type: string
  - JSONPath: .status.conditions[?(@.type=="Ready")].message
    name: Status
    priority: 1
    type: string
  - JSONPath: .metadata.creationTimestamp
    description: CreationTimestamp is a timestamp representing the server time when
      this object was created. It is not guaranteed to be set in happens-before order
      across separate operations. Clients may not set this value. It is represented
      in RFC3339 form and is in UTC.
    name: Age
    type: date
  group: cert-manager.io
  names:
    kind: Issuer
    listKind: IssuerList
    plural: issuers
    singular: issuer
  scope: Namespaced
  subresources:
    status: {}
  validation:
    openAPIV3Schema:
      properties:
        apiVersion:
          description: 'APIVersion defines the versioned schema of this representation
            of an object. Servers should convert recognized schemas to the latest
            internal value, and may reject unrecognized values. More info: https://git.k8s.io/community/contributors/devel/sig-architecture/api-conventions.md#resources'
          type: string
        kind:
          description: 'Kind is a string value representing the REST resource this
            object represents. Servers may infer this from the endpoint the client
            submits requests to. Cannot be updated. In CamelCase. More info: https://git.k8s.io/community/contributors/devel/sig-architecture/api-conventions.md#types-kinds'
          type: string
        metadata:
          type: object
        spec:
          description: IssuerSpec is the specification of an Issuer. This includes
            any configuration required for the issuer.
          properties:
            acme:
              description: ACMEIssuer contains the specification for an ACME issuer
              properties:
                email:
                  description: Email is the email for this account
                  type: string
                privateKeySecretRef:
                  description: PrivateKey is the name of a secret containing the private
                    key for this user account.
                  properties:
                    key:
                      description: The key of the secret to select from. Must be a
                        valid secret key.
                      type: string
                    name:
                      description: 'Name of the referent. More info: https://kubernetes.io/docs/concepts/overview/working-with-objects/names/#names
                        TODO: Add other useful fields. apiVersion, kind, uid?'
                      type: string
                  required:
                  - name
                  type: object
                server:
                  description: Server is the ACME server URL
                  type: string
                skipTLSVerify:
                  description: If true, skip verifying the ACME server TLS certificate
                  type: boolean
                solvers:
                  description: Solvers is a list of challenge solvers that will be
                    used to solve ACME challenges for the matching domains.
                  items:
                    properties:
                      dns01:
                        properties:
                          acmedns:
                            description: ACMEIssuerDNS01ProviderAcmeDNS is a structure
                              containing the configuration for ACME-DNS servers
                            properties:
                              accountSecretRef:
                                properties:
                                  key:
                                    description: The key of the secret to select from.
                                      Must be a valid secret key.
                                    type: string
                                  name:
                                    description: 'Name of the referent. More info:
                                      https://kubernetes.io/docs/concepts/overview/working-with-objects/names/#names
                                      TODO: Add other useful fields. apiVersion, kind,
                                      uid?'
                                    type: string
                                required:
                                - name
                                type: object
                              host:
                                type: string
                            required:
                            - accountSecretRef
                            - host
                            type: object
                          akamai:
                            description: ACMEIssuerDNS01ProviderAkamai is a structure
                              containing the DNS configuration for Akamai DNS—Zone
                              Record Management API
                            properties:
                              accessTokenSecretRef:
                                properties:
                                  key:
                                    description: The key of the secret to select from.
                                      Must be a valid secret key.
                                    type: string
                                  name:
                                    description: 'Name of the referent. More info:
                                      https://kubernetes.io/docs/concepts/overview/working-with-objects/names/#names
                                      TODO: Add other useful fields. apiVersion, kind,
                                      uid?'
                                    type: string
                                required:
                                - name
                                type: object
                              clientSecretSecretRef:
                                properties:
                                  key:
                                    description: The key of the secret to select from.
                                      Must be a valid secret key.
                                    type: string
                                  name:
                                    description: 'Name of the referent. More info:
                                      https://kubernetes.io/docs/concepts/overview/working-with-objects/names/#names
                                      TODO: Add other useful fields. apiVersion, kind,
                                      uid?'
                                    type: string
                                required:
                                - name
                                type: object
                              clientTokenSecretRef:
                                properties:
                                  key:
                                    description: The key of the secret to select from.
                                      Must be a valid secret key.
                                    type: string
                                  name:
                                    description: 'Name of the referent. More info:
                                      https://kubernetes.io/docs/concepts/overview/working-with-objects/names/#names
                                      TODO: Add other useful fields. apiVersion, kind,
                                      uid?'
                                    type: string
                                required:
                                - name
                                type: object
                              serviceConsumerDomain:
                                type: string
                            required:
                            - accessTokenSecretRef
                            - clientSecretSecretRef
                            - clientTokenSecretRef
                            - serviceConsumerDomain
                            type: object
                          azuredns:
                            description: ACMEIssuerDNS01ProviderAzureDNS is a structure
                              containing the configuration for Azure DNS
                            properties:
                              clientID:
                                type: string
                              clientSecretSecretRef:
                                properties:
                                  key:
                                    description: The key of the secret to select from.
                                      Must be a valid secret key.
                                    type: string
                                  name:
                                    description: 'Name of the referent. More info:
                                      https://kubernetes.io/docs/concepts/overview/working-with-objects/names/#names
                                      TODO: Add other useful fields. apiVersion, kind,
                                      uid?'
                                    type: string
                                required:
                                - name
                                type: object
                              environment:
                                enum:
                                - AzurePublicCloud
                                - AzureChinaCloud
                                - AzureGermanCloud
                                - AzureUSGovernmentCloud
                                type: string
                              hostedZoneName:
                                type: string
                              resourceGroupName:
                                type: string
                              subscriptionID:
                                type: string
                              tenantID:
                                type: string
                            required:
                            - clientID
                            - clientSecretSecretRef
                            - resourceGroupName
                            - subscriptionID
                            - tenantID
                            type: object
                          clouddns:
                            description: ACMEIssuerDNS01ProviderCloudDNS is a structure
                              containing the DNS configuration for Google Cloud DNS
                            properties:
                              project:
                                type: string
                              serviceAccountSecretRef:
                                properties:
                                  key:
                                    description: The key of the secret to select from.
                                      Must be a valid secret key.
                                    type: string
                                  name:
                                    description: 'Name of the referent. More info:
                                      https://kubernetes.io/docs/concepts/overview/working-with-objects/names/#names
                                      TODO: Add other useful fields. apiVersion, kind,
                                      uid?'
                                    type: string
                                required:
                                - name
                                type: object
                            required:
                            - project
                            type: object
                          cloudflare:
                            description: ACMEIssuerDNS01ProviderCloudflare is a structure
                              containing the DNS configuration for Cloudflare
                            properties:
                              apiKeySecretRef:
                                properties:
                                  key:
                                    description: The key of the secret to select from.
                                      Must be a valid secret key.
                                    type: string
                                  name:
                                    description: 'Name of the referent. More info:
                                      https://kubernetes.io/docs/concepts/overview/working-with-objects/names/#names
                                      TODO: Add other useful fields. apiVersion, kind,
                                      uid?'
                                    type: string
                                required:
                                - name
                                type: object
                              apiTokenSecretRef:
                                properties:
                                  key:
                                    description: The key of the secret to select from.
                                      Must be a valid secret key.
                                    type: string
                                  name:
                                    description: 'Name of the referent. More info:
                                      https://kubernetes.io/docs/concepts/overview/working-with-objects/names/#names
                                      TODO: Add other useful fields. apiVersion, kind,
                                      uid?'
                                    type: string
                                required:
                                - name
                                type: object
                              email:
                                type: string
                            required:
                            - email
                            type: object
                          cnameStrategy:
                            description: CNAMEStrategy configures how the DNS01 provider
                              should handle CNAME records when found in DNS zones.
                            enum:
                            - None
                            - Follow
                            type: string
                          digitalocean:
                            description: ACMEIssuerDNS01ProviderDigitalOcean is a
                              structure containing the DNS configuration for DigitalOcean
                              Domains
                            properties:
                              tokenSecretRef:
                                properties:
                                  key:
                                    description: The key of the secret to select from.
                                      Must be a valid secret key.
                                    type: string
                                  name:
                                    description: 'Name of the referent. More info:
                                      https://kubernetes.io/docs/concepts/overview/working-with-objects/names/#names
                                      TODO: Add other useful fields. apiVersion, kind,
                                      uid?'
                                    type: string
                                required:
                                - name
                                type: object
                            required:
                            - tokenSecretRef
                            type: object
                          rfc2136:
                            description: ACMEIssuerDNS01ProviderRFC2136 is a structure
                              containing the configuration for RFC2136 DNS
                            properties:
                              nameserver:
                                description: 'The IP address of the DNS supporting
                                  RFC2136. Required. Note: FQDN is not a valid value,
                                  only IP.'
                                type: string
                              tsigAlgorithm:
                                description: 'The TSIG Algorithm configured in the
                                  DNS supporting RFC2136. Used only when ``tsigSecretSecretRef``
                                  and ``tsigKeyName`` are defined. Supported values
                                  are (case-insensitive): ``HMACMD5`` (default), ``HMACSHA1``,
                                  ``HMACSHA256`` or ``HMACSHA512``.'
                                type: string
                              tsigKeyName:
                                description: The TSIG Key name configured in the DNS.
                                  If ``tsigSecretSecretRef`` is defined, this field
                                  is required.
                                type: string
                              tsigSecretSecretRef:
                                description: The name of the secret containing the
                                  TSIG value. If ``tsigKeyName`` is defined, this
                                  field is required.
                                properties:
                                  key:
                                    description: The key of the secret to select from.
                                      Must be a valid secret key.
                                    type: string
                                  name:
                                    description: 'Name of the referent. More info:
                                      https://kubernetes.io/docs/concepts/overview/working-with-objects/names/#names
                                      TODO: Add other useful fields. apiVersion, kind,
                                      uid?'
                                    type: string
                                required:
                                - name
                                type: object
                            required:
                            - nameserver
                            type: object
                          route53:
                            description: ACMEIssuerDNS01ProviderRoute53 is a structure
                              containing the Route 53 configuration for AWS
                            properties:
                              accessKeyID:
                                description: 'The AccessKeyID is used for authentication.
                                  If not set we fall-back to using env vars, shared
                                  credentials file or AWS Instance metadata see: https://docs.aws.amazon.com/sdk-for-go/v1/developer-guide/configuring-sdk.html#specifying-credentials'
                                type: string
                              hostedZoneID:
                                description: If set, the provider will manage only
                                  this zone in Route53 and will not do an lookup using
                                  the route53:ListHostedZonesByName api call.
                                type: string
                              region:
                                description: Always set the region when using AccessKeyID
                                  and SecretAccessKey
                                type: string
                              role:
                                description: Role is a Role ARN which the Route53
                                  provider will assume using either the explicit credentials
                                  AccessKeyID/SecretAccessKey or the inferred credentials
                                  from environment variables, shared credentials file
                                  or AWS Instance metadata
                                type: string
                              secretAccessKeySecretRef:
                                description: The SecretAccessKey is used for authentication.
                                  If not set we fall-back to using env vars, shared
                                  credentials file or AWS Instance metadata https://docs.aws.amazon.com/sdk-for-go/v1/developer-guide/configuring-sdk.html#specifying-credentials
                                properties:
                                  key:
                                    description: The key of the secret to select from.
                                      Must be a valid secret key.
                                    type: string
                                  name:
                                    description: 'Name of the referent. More info:
                                      https://kubernetes.io/docs/concepts/overview/working-with-objects/names/#names
                                      TODO: Add other useful fields. apiVersion, kind,
                                      uid?'
                                    type: string
                                required:
                                - name
                                type: object
                            required:
                            - region
                            type: object
                          webhook:
                            description: ACMEIssuerDNS01ProviderWebhook specifies
                              configuration for a webhook DNS01 provider, including
                              where to POST ChallengePayload resources.
                            properties:
                              config:
                                description: Additional configuration that should
                                  be passed to the webhook apiserver when challenges
                                  are processed. This can contain arbitrary JSON data.
                                  Secret values should not be specified in this stanza.
                                  If secret values are needed (e.g. credentials for
                                  a DNS service), you should use a SecretKeySelector
                                  to reference a Secret resource. For details on the
                                  schema of this field, consult the webhook provider
                                  implementation's documentation.
                                x-kubernetes-preserve-unknown-fields: true
                              groupName:
                                description: The API group name that should be used
                                  when POSTing ChallengePayload resources to the webhook
                                  apiserver. This should be the same as the GroupName
                                  specified in the webhook provider implementation.
                                type: string
                              solverName:
                                description: The name of the solver to use, as defined
                                  in the webhook provider implementation. This will
                                  typically be the name of the provider, e.g. 'cloudflare'.
                                type: string
                            required:
                            - groupName
                            - solverName
                            type: object
                        type: object
                      http01:
                        description: ACMEChallengeSolverHTTP01 contains configuration
                          detailing how to solve HTTP01 challenges within a Kubernetes
                          cluster. Typically this is accomplished through creating
                          'routes' of some description that configure ingress controllers
                          to direct traffic to 'solver pods', which are responsible
                          for responding to the ACME server's HTTP requests.
                        properties:
                          ingress:
                            description: The ingress based HTTP01 challenge solver
                              will solve challenges by creating or modifying Ingress
                              resources in order to route requests for '/.well-known/acme-challenge/XYZ'
                              to 'challenge solver' pods that are provisioned by cert-manager
                              for each Challenge to be completed.
                            properties:
                              class:
                                description: The ingress class to use when creating
                                  Ingress resources to solve ACME challenges that
                                  use this challenge solver. Only one of 'class' or
                                  'name' may be specified.
                                type: string
                              name:
                                description: The name of the ingress resource that
                                  should have ACME challenge solving routes inserted
                                  into it in order to solve HTTP01 challenges. This
                                  is typically used in conjunction with ingress controllers
                                  like ingress-gce, which maintains a 1:1 mapping
                                  between external IPs and ingress resources.
                                type: string
                              podTemplate:
                                description: Optional pod template used to configure
                                  the ACME challenge solver pods used for HTTP01 challenges
                                properties:
                                  metadata:
                                    description: ObjectMeta overrides for the pod
                                      used to solve HTTP01 challenges. Only the 'labels'
                                      and 'annotations' fields may be set. If labels
                                      or annotations overlap with in-built values,
                                      the values here will override the in-built values.
                                    properties:
                                      annotations:
                                        additionalProperties:
                                          type: string
                                        description: Annotations that should be added
                                          to the create ACME HTTP01 solver pods.
                                        type: object
                                      labels:
                                        additionalProperties:
                                          type: string
                                        description: Labels that should be added to
                                          the created ACME HTTP01 solver pods.
                                        type: object
                                    type: object
                                  spec:
                                    description: PodSpec defines overrides for the
                                      HTTP01 challenge solver pod. Only the 'nodeSelector',
                                      'affinity' and 'tolerations' fields are supported
                                      currently. All other fields will be ignored.
                                    properties:
                                      affinity:
                                        description: If specified, the pod's scheduling
                                          constraints
                                        properties:
                                          nodeAffinity:
                                            description: Describes node affinity scheduling
                                              rules for the pod.
                                            properties:
                                              preferredDuringSchedulingIgnoredDuringExecution:
                                                description: The scheduler will prefer
                                                  to schedule pods to nodes that satisfy
                                                  the affinity expressions specified
                                                  by this field, but it may choose
                                                  a node that violates one or more
                                                  of the expressions. The node that
                                                  is most preferred is the one with
                                                  the greatest sum of weights, i.e.
                                                  for each node that meets all of
                                                  the scheduling requirements (resource
                                                  request, requiredDuringScheduling
                                                  affinity expressions, etc.), compute
                                                  a sum by iterating through the elements
                                                  of this field and adding "weight"
                                                  to the sum if the node matches the
                                                  corresponding matchExpressions;
                                                  the node(s) with the highest sum
                                                  are the most preferred.
                                                items:
                                                  description: An empty preferred
                                                    scheduling term matches all objects
                                                    with implicit weight 0 (i.e. it's
                                                    a no-op). A null preferred scheduling
                                                    term matches no objects (i.e.
                                                    is also a no-op).
                                                  properties:
                                                    preference:
                                                      description: A node selector
                                                        term, associated with the
                                                        corresponding weight.
                                                      properties:
                                                        matchExpressions:
                                                          description: A list of node
                                                            selector requirements
                                                            by node's labels.
                                                          items:
                                                            description: A node selector
                                                              requirement is a selector
                                                              that contains values,
                                                              a key, and an operator
                                                              that relates the key
                                                              and values.
                                                            properties:
                                                              key:
                                                                description: The label
                                                                  key that the selector
                                                                  applies to.
                                                                type: string
                                                              operator:
                                                                description: Represents
                                                                  a key's relationship
                                                                  to a set of values.
                                                                  Valid operators
                                                                  are In, NotIn, Exists,
                                                                  DoesNotExist. Gt,
                                                                  and Lt.
                                                                type: string
                                                              values:
                                                                description: An array
                                                                  of string values.
                                                                  If the operator
                                                                  is In or NotIn,
                                                                  the values array
                                                                  must be non-empty.
                                                                  If the operator
                                                                  is Exists or DoesNotExist,
                                                                  the values array
                                                                  must be empty. If
                                                                  the operator is
                                                                  Gt or Lt, the values
                                                                  array must have
                                                                  a single element,
                                                                  which will be interpreted
                                                                  as an integer. This
                                                                  array is replaced
                                                                  during a strategic
                                                                  merge patch.
                                                                items:
                                                                  type: string
                                                                type: array
                                                            required:
                                                            - key
                                                            - operator
                                                            type: object
                                                          type: array
                                                        matchFields:
                                                          description: A list of node
                                                            selector requirements
                                                            by node's fields.
                                                          items:
                                                            description: A node selector
                                                              requirement is a selector
                                                              that contains values,
                                                              a key, and an operator
                                                              that relates the key
                                                              and values.
                                                            properties:
                                                              key:
                                                                description: The label
                                                                  key that the selector
                                                                  applies to.
                                                                type: string
                                                              operator:
                                                                description: Represents
                                                                  a key's relationship
                                                                  to a set of values.
                                                                  Valid operators
                                                                  are In, NotIn, Exists,
                                                                  DoesNotExist. Gt,
                                                                  and Lt.
                                                                type: string
                                                              values:
                                                                description: An array
                                                                  of string values.
                                                                  If the operator
                                                                  is In or NotIn,
                                                                  the values array
                                                                  must be non-empty.
                                                                  If the operator
                                                                  is Exists or DoesNotExist,
                                                                  the values array
                                                                  must be empty. If
                                                                  the operator is
                                                                  Gt or Lt, the values
                                                                  array must have
                                                                  a single element,
                                                                  which will be interpreted
                                                                  as an integer. This
                                                                  array is replaced
                                                                  during a strategic
                                                                  merge patch.
                                                                items:
                                                                  type: string
                                                                type: array
                                                            required:
                                                            - key
                                                            - operator
                                                            type: object
                                                          type: array
                                                      type: object
                                                    weight:
                                                      description: Weight associated
                                                        with matching the corresponding
                                                        nodeSelectorTerm, in the range
                                                        1-100.
                                                      format: int32
                                                      type: integer
                                                  required:
                                                  - preference
                                                  - weight
                                                  type: object
                                                type: array
                                              requiredDuringSchedulingIgnoredDuringExecution:
                                                description: If the affinity requirements
                                                  specified by this field are not
                                                  met at scheduling time, the pod
                                                  will not be scheduled onto the node.
                                                  If the affinity requirements specified
                                                  by this field cease to be met at
                                                  some point during pod execution
                                                  (e.g. due to an update), the system
                                                  may or may not try to eventually
                                                  evict the pod from its node.
                                                properties:
                                                  nodeSelectorTerms:
                                                    description: Required. A list
                                                      of node selector terms. The
                                                      terms are ORed.
                                                    items:
                                                      description: A null or empty
                                                        node selector term matches
                                                        no objects. The requirements
                                                        of them are ANDed. The TopologySelectorTerm
                                                        type implements a subset of
                                                        the NodeSelectorTerm.
                                                      properties:
                                                        matchExpressions:
                                                          description: A list of node
                                                            selector requirements
                                                            by node's labels.
                                                          items:
                                                            description: A node selector
                                                              requirement is a selector
                                                              that contains values,
                                                              a key, and an operator
                                                              that relates the key
                                                              and values.
                                                            properties:
                                                              key:
                                                                description: The label
                                                                  key that the selector
                                                                  applies to.
                                                                type: string
                                                              operator:
                                                                description: Represents
                                                                  a key's relationship
                                                                  to a set of values.
                                                                  Valid operators
                                                                  are In, NotIn, Exists,
                                                                  DoesNotExist. Gt,
                                                                  and Lt.
                                                                type: string
                                                              values:
                                                                description: An array
                                                                  of string values.
                                                                  If the operator
                                                                  is In or NotIn,
                                                                  the values array
                                                                  must be non-empty.
                                                                  If the operator
                                                                  is Exists or DoesNotExist,
                                                                  the values array
                                                                  must be empty. If
                                                                  the operator is
                                                                  Gt or Lt, the values
                                                                  array must have
                                                                  a single element,
                                                                  which will be interpreted
                                                                  as an integer. This
                                                                  array is replaced
                                                                  during a strategic
                                                                  merge patch.
                                                                items:
                                                                  type: string
                                                                type: array
                                                            required:
                                                            - key
                                                            - operator
                                                            type: object
                                                          type: array
                                                        matchFields:
                                                          description: A list of node
                                                            selector requirements
                                                            by node's fields.
                                                          items:
                                                            description: A node selector
                                                              requirement is a selector
                                                              that contains values,
                                                              a key, and an operator
                                                              that relates the key
                                                              and values.
                                                            properties:
                                                              key:
                                                                description: The label
                                                                  key that the selector
                                                                  applies to.
                                                                type: string
                                                              operator:
                                                                description: Represents
                                                                  a key's relationship
                                                                  to a set of values.
                                                                  Valid operators
                                                                  are In, NotIn, Exists,
                                                                  DoesNotExist. Gt,
                                                                  and Lt.
                                                                type: string
                                                              values:
                                                                description: An array
                                                                  of string values.
                                                                  If the operator
                                                                  is In or NotIn,
                                                                  the values array
                                                                  must be non-empty.
                                                                  If the operator
                                                                  is Exists or DoesNotExist,
                                                                  the values array
                                                                  must be empty. If
                                                                  the operator is
                                                                  Gt or Lt, the values
                                                                  array must have
                                                                  a single element,
                                                                  which will be interpreted
                                                                  as an integer. This
                                                                  array is replaced
                                                                  during a strategic
                                                                  merge patch.
                                                                items:
                                                                  type: string
                                                                type: array
                                                            required:
                                                            - key
                                                            - operator
                                                            type: object
                                                          type: array
                                                      type: object
                                                    type: array
                                                required:
                                                - nodeSelectorTerms
                                                type: object
                                            type: object
                                          podAffinity:
                                            description: Describes pod affinity scheduling
                                              rules (e.g. co-locate this pod in the
                                              same node, zone, etc. as some other
                                              pod(s)).
                                            properties:
                                              preferredDuringSchedulingIgnoredDuringExecution:
                                                description: The scheduler will prefer
                                                  to schedule pods to nodes that satisfy
                                                  the affinity expressions specified
                                                  by this field, but it may choose
                                                  a node that violates one or more
                                                  of the expressions. The node that
                                                  is most preferred is the one with
                                                  the greatest sum of weights, i.e.
                                                  for each node that meets all of
                                                  the scheduling requirements (resource
                                                  request, requiredDuringScheduling
                                                  affinity expressions, etc.), compute
                                                  a sum by iterating through the elements
                                                  of this field and adding "weight"
                                                  to the sum if the node has pods
                                                  which matches the corresponding
                                                  podAffinityTerm; the node(s) with
                                                  the highest sum are the most preferred.
                                                items:
                                                  description: The weights of all
                                                    of the matched WeightedPodAffinityTerm
                                                    fields are added per-node to find
                                                    the most preferred node(s)
                                                  properties:
                                                    podAffinityTerm:
                                                      description: Required. A pod
                                                        affinity term, associated
                                                        with the corresponding weight.
                                                      properties:
                                                        labelSelector:
                                                          description: A label query
                                                            over a set of resources,
                                                            in this case pods.
                                                          properties:
                                                            matchExpressions:
                                                              description: matchExpressions
                                                                is a list of label
                                                                selector requirements.
                                                                The requirements are
                                                                ANDed.
                                                              items:
                                                                description: A label
                                                                  selector requirement
                                                                  is a selector that
                                                                  contains values,
                                                                  a key, and an operator
                                                                  that relates the
                                                                  key and values.
                                                                properties:
                                                                  key:
                                                                    description: key
                                                                      is the label
                                                                      key that the
                                                                      selector applies
                                                                      to.
                                                                    type: string
                                                                  operator:
                                                                    description: operator
                                                                      represents a
                                                                      key's relationship
                                                                      to a set of
                                                                      values. Valid
                                                                      operators are
                                                                      In, NotIn, Exists
                                                                      and DoesNotExist.
                                                                    type: string
                                                                  values:
                                                                    description: values
                                                                      is an array
                                                                      of string values.
                                                                      If the operator
                                                                      is In or NotIn,
                                                                      the values array
                                                                      must be non-empty.
                                                                      If the operator
                                                                      is Exists or
                                                                      DoesNotExist,
                                                                      the values array
                                                                      must be empty.
                                                                      This array is
                                                                      replaced during
                                                                      a strategic
                                                                      merge patch.
                                                                    items:
                                                                      type: string
                                                                    type: array
                                                                required:
                                                                - key
                                                                - operator
                                                                type: object
                                                              type: array
                                                            matchLabels:
                                                              additionalProperties:
                                                                type: string
                                                              description: matchLabels
                                                                is a map of {key,value}
                                                                pairs. A single {key,value}
                                                                in the matchLabels
                                                                map is equivalent
                                                                to an element of matchExpressions,
                                                                whose key field is
                                                                "key", the operator
                                                                is "In", and the values
                                                                array contains only
                                                                "value". The requirements
                                                                are ANDed.
                                                              type: object
                                                          type: object
                                                        namespaces:
                                                          description: namespaces
                                                            specifies which namespaces
                                                            the labelSelector applies
                                                            to (matches against);
                                                            null or empty list means
                                                            "this pod's namespace"
                                                          items:
                                                            type: string
                                                          type: array
                                                        topologyKey:
                                                          description: This pod should
                                                            be co-located (affinity)
                                                            or not co-located (anti-affinity)
                                                            with the pods matching
                                                            the labelSelector in the
                                                            specified namespaces,
                                                            where co-located is defined
                                                            as running on a node whose
                                                            value of the label with
                                                            key topologyKey matches
                                                            that of any node on which
                                                            any of the selected pods
                                                            is running. Empty topologyKey
                                                            is not allowed.
                                                          type: string
                                                      required:
                                                      - topologyKey
                                                      type: object
                                                    weight:
                                                      description: weight associated
                                                        with matching the corresponding
                                                        podAffinityTerm, in the range
                                                        1-100.
                                                      format: int32
                                                      type: integer
                                                  required:
                                                  - podAffinityTerm
                                                  - weight
                                                  type: object
                                                type: array
                                              requiredDuringSchedulingIgnoredDuringExecution:
                                                description: If the affinity requirements
                                                  specified by this field are not
                                                  met at scheduling time, the pod
                                                  will not be scheduled onto the node.
                                                  If the affinity requirements specified
                                                  by this field cease to be met at
                                                  some point during pod execution
                                                  (e.g. due to a pod label update),
                                                  the system may or may not try to
                                                  eventually evict the pod from its
                                                  node. When there are multiple elements,
                                                  the lists of nodes corresponding
                                                  to each podAffinityTerm are intersected,
                                                  i.e. all terms must be satisfied.
                                                items:
                                                  description: Defines a set of pods
                                                    (namely those matching the labelSelector
                                                    relative to the given namespace(s))
                                                    that this pod should be co-located
                                                    (affinity) or not co-located (anti-affinity)
                                                    with, where co-located is defined
                                                    as running on a node whose value
                                                    of the label with key <topologyKey>
                                                    matches that of any node on which
                                                    a pod of the set of pods is running
                                                  properties:
                                                    labelSelector:
                                                      description: A label query over
                                                        a set of resources, in this
                                                        case pods.
                                                      properties:
                                                        matchExpressions:
                                                          description: matchExpressions
                                                            is a list of label selector
                                                            requirements. The requirements
                                                            are ANDed.
                                                          items:
                                                            description: A label selector
                                                              requirement is a selector
                                                              that contains values,
                                                              a key, and an operator
                                                              that relates the key
                                                              and values.
                                                            properties:
                                                              key:
                                                                description: key is
                                                                  the label key that
                                                                  the selector applies
                                                                  to.
                                                                type: string
                                                              operator:
                                                                description: operator
                                                                  represents a key's
                                                                  relationship to
                                                                  a set of values.
                                                                  Valid operators
                                                                  are In, NotIn, Exists
                                                                  and DoesNotExist.
                                                                type: string
                                                              values:
                                                                description: values
                                                                  is an array of string
                                                                  values. If the operator
                                                                  is In or NotIn,
                                                                  the values array
                                                                  must be non-empty.
                                                                  If the operator
                                                                  is Exists or DoesNotExist,
                                                                  the values array
                                                                  must be empty. This
                                                                  array is replaced
                                                                  during a strategic
                                                                  merge patch.
                                                                items:
                                                                  type: string
                                                                type: array
                                                            required:
                                                            - key
                                                            - operator
                                                            type: object
                                                          type: array
                                                        matchLabels:
                                                          additionalProperties:
                                                            type: string
                                                          description: matchLabels
                                                            is a map of {key,value}
                                                            pairs. A single {key,value}
                                                            in the matchLabels map
                                                            is equivalent to an element
                                                            of matchExpressions, whose
                                                            key field is "key", the
                                                            operator is "In", and
                                                            the values array contains
                                                            only "value". The requirements
                                                            are ANDed.
                                                          type: object
                                                      type: object
                                                    namespaces:
                                                      description: namespaces specifies
                                                        which namespaces the labelSelector
                                                        applies to (matches against);
                                                        null or empty list means "this
                                                        pod's namespace"
                                                      items:
                                                        type: string
                                                      type: array
                                                    topologyKey:
                                                      description: This pod should
                                                        be co-located (affinity) or
                                                        not co-located (anti-affinity)
                                                        with the pods matching the
                                                        labelSelector in the specified
                                                        namespaces, where co-located
                                                        is defined as running on a
                                                        node whose value of the label
                                                        with key topologyKey matches
                                                        that of any node on which
                                                        any of the selected pods is
                                                        running. Empty topologyKey
                                                        is not allowed.
                                                      type: string
                                                  required:
                                                  - topologyKey
                                                  type: object
                                                type: array
                                            type: object
                                          podAntiAffinity:
                                            description: Describes pod anti-affinity
                                              scheduling rules (e.g. avoid putting
                                              this pod in the same node, zone, etc.
                                              as some other pod(s)).
                                            properties:
                                              preferredDuringSchedulingIgnoredDuringExecution:
                                                description: The scheduler will prefer
                                                  to schedule pods to nodes that satisfy
                                                  the anti-affinity expressions specified
                                                  by this field, but it may choose
                                                  a node that violates one or more
                                                  of the expressions. The node that
                                                  is most preferred is the one with
                                                  the greatest sum of weights, i.e.
                                                  for each node that meets all of
                                                  the scheduling requirements (resource
                                                  request, requiredDuringScheduling
                                                  anti-affinity expressions, etc.),
                                                  compute a sum by iterating through
                                                  the elements of this field and adding
                                                  "weight" to the sum if the node
                                                  has pods which matches the corresponding
                                                  podAffinityTerm; the node(s) with
                                                  the highest sum are the most preferred.
                                                items:
                                                  description: The weights of all
                                                    of the matched WeightedPodAffinityTerm
                                                    fields are added per-node to find
                                                    the most preferred node(s)
                                                  properties:
                                                    podAffinityTerm:
                                                      description: Required. A pod
                                                        affinity term, associated
                                                        with the corresponding weight.
                                                      properties:
                                                        labelSelector:
                                                          description: A label query
                                                            over a set of resources,
                                                            in this case pods.
                                                          properties:
                                                            matchExpressions:
                                                              description: matchExpressions
                                                                is a list of label
                                                                selector requirements.
                                                                The requirements are
                                                                ANDed.
                                                              items:
                                                                description: A label
                                                                  selector requirement
                                                                  is a selector that
                                                                  contains values,
                                                                  a key, and an operator
                                                                  that relates the
                                                                  key and values.
                                                                properties:
                                                                  key:
                                                                    description: key
                                                                      is the label
                                                                      key that the
                                                                      selector applies
                                                                      to.
                                                                    type: string
                                                                  operator:
                                                                    description: operator
                                                                      represents a
                                                                      key's relationship
                                                                      to a set of
                                                                      values. Valid
                                                                      operators are
                                                                      In, NotIn, Exists
                                                                      and DoesNotExist.
                                                                    type: string
                                                                  values:
                                                                    description: values
                                                                      is an array
                                                                      of string values.
                                                                      If the operator
                                                                      is In or NotIn,
                                                                      the values array
                                                                      must be non-empty.
                                                                      If the operator
                                                                      is Exists or
                                                                      DoesNotExist,
                                                                      the values array
                                                                      must be empty.
                                                                      This array is
                                                                      replaced during
                                                                      a strategic
                                                                      merge patch.
                                                                    items:
                                                                      type: string
                                                                    type: array
                                                                required:
                                                                - key
                                                                - operator
                                                                type: object
                                                              type: array
                                                            matchLabels:
                                                              additionalProperties:
                                                                type: string
                                                              description: matchLabels
                                                                is a map of {key,value}
                                                                pairs. A single {key,value}
                                                                in the matchLabels
                                                                map is equivalent
                                                                to an element of matchExpressions,
                                                                whose key field is
                                                                "key", the operator
                                                                is "In", and the values
                                                                array contains only
                                                                "value". The requirements
                                                                are ANDed.
                                                              type: object
                                                          type: object
                                                        namespaces:
                                                          description: namespaces
                                                            specifies which namespaces
                                                            the labelSelector applies
                                                            to (matches against);
                                                            null or empty list means
                                                            "this pod's namespace"
                                                          items:
                                                            type: string
                                                          type: array
                                                        topologyKey:
                                                          description: This pod should
                                                            be co-located (affinity)
                                                            or not co-located (anti-affinity)
                                                            with the pods matching
                                                            the labelSelector in the
                                                            specified namespaces,
                                                            where co-located is defined
                                                            as running on a node whose
                                                            value of the label with
                                                            key topologyKey matches
                                                            that of any node on which
                                                            any of the selected pods
                                                            is running. Empty topologyKey
                                                            is not allowed.
                                                          type: string
                                                      required:
                                                      - topologyKey
                                                      type: object
                                                    weight:
                                                      description: weight associated
                                                        with matching the corresponding
                                                        podAffinityTerm, in the range
                                                        1-100.
                                                      format: int32
                                                      type: integer
                                                  required:
                                                  - podAffinityTerm
                                                  - weight
                                                  type: object
                                                type: array
                                              requiredDuringSchedulingIgnoredDuringExecution:
                                                description: If the anti-affinity
                                                  requirements specified by this field
                                                  are not met at scheduling time,
                                                  the pod will not be scheduled onto
                                                  the node. If the anti-affinity requirements
                                                  specified by this field cease to
                                                  be met at some point during pod
                                                  execution (e.g. due to a pod label
                                                  update), the system may or may not
                                                  try to eventually evict the pod
                                                  from its node. When there are multiple
                                                  elements, the lists of nodes corresponding
                                                  to each podAffinityTerm are intersected,
                                                  i.e. all terms must be satisfied.
                                                items:
                                                  description: Defines a set of pods
                                                    (namely those matching the labelSelector
                                                    relative to the given namespace(s))
                                                    that this pod should be co-located
                                                    (affinity) or not co-located (anti-affinity)
                                                    with, where co-located is defined
                                                    as running on a node whose value
                                                    of the label with key <topologyKey>
                                                    matches that of any node on which
                                                    a pod of the set of pods is running
                                                  properties:
                                                    labelSelector:
                                                      description: A label query over
                                                        a set of resources, in this
                                                        case pods.
                                                      properties:
                                                        matchExpressions:
                                                          description: matchExpressions
                                                            is a list of label selector
                                                            requirements. The requirements
                                                            are ANDed.
                                                          items:
                                                            description: A label selector
                                                              requirement is a selector
                                                              that contains values,
                                                              a key, and an operator
                                                              that relates the key
                                                              and values.
                                                            properties:
                                                              key:
                                                                description: key is
                                                                  the label key that
                                                                  the selector applies
                                                                  to.
                                                                type: string
                                                              operator:
                                                                description: operator
                                                                  represents a key's
                                                                  relationship to
                                                                  a set of values.
                                                                  Valid operators
                                                                  are In, NotIn, Exists
                                                                  and DoesNotExist.
                                                                type: string
                                                              values:
                                                                description: values
                                                                  is an array of string
                                                                  values. If the operator
                                                                  is In or NotIn,
                                                                  the values array
                                                                  must be non-empty.
                                                                  If the operator
                                                                  is Exists or DoesNotExist,
                                                                  the values array
                                                                  must be empty. This
                                                                  array is replaced
                                                                  during a strategic
                                                                  merge patch.
                                                                items:
                                                                  type: string
                                                                type: array
                                                            required:
                                                            - key
                                                            - operator
                                                            type: object
                                                          type: array
                                                        matchLabels:
                                                          additionalProperties:
                                                            type: string
                                                          description: matchLabels
                                                            is a map of {key,value}
                                                            pairs. A single {key,value}
                                                            in the matchLabels map
                                                            is equivalent to an element
                                                            of matchExpressions, whose
                                                            key field is "key", the
                                                            operator is "In", and
                                                            the values array contains
                                                            only "value". The requirements
                                                            are ANDed.
                                                          type: object
                                                      type: object
                                                    namespaces:
                                                      description: namespaces specifies
                                                        which namespaces the labelSelector
                                                        applies to (matches against);
                                                        null or empty list means "this
                                                        pod's namespace"
                                                      items:
                                                        type: string
                                                      type: array
                                                    topologyKey:
                                                      description: This pod should
                                                        be co-located (affinity) or
                                                        not co-located (anti-affinity)
                                                        with the pods matching the
                                                        labelSelector in the specified
                                                        namespaces, where co-located
                                                        is defined as running on a
                                                        node whose value of the label
                                                        with key topologyKey matches
                                                        that of any node on which
                                                        any of the selected pods is
                                                        running. Empty topologyKey
                                                        is not allowed.
                                                      type: string
                                                  required:
                                                  - topologyKey
                                                  type: object
                                                type: array
                                            type: object
                                        type: object
                                      nodeSelector:
                                        additionalProperties:
                                          type: string
                                        description: 'NodeSelector is a selector which
                                          must be true for the pod to fit on a node.
                                          Selector which must match a node''s labels
                                          for the pod to be scheduled on that node.
                                          More info: https://kubernetes.io/docs/concepts/configuration/assign-pod-node/'
                                        type: object
                                      tolerations:
                                        description: If specified, the pod's tolerations.
                                        items:
                                          description: The pod this Toleration is
                                            attached to tolerates any taint that matches
                                            the triple <key,value,effect> using the
                                            matching operator <operator>.
                                          properties:
                                            effect:
                                              description: Effect indicates the taint
                                                effect to match. Empty means match
                                                all taint effects. When specified,
                                                allowed values are NoSchedule, PreferNoSchedule
                                                and NoExecute.
                                              type: string
                                            key:
                                              description: Key is the taint key that
                                                the toleration applies to. Empty means
                                                match all taint keys. If the key is
                                                empty, operator must be Exists; this
                                                combination means to match all values
                                                and all keys.
                                              type: string
                                            operator:
                                              description: Operator represents a key's
                                                relationship to the value. Valid operators
                                                are Exists and Equal. Defaults to
                                                Equal. Exists is equivalent to wildcard
                                                for value, so that a pod can tolerate
                                                all taints of a particular category.
                                              type: string
                                            tolerationSeconds:
                                              description: TolerationSeconds represents
                                                the period of time the toleration
                                                (which must be of effect NoExecute,
                                                otherwise this field is ignored) tolerates
                                                the taint. By default, it is not set,
                                                which means tolerate the taint forever
                                                (do not evict). Zero and negative
                                                values will be treated as 0 (evict
                                                immediately) by the system.
                                              format: int64
                                              type: integer
                                            value:
                                              description: Value is the taint value
                                                the toleration matches to. If the
                                                operator is Exists, the value should
                                                be empty, otherwise just a regular
                                                string.
                                              type: string
                                          type: object
                                        type: array
                                    type: object
                                type: object
                              serviceType:
                                description: Optional service type for Kubernetes
                                  solver service
                                type: string
                            type: object
                        type: object
                      selector:
                        description: Selector selects a set of DNSNames on the Certificate
                          resource that should be solved using this challenge solver.
                        properties:
                          dnsNames:
                            description: List of DNSNames that this solver will be
                              used to solve. If specified and a match is found, a
                              dnsNames selector will take precedence over a dnsZones
                              selector. If multiple solvers match with the same dnsNames
                              value, the solver with the most matching labels in matchLabels
                              will be selected. If neither has more matches, the solver
                              defined earlier in the list will be selected.
                            items:
                              type: string
                            type: array
                          dnsZones:
                            description: List of DNSZones that this solver will be
                              used to solve. The most specific DNS zone match specified
                              here will take precedence over other DNS zone matches,
                              so a solver specifying sys.example.com will be selected
                              over one specifying example.com for the domain www.sys.example.com.
                              If multiple solvers match with the same dnsZones value,
                              the solver with the most matching labels in matchLabels
                              will be selected. If neither has more matches, the solver
                              defined earlier in the list will be selected.
                            items:
                              type: string
                            type: array
                          matchLabels:
                            additionalProperties:
                              type: string
                            description: A label selector that is used to refine the
                              set of certificate's that this challenge solver will
                              apply to.
                            type: object
                        type: object
                    type: object
                  type: array
              required:
              - privateKeySecretRef
              - server
              type: object
            ca:
              properties:
                secretName:
                  description: SecretName is the name of the secret used to sign Certificates
                    issued by this Issuer.
                  type: string
              required:
              - secretName
              type: object
            selfSigned:
              type: object
            vault:
              properties:
                auth:
                  description: Vault authentication
                  properties:
                    appRole:
                      description: This Secret contains a AppRole and Secret
                      properties:
                        path:
                          description: Where the authentication path is mounted in
                            Vault.
                          type: string
                        roleId:
                          type: string
                        secretRef:
                          properties:
                            key:
                              description: The key of the secret to select from. Must
                                be a valid secret key.
                              type: string
                            name:
                              description: 'Name of the referent. More info: https://kubernetes.io/docs/concepts/overview/working-with-objects/names/#names
                                TODO: Add other useful fields. apiVersion, kind, uid?'
                              type: string
                          required:
                          - name
                          type: object
                      required:
                      - path
                      - roleId
                      - secretRef
                      type: object
                    kubernetes:
                      description: This contains a Role and Secret with a ServiceAccount
                        token to authenticate with vault.
                      properties:
                        mountPath:
                          description: The Vault mountPath here is the mount path
                            to use when authenticating with Vault. For example, setting
                            a value to `/v1/auth/foo`, will use the path `/v1/auth/foo/login`
                            to authenticate with Vault. If unspecified, the default
                            value "/v1/auth/kubernetes" will be used.
                          type: string
                        role:
                          description: A required field containing the Vault Role
                            to assume. A Role binds a Kubernetes ServiceAccount with
                            a set of Vault policies.
                          type: string
                        secretRef:
                          description: The required Secret field containing a Kubernetes
                            ServiceAccount JWT used for authenticating with Vault.
                            Use of 'ambient credentials' is not supported.
                          properties:
                            key:
                              description: The key of the secret to select from. Must
                                be a valid secret key.
                              type: string
                            name:
                              description: 'Name of the referent. More info: https://kubernetes.io/docs/concepts/overview/working-with-objects/names/#names
                                TODO: Add other useful fields. apiVersion, kind, uid?'
                              type: string
                          required:
                          - name
                          type: object
                      required:
                      - role
                      - secretRef
                      type: object
                    tokenSecretRef:
                      description: This Secret contains the Vault token key
                      properties:
                        key:
                          description: The key of the secret to select from. Must
                            be a valid secret key.
                          type: string
                        name:
                          description: 'Name of the referent. More info: https://kubernetes.io/docs/concepts/overview/working-with-objects/names/#names
                            TODO: Add other useful fields. apiVersion, kind, uid?'
                          type: string
                      required:
                      - name
                      type: object
                  type: object
                caBundle:
                  description: Base64 encoded CA bundle to validate Vault server certificate.
                    Only used if the Server URL is using HTTPS protocol. This parameter
                    is ignored for plain HTTP protocol connection. If not set the
                    system root certificates are used to validate the TLS connection.
                  format: byte
                  type: string
                path:
                  description: Vault URL path to the certificate role
                  type: string
                server:
                  description: Server is the vault connection address
                  type: string
              required:
              - auth
              - path
              - server
              type: object
            venafi:
              description: VenafiIssuer describes issuer configuration details for
                Venafi Cloud.
              properties:
                cloud:
                  description: Cloud specifies the Venafi cloud configuration settings.
                    Only one of TPP or Cloud may be specified.
                  properties:
                    apiTokenSecretRef:
                      description: APITokenSecretRef is a secret key selector for
                        the Venafi Cloud API token.
                      properties:
                        key:
                          description: The key of the secret to select from. Must
                            be a valid secret key.
                          type: string
                        name:
                          description: 'Name of the referent. More info: https://kubernetes.io/docs/concepts/overview/working-with-objects/names/#names
                            TODO: Add other useful fields. apiVersion, kind, uid?'
                          type: string
                      required:
                      - name
                      type: object
                    url:
                      description: URL is the base URL for Venafi Cloud
                      type: string
                  required:
                  - apiTokenSecretRef
                  - url
                  type: object
                tpp:
                  description: TPP specifies Trust Protection Platform configuration
                    settings. Only one of TPP or Cloud may be specified.
                  properties:
                    caBundle:
                      description: CABundle is a PEM encoded TLS certifiate to use
                        to verify connections to the TPP instance. If specified, system
                        roots will not be used and the issuing CA for the TPP instance
                        must be verifiable using the provided root. If not specified,
                        the connection will be verified using the cert-manager system
                        root certificates.
                      format: byte
                      type: string
                    credentialsRef:
                      description: CredentialsRef is a reference to a Secret containing
                        the username and password for the TPP server. The secret must
                        contain two keys, 'username' and 'password'.
                      properties:
                        name:
                          description: 'Name of the referent. More info: https://kubernetes.io/docs/concepts/overview/working-with-objects/names/#names
                            TODO: Add other useful fields. apiVersion, kind, uid?'
                          type: string
                      required:
                      - name
                      type: object
                    url:
                      description: URL is the base URL for the Venafi TPP instance
                      type: string
                  required:
                  - credentialsRef
                  - url
                  type: object
                zone:
                  description: Zone is the Venafi Policy Zone to use for this issuer.
                    All requests made to the Venafi platform will be restricted by
                    the named zone policy. This field is required.
                  type: string
              required:
              - zone
              type: object
          type: object
        status:
          description: IssuerStatus contains status information about an Issuer
          properties:
            acme:
              properties:
                lastRegisteredEmail:
                  description: LastRegisteredEmail is the email associated with the
                    latest registered ACME account, in order to track changes made
                    to registered account associated with the  Issuer
                  type: string
                uri:
                  description: URI is the unique account identifier, which can also
                    be used to retrieve account details from the CA
                  type: string
              type: object
            conditions:
              items:
                description: IssuerCondition contains condition information for an
                  Issuer.
                properties:
                  lastTransitionTime:
                    description: LastTransitionTime is the timestamp corresponding
                      to the last status change of this condition.
                    format: date-time
                    type: string
                  message:
                    description: Message is a human readable description of the details
                      of the last transition, complementing reason.
                    type: string
                  reason:
                    description: Reason is a brief machine readable explanation for
                      the condition's last transition.
                    type: string
                  status:
                    description: Status of the condition, one of ('True', 'False',
                      'Unknown').
                    enum:
                    - "True"
                    - "False"
                    - Unknown
                    type: string
                  type:
                    description: Type of the condition, currently ('Ready').
                    type: string
                required:
                - status
                - type
                type: object
              type: array
          type: object
      type: object
  version: v1alpha2
  versions:
  - name: v1alpha2
    served: true
    storage: true
---
apiVersion: apiextensions.k8s.io/v1beta1
kind: CustomResourceDefinition
metadata:
  name: orders.acme.cert-manager.io
spec:
  additionalPrinterColumns:
  - JSONPath: .status.state
    name: State
    type: string
  - JSONPath: .spec.issuerRef.name
    name: Issuer
    priority: 1
    type: string
  - JSONPath: .status.reason
    name: Reason
    priority: 1
    type: string
  - JSONPath: .metadata.creationTimestamp
    description: CreationTimestamp is a timestamp representing the server time when
      this object was created. It is not guaranteed to be set in happens-before order
      across separate operations. Clients may not set this value. It is represented
      in RFC3339 form and is in UTC.
    name: Age
    type: date
  group: acme.cert-manager.io
  names:
    kind: Order
    listKind: OrderList
    plural: orders
    singular: order
  scope: Namespaced
  subresources:
    status: {}
  validation:
    openAPIV3Schema:
      description: Order is a type to represent an Order with an ACME server
      properties:
        apiVersion:
          description: 'APIVersion defines the versioned schema of this representation
            of an object. Servers should convert recognized schemas to the latest
            internal value, and may reject unrecognized values. More info: https://git.k8s.io/community/contributors/devel/sig-architecture/api-conventions.md#resources'
          type: string
        kind:
          description: 'Kind is a string value representing the REST resource this
            object represents. Servers may infer this from the endpoint the client
            submits requests to. Cannot be updated. In CamelCase. More info: https://git.k8s.io/community/contributors/devel/sig-architecture/api-conventions.md#types-kinds'
          type: string
        metadata:
          type: object
        spec:
          properties:
            commonName:
              description: CommonName is the common name as specified on the DER encoded
                CSR. If CommonName is not specified, the first DNSName specified will
                be used as the CommonName. At least one of CommonName or a DNSNames
                must be set. This field must match the corresponding field on the
                DER encoded CSR.
              type: string
            csr:
              description: Certificate signing request bytes in DER encoding. This
                will be used when finalizing the order. This field must be set on
                the order.
              format: byte
              type: string
            dnsNames:
              description: DNSNames is a list of DNS names that should be included
                as part of the Order validation process. If CommonName is not specified,
                the first DNSName specified will be used as the CommonName. At least
                one of CommonName or a DNSNames must be set. This field must match
                the corresponding field on the DER encoded CSR.
              items:
                type: string
              type: array
            issuerRef:
              description: IssuerRef references a properly configured ACME-type Issuer
                which should be used to create this Order. If the Issuer does not
                exist, processing will be retried. If the Issuer is not an 'ACME'
                Issuer, an error will be returned and the Order will be marked as
                failed.
              properties:
                group:
                  type: string
                kind:
                  type: string
                name:
                  type: string
              required:
              - name
              type: object
          required:
          - csr
          - issuerRef
          type: object
        status:
          properties:
            authorizations:
              description: Authorizations contains data returned from the ACME server
                on what authoriations must be completed in order to validate the DNS
                names specified on the Order.
              items:
                description: ACMEAuthorization contains data returned from the ACME
                  server on an authorization that must be completed in order validate
                  a DNS name on an ACME Order resource.
                properties:
                  challenges:
                    description: Challenges specifies the challenge types offered
                      by the ACME server. One of these challenge types will be selected
                      when validating the DNS name and an appropriate Challenge resource
                      will be created to perform the ACME challenge process.
                    items:
                      description: Challenge specifies a challenge offered by the
                        ACME server for an Order. An appropriate Challenge resource
                        can be created to perform the ACME challenge process.
                      properties:
                        token:
                          description: Token is the token that must be presented for
                            this challenge. This is used to compute the 'key' that
                            must also be presented.
                          type: string
                        type:
                          description: Type is the type of challenge being offered,
                            e.g. http-01, dns-01
                          type: string
                        url:
                          description: URL is the URL of this challenge. It can be
                            used to retrieve additional metadata about the Challenge
                            from the ACME server.
                          type: string
                      required:
                      - token
                      - type
                      - url
                      type: object
                    type: array
                  identifier:
                    description: Identifier is the DNS name to be validated as part
                      of this authorization
                    type: string
                  url:
                    description: URL is the URL of the Authorization that must be
                      completed
                    type: string
                  wildcard:
                    description: Wildcard will be true if this authorization is for
                      a wildcard DNS name. If this is true, the identifier will be
                      the *non-wildcard* version of the DNS name. For example, if
                      '*.example.com' is the DNS name being validated, this field
                      will be 'true' and the 'identifier' field will be 'example.com'.
                    type: boolean
                required:
                - url
                type: object
              type: array
            certificate:
              description: Certificate is a copy of the PEM encoded certificate for
                this Order. This field will be populated after the order has been
                successfully finalized with the ACME server, and the order has transitioned
                to the 'valid' state.
              format: byte
              type: string
            failureTime:
              description: FailureTime stores the time that this order failed. This
                is used to influence garbage collection and back-off.
              format: date-time
              type: string
            finalizeURL:
              description: FinalizeURL of the Order. This is used to obtain certificates
                for this order once it has been completed.
              type: string
            reason:
              description: Reason optionally provides more information about a why
                the order is in the current state.
              type: string
            state:
              description: State contains the current state of this Order resource.
                States 'success' and 'expired' are 'final'
              enum:
              - valid
              - ready
              - pending
              - processing
              - invalid
              - expired
              - errored
              type: string
            url:
              description: URL of the Order. This will initially be empty when the
                resource is first created. The Order controller will populate this
                field when the Order is first processed. This field will be immutable
                after it is initially set.
              type: string
          type: object
      required:
      - metadata
      type: object
  version: v1alpha2
  versions:
  - name: v1alpha2
    served: true
    storage: true
---
apiVersion: rbac.authorization.k8s.io/v1beta1
kind: ClusterRole
metadata:
  annotations: {}
  labels:
    name: cert-manager-challenges
  name: cert-manager-challenges
rules:
- apiGroups:
  - acme.cert-manager.io
  resources:
  - challenges
  - challenges/status
  verbs:
  - update
- apiGroups:
  - acme.cert-manager.io
  resources:
  - challenges
  verbs:
  - get
  - list
  - watch
- apiGroups:
  - cert-manager.io
  resources:
  - issuers
  - clusterissuers
  verbs:
  - get
  - list
  - watch
- apiGroups:
  - ""
  resources:
  - secrets
  verbs:
  - get
  - list
  - watch
- apiGroups:
  - ""
  resources:
  - events
  verbs:
  - create
  - patch
- apiGroups:
  - ""
  resources:
  - pods
  - services
  verbs:
  - get
  - list
  - watch
  - create
  - delete
- apiGroups:
  - extensions
  resources:
  - ingresses
  verbs:
  - get
  - list
  - watch
  - create
  - delete
  - update
- apiGroups:
  - acme.cert-manager.io
  resources:
  - challenges/finalizers
  verbs:
  - update
- apiGroups:
  - ""
  resources:
  - secrets
  verbs:
  - get
  - list
  - watch
---
apiVersion: rbac.authorization.k8s.io/v1beta1
kind: ClusterRoleBinding
metadata:
  annotations: {}
  labels:
    name: cert-manager-challenges
  name: cert-manager-challenges
roleRef:
  apiGroup: rbac.authorization.k8s.io
  kind: ClusterRole
  name: cert-manager-challenges
subjects:
- kind: ServiceAccount
  name: cert-manager
  namespace: kubeprod
---
apiVersion: apps/v1
kind: Deployment
metadata:
  annotations: {}
  labels:
    name: cert-manager
  name: cert-manager
  namespace: kubeprod
spec:
  minReadySeconds: 30
  replicas: 1
  revisionHistoryLimit: 10
  selector:
    matchLabels:
      name: cert-manager
  strategy:
    rollingUpdate:
      maxSurge: 25%
      maxUnavailable: 25%
    type: RollingUpdate
  template:
    metadata:
      annotations:
        prometheus.io/path: /metrics
        prometheus.io/port: "9402"
        prometheus.io/scrape: "true"
      labels:
        name: cert-manager
    spec:
      containers:
      - args:
        - --acme-http01-solver-image=quay.io/jetstack/cert-manager-acmesolver:v0.15.2
        - --cluster-resource-namespace=$(POD_NAMESPACE)
        - --default-issuer-kind=ClusterIssuer
        - --default-issuer-name=letsencrypt-prod
        - --leader-election-namespace=$(POD_NAMESPACE)
        - --v=2
        env:
        - name: POD_NAMESPACE
          valueFrom:
            fieldRef:
              apiVersion: v1
              fieldPath: metadata.namespace
        image: bitnami/cert-manager:0.15.2-debian-10-r7
        imagePullPolicy: IfNotPresent
        name: cert-manager
        ports:
        - containerPort: 9402
          name: prometheus
        resources:
          requests:
            cpu: 10m
            memory: 32Mi
        stdin: false
        tty: false
        volumeMounts: []
      imagePullSecrets: []
      initContainers: []
      serviceAccountName: cert-manager
      terminationGracePeriodSeconds: 30
      volumes: []
---
apiVersion: v1
kind: ServiceAccount
metadata:
  annotations: {}
  labels:
    name: external-dns
  name: external-dns
  namespace: kubeprod
---
apiVersion: rbac.authorization.k8s.io/v1beta1
kind: ClusterRole
metadata:
  annotations: {}
  labels:
    name: external-dns
  name: external-dns
rules:
- apiGroups:
  - ""
  resources:
  - services
  - pods
  - nodes
  verbs:
  - get
  - list
  - watch
- apiGroups:
  - extensions
  - networking.k8s.io
  resources:
  - ingresses
  verbs:
  - get
  - list
  - watch
- apiGroups:
  - networking.istio.io
  resources:
  - gateways
  verbs:
  - get
  - list
  - watch
- apiGroups:
  - externaldns.k8s.io
  resources:
  - dnsendpoints
  verbs:
  - get
  - list
  - watch
- apiGroups:
  - externaldns.k8s.io
  resources:
  - dnsendpoints/status
  verbs:
  - update
---
apiVersion: rbac.authorization.k8s.io/v1beta1
kind: ClusterRoleBinding
metadata:
  annotations: {}
  labels:
    name: external-dns-viewer
  name: external-dns-viewer
roleRef:
  apiGroup: rbac.authorization.k8s.io
  kind: ClusterRole
  name: external-dns
subjects:
- kind: ServiceAccount
  name: external-dns
  namespace: kubeprod
---
apiVersion: apiextensions.k8s.io/v1beta1
kind: CustomResourceDefinition
metadata:
  creationTimestamp: null
  labels:
    api: externaldns
    kubebuilder.k8s.io: 1.0.0
  name: dnsendpoints.externaldns.k8s.io
spec:
  group: externaldns.k8s.io
  names:
    kind: DNSEndpoint
    plural: dnsendpoints
  scope: Namespaced
  subresources:
    status: {}
  validation:
    openAPIV3Schema:
      properties:
        apiVersion:
          type: string
        kind:
          type: string
        metadata:
          type: object
        spec:
          properties:
            endpoints:
              items:
                properties:
                  dnsName:
                    type: string
                  labels:
                    type: object
                  providerSpecific:
                    items:
                      properties:
                        name:
                          type: string
                        value:
                          type: string
                      type: object
                    type: array
                  recordTTL:
                    format: int64
                    type: integer
                  recordType:
                    type: string
                  targets:
                    items:
                      type: string
                    type: array
                type: object
              type: array
          type: object
        status:
          properties:
            observedGeneration:
              format: int64
              type: integer
          type: object
  version: v1alpha1
---
apiVersion: apps/v1
kind: Deployment
metadata:
  annotations: {}
  labels:
    name: external-dns
  name: external-dns
  namespace: kubeprod
spec:
  minReadySeconds: 30
  replicas: 1
  revisionHistoryLimit: 10
  selector:
    matchLabels:
      name: external-dns
  strategy:
    rollingUpdate:
      maxSurge: 25%
      maxUnavailable: 25%
    type: RollingUpdate
  template:
    metadata:
      annotations:
        prometheus.io/path: /metrics
        prometheus.io/port: "7979"
        prometheus.io/scrape: "true"
      labels:
        name: external-dns
    spec:
      containers:
      - args:
        - --domain-filter=hosteaching.ovh
        - --log-level=warning
        - --pdns-server=http://powerdns.kubeprod.svc:8081
        - --provider=pdns
        - --registry=txt
        - --txt-owner-id=hosteaching.ovh
        - --txt-prefix=_externaldns.
        - --source=service
        - --source=ingress
        - --source=crd
        env:
        - name: EXTERNAL_DNS_PDNS_API_KEY
          valueFrom:
            secretKeyRef:
              key: api_key
              name: powerdns-77ede1a
        image: bitnami/external-dns:0.7.1-debian-10-r32
        imagePullPolicy: IfNotPresent
        livenessProbe:
          httpGet:
            path: /healthz
            port: metrics
        name: external-dns
        ports:
        - containerPort: 7979
          name: metrics
        readinessProbe:
          httpGet:
            path: /healthz
            port: metrics
        stdin: false
        tty: false
        volumeMounts: []
      imagePullSecrets: []
      initContainers: []
      serviceAccountName: external-dns
      terminationGracePeriodSeconds: 30
      volumes: []
---
apiVersion: v1
data:
  k8s_cluster_capacity.json: |
    {
        "annotations": {
          "list": [
            {
              "builtIn": 1,
              "datasource": "-- Grafana --",
              "enable": true,
              "hide": true,
              "iconColor": "rgba(0, 211, 255, 1)",
              "name": "Annotations & Alerts",
              "type": "dashboard"
            }
          ]
        },
        "description": "Cluster capacity level overview",
        "editable": true,
        "gnetId": 7249,
        "graphTooltip": 0,
        "id": 459209,
        "iteration": 1555692831012,
        "links": [],
        "panels": [
          {
            "cacheTimeout": null,
            "colorBackground": false,
            "colorValue": false,
            "colors": [
              "#299c46",
              "rgba(237, 129, 40, 0.89)",
              "#d44a3a"
            ],
            "datasource": "$datasource",
            "format": "none",
            "gauge": {
              "maxValue": 100,
              "minValue": 0,
              "show": false,
              "thresholdLabels": false,
              "thresholdMarkers": true
            },
            "gridPos": {
              "h": 6,
              "w": 4,
              "x": 0,
              "y": 0
            },
            "id": 21,
            "interval": null,
            "links": [],
            "mappingType": 1,
            "mappingTypes": [
              {
                "name": "value to text",
                "value": 1
              },
              {
                "name": "range to text",
                "value": 2
              }
            ],
            "maxDataPoints": 100,
            "nullPointMode": "connected",
            "nullText": null,
            "postfix": "",
            "postfixFontSize": "50%",
            "prefix": "",
            "prefixFontSize": "50%",
            "rangeMaps": [
              {
                "from": "null",
                "text": "N/A",
                "to": "null"
              }
            ],
            "sparkline": {
              "fillColor": "rgba(31, 118, 189, 0.18)",
              "full": false,
              "lineColor": "rgb(31, 120, 193)",
              "show": true
            },
            "tableColumn": "",
            "targets": [
              {
                "expr": "sum by (name) (delta (nginx_ingress_controller_nginx_process_connections_total{state='accepted'}[1h]))",
                "format": "time_series",
                "instant": false,
                "intervalFactor": 1,
                "refId": "A"
              }
            ],
            "thresholds": "",
            "title": "Ingress accepted connections in last hour",
            "type": "singlestat",
            "valueFontSize": "80%",
            "valueMaps": [
              {
                "op": "=",
                "text": "N/A",
                "value": "null"
              }
            ],
            "valueName": "avg"
          },
          {
            "cacheTimeout": null,
            "colorBackground": false,
            "colorValue": false,
            "colors": [
              "rgba(50, 172, 45, 0.97)",
              "rgba(237, 129, 40, 0.89)",
              "rgba(245, 54, 54, 0.9)"
            ],
            "datasource": "$datasource",
            "decimals": 2,
            "format": "percentunit",
            "gauge": {
              "maxValue": 1,
              "minValue": 0,
              "show": true,
              "thresholdLabels": false,
              "thresholdMarkers": true
            },
            "gridPos": {
              "h": 6,
              "w": 3,
              "x": 4,
              "y": 0
            },
            "id": 4,
            "interval": null,
            "links": [],
            "mappingType": 1,
            "mappingTypes": [
              {
                "name": "value to text",
                "value": 1
              },
              {
                "name": "range to text",
                "value": 2
              }
            ],
            "maxDataPoints": 100,
            "nullPointMode": "connected",
            "nullText": null,
            "postfix": "",
            "postfixFontSize": "50%",
            "prefix": "",
            "prefixFontSize": "50%",
            "rangeMaps": [
              {
                "from": "null",
                "text": "N/A",
                "to": "null"
              }
            ],
            "sparkline": {
              "fillColor": "rgba(31, 118, 189, 0.18)",
              "full": false,
              "lineColor": "rgb(31, 120, 193)",
              "show": true
            },
            "tableColumn": "",
            "targets": [
              {
                "expr": "((sum(node_memory_MemTotal_bytes) - sum(node_memory_MemFree_bytes) - sum(node_memory_Buffers_bytes) - sum(node_memory_Cached_bytes)) / sum(node_memory_MemTotal_bytes))",
                "format": "time_series",
                "intervalFactor": 2,
                "legendFormat": "",
                "refId": "A",
                "step": 40
              }
            ],
            "thresholds": "0.7, 0.9",
            "title": "Cluster memory usage",
            "type": "singlestat",
            "valueFontSize": "80%",
            "valueMaps": [
              {
                "op": "=",
                "text": "N/A",
                "value": "null"
              }
            ],
            "valueName": "min"
          },
          {
            "cacheTimeout": null,
            "colorBackground": false,
            "colorValue": false,
            "colors": [
              "rgba(50, 172, 45, 0.97)",
              "rgba(237, 129, 40, 0.89)",
              "rgba(245, 54, 54, 0.9)"
            ],
            "datasource": "$datasource",
            "description": "",
            "format": "percentunit",
            "gauge": {
              "maxValue": 1,
              "minValue": 0,
              "show": true,
              "thresholdLabels": false,
              "thresholdMarkers": true
            },
            "gridPos": {
              "h": 6,
              "w": 3,
              "x": 7,
              "y": 0
            },
            "id": 2,
            "interval": null,
            "links": [],
            "mappingType": 1,
            "mappingTypes": [
              {
                "name": "value to text",
                "value": 1
              },
              {
                "name": "range to text",
                "value": 2
              }
            ],
            "maxDataPoints": 100,
            "nullPointMode": "connected",
            "nullText": null,
            "postfix": "",
            "postfixFontSize": "50%",
            "prefix": "",
            "prefixFontSize": "50%",
            "rangeMaps": [
              {
                "from": "null",
                "text": "N/A",
                "to": "null"
              }
            ],
            "sparkline": {
              "fillColor": "rgba(31, 118, 189, 0.18)",
              "full": false,
              "lineColor": "rgb(31, 120, 193)",
              "show": true
            },
            "tableColumn": "",
            "targets": [
              {
                "expr": "(sum(node_filesystem_size_bytes{device!=\"rootfs\"}) - sum(node_filesystem_free_bytes{device!=\"rootfs\"})) / sum(node_filesystem_size_bytes{device!=\"rootfs\"})",
                "format": "time_series",
                "intervalFactor": 2,
                "refId": "A",
                "step": 40
              }
            ],
            "thresholds": "0.75, 0.9",
            "title": "Disk space usage",
            "type": "singlestat",
            "valueFontSize": "80%",
            "valueMaps": [
              {
                "op": "=",
                "text": "N/A",
                "value": "null"
              }
            ],
            "valueName": "avg"
          },
          {
            "aliasColors": {},
            "bars": false,
            "dashLength": 10,
            "dashes": false,
            "datasource": "$datasource",
            "fill": 1,
            "gridPos": {
              "h": 6,
              "w": 4,
              "x": 10,
              "y": 0
            },
            "id": 27,
            "legend": {
              "avg": false,
              "current": false,
              "max": false,
              "min": false,
              "show": false,
              "total": false,
              "values": false
            },
            "lines": true,
            "linewidth": 1,
            "links": [],
            "nullPointMode": "null",
            "percentage": false,
            "pointradius": 5,
            "points": false,
            "renderer": "flot",
            "seriesOverrides": [],
            "spaceLength": 10,
            "stack": false,
            "steppedLine": false,
            "targets": [
              {
                "expr": "sum(kube_pod_info)",
                "format": "time_series",
                "intervalFactor": 2,
                "legendFormat": "Current number of Pods",
                "refId": "A"
              },
              {
                "expr": "sum(kube_node_status_capacity_pods)",
                "format": "time_series",
                "intervalFactor": 2,
                "legendFormat": "Maximum node capacity of pods",
                "refId": "B"
              }
            ],
            "thresholds": [],
            "timeFrom": null,
            "timeRegions": [],
            "timeShift": null,
            "title": "Cluster pod utilization",
            "tooltip": {
              "shared": true,
              "sort": 0,
              "value_type": "individual"
            },
            "type": "graph",
            "xaxis": {
              "buckets": null,
              "mode": "time",
              "name": null,
              "show": true,
              "values": []
            },
            "yaxes": [
              {
                "format": "short",
                "label": null,
                "logBase": 1,
                "max": null,
                "min": null,
                "show": true
              },
              {
                "format": "short",
                "label": null,
                "logBase": 1,
                "max": null,
                "min": null,
                "show": true
              }
            ],
            "yaxis": {
              "align": false,
              "alignLevel": null
            }
          },
          {
            "columns": [],
            "datasource": "$datasource",
            "fontSize": "90%",
            "gridPos": {
              "h": 6,
              "w": 5,
              "x": 14,
              "y": 0
            },
            "id": 19,
            "links": [],
            "pageSize": 10,
            "scroll": true,
            "showHeader": true,
            "sort": {
              "col": 0,
              "desc": true
            },
            "styles": [
              {
                "alias": "",
                "colorMode": null,
                "colors": [
                  "rgba(245, 54, 54, 0.9)",
                  "rgba(237, 129, 40, 0.89)",
                  "rgba(50, 172, 45, 0.97)"
                ],
                "dateFormat": "YYYY-MM-DD HH:mm:ss",
                "decimals": 2,
                "mappingType": 1,
                "pattern": "Time",
                "thresholds": [],
                "type": "date",
                "unit": "short"
              },
              {
                "alias": "",
                "colorMode": "row",
                "colors": [
                  "rgba(245, 54, 54, 0.9)",
                  "#cca300",
                  "rgba(50, 172, 45, 0.97)"
                ],
                "decimals": 2,
                "pattern": "/.*/",
                "thresholds": [
                  "1"
                ],
                "type": "number",
                "unit": "short"
              }
            ],
            "targets": [
              {
                "expr": "sum by (kubernetes_pod_name, value) (delta(kube_pod_container_status_restarts_total[15m]) >0)",
                "format": "table",
                "instant": true,
                "interval": "15m",
                "intervalFactor": 1,
                "legendFormat": "",
                "refId": "A"
              }
            ],
            "title": "Restarted pods",
            "transform": "table",
            "type": "table"
          },
          {
            "aliasColors": {},
            "bars": false,
            "dashLength": 10,
            "dashes": false,
            "datasource": "$datasource",
            "fill": 3,
            "gridPos": {
              "h": 6,
              "w": 5,
              "x": 19,
              "y": 0
            },
            "id": 5,
            "legend": {
              "alignAsTable": true,
              "avg": false,
              "current": true,
              "max": true,
              "min": true,
              "show": false,
              "total": false,
              "values": true
            },
            "lines": true,
            "linewidth": 2,
            "links": [],
            "nullPointMode": "null as zero",
            "percentage": false,
            "pointradius": 5,
            "points": false,
            "renderer": "flot",
            "seriesOverrides": [],
            "spaceLength": 10,
            "stack": false,
            "steppedLine": false,
            "targets": [
              {
                "expr": "sum (kube_pod_status_phase{}) by (phase)",
                "format": "time_series",
                "hide": false,
                "interval": "",
                "intervalFactor": 2,
                "legendFormat": "{{ phase }}",
                "metric": "kube_pod_status_phase",
                "refId": "A",
                "step": 10
              }
            ],
            "thresholds": [],
            "timeFrom": null,
            "timeRegions": [],
            "timeShift": null,
            "title": "Pods Running Count",
            "tooltip": {
              "shared": true,
              "sort": 0,
              "value_type": "individual"
            },
            "type": "graph",
            "xaxis": {
              "buckets": null,
              "mode": "time",
              "name": null,
              "show": true,
              "values": []
            },
            "yaxes": [
              {
                "format": "short",
                "label": null,
                "logBase": 1,
                "max": null,
                "min": "0",
                "show": true
              },
              {
                "format": "short",
                "label": null,
                "logBase": 1,
                "max": null,
                "min": null,
                "show": true
              }
            ],
            "yaxis": {
              "align": false,
              "alignLevel": null
            }
          },
          {
            "aliasColors": {},
            "bars": false,
            "dashLength": 10,
            "dashes": false,
            "datasource": "$datasource",
            "editable": true,
            "error": false,
            "fill": 1,
            "grid": {
              "threshold1Color": "rgba(216, 200, 27, 0.27)",
              "threshold2Color": "rgba(234, 112, 112, 0.22)"
            },
            "gridPos": {
              "h": 6,
              "w": 10,
              "x": 0,
              "y": 6
            },
            "id": 17,
            "isNew": false,
            "legend": {
              "alignAsTable": false,
              "avg": true,
              "current": false,
              "hideEmpty": false,
              "hideZero": false,
              "max": false,
              "min": false,
              "rightSide": false,
              "show": true,
              "total": false,
              "values": true
            },
            "lines": true,
            "linewidth": 2,
            "links": [],
            "nullPointMode": "connected",
            "percentage": false,
            "pointradius": 5,
            "points": false,
            "renderer": "flot",
            "seriesOverrides": [
              {
                "alias": "read",
                "yaxis": 1
              },
              {
                "alias": "io_time",
                "yaxis": 2
              },
              {
                "alias": "written",
                "yaxis": 1
              }
            ],
            "spaceLength": 10,
            "stack": false,
            "steppedLine": false,
            "targets": [
              {
                "expr": "sum(rate(node_disk_read_bytes_total[5m]))",
                "format": "time_series",
                "hide": false,
                "interval": "15s",
                "intervalFactor": 4,
                "legendFormat": "read",
                "refId": "A",
                "step": 20,
                "target": ""
              },
              {
                "expr": "sum(rate(node_disk_written_bytes_total[5m]))",
                "format": "time_series",
                "interval": "15s",
                "intervalFactor": 4,
                "legendFormat": "written",
                "refId": "B",
                "step": 20
              },
              {
                "expr": "sum(rate(node_disk_io_time_seconds_total[5m]))",
                "format": "time_series",
                "instant": false,
                "interval": "15s",
                "intervalFactor": 4,
                "legendFormat": "io_time",
                "refId": "C"
              }
            ],
            "thresholds": [],
            "timeFrom": null,
            "timeRegions": [],
            "timeShift": null,
            "title": "Average disk I/O",
            "tooltip": {
              "msResolution": false,
              "shared": true,
              "sort": 0,
              "value_type": "cumulative"
            },
            "type": "graph",
            "xaxis": {
              "buckets": null,
              "mode": "time",
              "name": null,
              "show": true,
              "values": []
            },
            "yaxes": [
              {
                "format": "bytes",
                "logBase": 1,
                "show": true
              },
              {
                "format": "ms",
                "logBase": 1,
                "show": true
              }
            ],
            "yaxis": {
              "align": false,
              "alignLevel": null
            }
          },
          {
            "aliasColors": {},
            "bars": false,
            "dashLength": 10,
            "dashes": false,
            "datasource": "$datasource",
            "fill": 1,
            "gridPos": {
              "h": 6,
              "w": 7,
              "x": 10,
              "y": 6
            },
            "id": 23,
            "legend": {
              "avg": false,
              "current": false,
              "max": false,
              "min": false,
              "show": false,
              "total": false,
              "values": false
            },
            "lines": true,
            "linewidth": 1,
            "links": [],
            "nullPointMode": "null",
            "percentage": false,
            "pointradius": 5,
            "points": false,
            "renderer": "flot",
            "seriesOverrides": [],
            "spaceLength": 10,
            "stack": false,
            "steppedLine": false,
            "targets": [
              {
                "expr": "sum(rate(node_network_receive_bytes_total{device!~\"lo\"}[5m]))",
                "format": "time_series",
                "intervalFactor": 3,
                "legendFormat": "received",
                "refId": "A"
              }
            ],
            "thresholds": [],
            "timeFrom": null,
            "timeRegions": [],
            "timeShift": null,
            "title": "Average network traffic received",
            "tooltip": {
              "shared": true,
              "sort": 0,
              "value_type": "individual"
            },
            "type": "graph",
            "xaxis": {
              "buckets": null,
              "mode": "time",
              "name": null,
              "show": true,
              "values": []
            },
            "yaxes": [
              {
                "format": "decbytes",
                "label": null,
                "logBase": 1,
                "max": null,
                "min": null,
                "show": true
              },
              {
                "format": "decbytes",
                "label": null,
                "logBase": 1,
                "max": null,
                "min": null,
                "show": true
              }
            ],
            "yaxis": {
              "align": false,
              "alignLevel": null
            }
          },
          {
            "aliasColors": {},
            "bars": false,
            "dashLength": 10,
            "dashes": false,
            "datasource": "$datasource",
            "fill": 1,
            "gridPos": {
              "h": 6,
              "w": 7,
              "x": 17,
              "y": 6
            },
            "id": 25,
            "legend": {
              "avg": false,
              "current": false,
              "max": false,
              "min": false,
              "show": false,
              "total": false,
              "values": false
            },
            "lines": true,
            "linewidth": 1,
            "links": [],
            "nullPointMode": "null",
            "percentage": false,
            "pointradius": 5,
            "points": false,
            "renderer": "flot",
            "seriesOverrides": [],
            "spaceLength": 10,
            "stack": false,
            "steppedLine": false,
            "targets": [
              {
                "expr": "sum(rate(node_network_transmit_bytes_total{device!~\"lo\"}[5m]))",
                "format": "time_series",
                "intervalFactor": 3,
                "legendFormat": "transmitted",
                "refId": "A"
              }
            ],
            "thresholds": [],
            "timeFrom": null,
            "timeRegions": [],
            "timeShift": null,
            "title": "Average network traffic transmitted",
            "tooltip": {
              "shared": true,
              "sort": 0,
              "value_type": "individual"
            },
            "type": "graph",
            "xaxis": {
              "buckets": null,
              "mode": "time",
              "name": null,
              "show": true,
              "values": []
            },
            "yaxes": [
              {
                "format": "bytes",
                "label": null,
                "logBase": 1,
                "max": null,
                "min": null,
                "show": true
              },
              {
                "format": "bytes",
                "label": null,
                "logBase": 1,
                "max": null,
                "min": null,
                "show": true
              }
            ],
            "yaxis": {
              "align": false,
              "alignLevel": null
            }
          },
          {
            "aliasColors": {},
            "bars": false,
            "dashLength": 10,
            "dashes": false,
            "datasource": "$datasource",
            "description": "some ref: https://blog.freshtracks.io/a-deep-dive-into-kubernetes-metrics-part-2-c869581e9f29",
            "editable": true,
            "error": false,
            "fill": 1,
            "grid": {
              "threshold1Color": "rgba(216, 200, 27, 0.27)",
              "threshold2Color": "rgba(234, 112, 112, 0.22)"
            },
            "gridPos": {
              "h": 6,
              "w": 12,
              "x": 0,
              "y": 12
            },
            "id": 3,
            "isNew": false,
            "legend": {
              "alignAsTable": false,
              "avg": false,
              "current": false,
              "hideEmpty": false,
              "hideZero": false,
              "max": false,
              "min": false,
              "rightSide": false,
              "show": true,
              "total": false,
              "values": false
            },
            "lines": true,
            "linewidth": 2,
            "links": [],
            "nullPointMode": "connected",
            "percentage": false,
            "pointradius": 5,
            "points": false,
            "renderer": "flot",
            "seriesOverrides": [],
            "spaceLength": 10,
            "stack": false,
            "steppedLine": false,
            "targets": [
              {
                "expr": "sum(node_load1) by (node) / count(node_cpu_seconds_total{mode=\"system\"}) by (node)",
                "format": "time_series",
                "hide": false,
                "intervalFactor": 2,
                "legendFormat": "load 1m",
                "refId": "A",
                "step": 20,
                "target": ""
              },
              {
                "expr": "sum(node_load5) by (node) / count(node_cpu_seconds_total{mode=\"system\"}) by (node)",
                "format": "time_series",
                "hide": false,
                "intervalFactor": 4,
                "legendFormat": "load 5m",
                "refId": "B",
                "step": 20,
                "target": ""
              },
              {
                "expr": "sum(node_load15) by (node) / count(node_cpu_seconds_total{mode=\"system\"}) by (node)",
                "format": "time_series",
                "hide": false,
                "intervalFactor": 4,
                "legendFormat": "load 15m",
                "refId": "C",
                "step": 20,
                "target": ""
              }
            ],
            "thresholds": [],
            "timeFrom": null,
            "timeRegions": [],
            "timeShift": null,
            "title": "Average cluster system load",
            "tooltip": {
              "msResolution": false,
              "shared": true,
              "sort": 0,
              "value_type": "cumulative"
            },
            "type": "graph",
            "xaxis": {
              "buckets": null,
              "mode": "time",
              "name": null,
              "show": true,
              "values": []
            },
            "yaxes": [
              {
                "format": "percentunit",
                "logBase": 1,
                "show": true
              },
              {
                "format": "short",
                "logBase": 1,
                "show": true
              }
            ],
            "yaxis": {
              "align": false,
              "alignLevel": null
            }
          },
          {
            "aliasColors": {},
            "bars": false,
            "dashLength": 10,
            "dashes": false,
            "datasource": "$datasource",
            "description": "This represents the total [memory resource requests](https://kubernetes.io/docs/concepts/configuration/manage-compute-resources-container/#meaning-of-memory) in the cluster.\nFor comparison the total [allocatable memory](https://github.com/kubernetes/community/blob/master/contributors/design-proposals/node-allocatable.md) is also shown.",
            "editable": true,
            "error": false,
            "fill": 1,
            "grid": {
              "threshold1Color": "rgba(216, 200, 27, 0.27)",
              "threshold2Color": "rgba(234, 112, 112, 0.22)"
            },
            "gridPos": {
              "h": 6,
              "w": 12,
              "x": 12,
              "y": 12
            },
            "id": 7,
            "isNew": false,
            "legend": {
              "alignAsTable": false,
              "avg": false,
              "current": false,
              "hideEmpty": false,
              "hideZero": false,
              "max": false,
              "min": false,
              "rightSide": false,
              "show": true,
              "total": false,
              "values": false
            },
            "lines": true,
            "linewidth": 3,
            "links": [],
            "nullPointMode": "null",
            "percentage": false,
            "pointradius": 5,
            "points": false,
            "renderer": "flot",
            "seriesOverrides": [],
            "spaceLength": 10,
            "stack": false,
            "steppedLine": false,
            "targets": [
              {
                "expr": "min(sum(kube_node_status_allocatable_memory_bytes) by (instance))",
                "format": "time_series",
                "hide": false,
                "intervalFactor": 1,
                "legendFormat": "Allocatable",
                "refId": "A",
                "step": 20
              },
              {
                "expr": "max(sum(kube_pod_container_resource_requests_memory_bytes) by (instance))",
                "format": "time_series",
                "hide": false,
                "intervalFactor": 1,
                "legendFormat": "Requested",
                "refId": "B",
                "step": 20
              },
              {
                "expr": "max(sum(kube_pod_container_resource_limits_memory_bytes) by (instance))",
                "format": "time_series",
                "hide": true,
                "intervalFactor": 1,
                "legendFormat": "Limit",
                "refId": "C"
              },
              {
                "expr": "sum(node_memory_MemTotal_bytes) - sum(node_memory_MemFree_bytes) - sum(node_memory_Buffers_bytes) - sum(node_memory_Cached_bytes)",
                "format": "time_series",
                "intervalFactor": 1,
                "legendFormat": "Usage",
                "refId": "D"
              }
            ],
            "thresholds": [],
            "timeFrom": null,
            "timeRegions": [],
            "timeShift": null,
            "title": "Cluster memory",
            "tooltip": {
              "msResolution": false,
              "shared": true,
              "sort": 0,
              "value_type": "individual"
            },
            "type": "graph",
            "xaxis": {
              "buckets": null,
              "mode": "time",
              "name": null,
              "show": true,
              "values": []
            },
            "yaxes": [
              {
                "format": "bytes",
                "label": "Memory",
                "logBase": 1,
                "max": null,
                "min": "0",
                "show": true
              },
              {
                "format": "short",
                "logBase": 1,
                "show": true
              }
            ],
            "yaxis": {
              "align": false,
              "alignLevel": null
            }
          },
          {
            "aliasColors": {},
            "bars": false,
            "dashLength": 10,
            "dashes": false,
            "datasource": "$datasource",
            "fill": 1,
            "gridPos": {
              "h": 6,
              "w": 9,
              "x": 0,
              "y": 18
            },
            "height": "300px",
            "id": 10,
            "legend": {
              "alignAsTable": true,
              "avg": false,
              "current": true,
              "max": false,
              "min": false,
              "show": true,
              "total": false,
              "values": true
            },
            "lines": true,
            "linewidth": 1,
            "links": [],
            "nullPointMode": "null",
            "percentage": false,
            "pointradius": 5,
            "points": false,
            "renderer": "flot",
            "seriesOverrides": [],
            "spaceLength": 10,
            "stack": false,
            "steppedLine": false,
            "targets": [
              {
                "expr": "topk(5,sum(container_memory_usage_bytes{image!=\"\"}) by (pod))",
                "format": "time_series",
                "intervalFactor": 2,
                "legendFormat": "{{pod}}",
                "refId": "A",
                "step": 10
              }
            ],
            "thresholds": [],
            "timeFrom": null,
            "timeRegions": [],
            "timeShift": null,
            "title": "Top 5 Memory Intense Pods",
            "tooltip": {
              "shared": true,
              "sort": 0,
              "value_type": "individual"
            },
            "type": "graph",
            "xaxis": {
              "buckets": null,
              "mode": "time",
              "name": null,
              "show": true,
              "values": []
            },
            "yaxes": [
              {
                "format": "bytes",
                "label": null,
                "logBase": 1,
                "max": null,
                "min": null,
                "show": true
              },
              {
                "format": "short",
                "label": null,
                "logBase": 1,
                "max": null,
                "min": null,
                "show": true
              }
            ],
            "yaxis": {
              "align": false,
              "alignLevel": null
            }
          },
          {
            "aliasColors": {},
            "bars": false,
            "dashLength": 10,
            "dashes": false,
            "datasource": "$datasource",
            "fill": 0,
            "gridPos": {
              "h": 6,
              "w": 15,
              "x": 9,
              "y": 18
            },
            "height": "230px",
            "id": 6,
            "legend": {
              "alignAsTable": true,
              "avg": false,
              "current": false,
              "hideEmpty": false,
              "max": true,
              "min": true,
              "rightSide": true,
              "show": true,
              "total": false,
              "values": true
            },
            "lines": true,
            "linewidth": 1,
            "links": [],
            "nullPointMode": "null",
            "percentage": false,
            "pointradius": 5,
            "points": false,
            "renderer": "flot",
            "seriesOverrides": [],
            "spaceLength": 10,
            "stack": false,
            "steppedLine": false,
            "targets": [
              {
                "expr": "topk(5, sum(rate(container_cpu_usage_seconds_total{image!=\"\",name=~\"^k8s_.*\",container!=\"POD\"}[2m])) by (pod, container))",
                "format": "time_series",
                "interval": "",
                "intervalFactor": 2,
                "legendFormat": "{{ container }} in {{ pod }}",
                "metric": "container_cpu_usage_seconds_total",
                "refId": "A",
                "step": 4
              }
            ],
            "thresholds": [],
            "timeFrom": null,
            "timeRegions": [],
            "timeShift": null,
            "title": "TOP CPU Containers",
            "tooltip": {
              "shared": true,
              "sort": 0,
              "value_type": "individual"
            },
            "type": "graph",
            "xaxis": {
              "buckets": null,
              "mode": "time",
              "name": null,
              "show": true,
              "values": []
            },
            "yaxes": [
              {
                "format": "short",
                "label": null,
                "logBase": 1,
                "max": null,
                "min": null,
                "show": true
              },
              {
                "format": "short",
                "label": null,
                "logBase": 1,
                "max": null,
                "min": null,
                "show": true
              }
            ],
            "yaxis": {
              "align": false,
              "alignLevel": null
            }
          }
        ],
        "refresh": "30s",
        "schemaVersion": 16,
        "style": "dark",
        "tags": [
          "kubernetes",
          "capacity"
        ],
        "templating": {
          "list": [
            {
              "hide": 0,
              "label": null,
              "name": "datasource",
              "options": [],
              "query": "prometheus",
              "refresh": 1,
              "regex": "",
              "skipUrlSync": false,
              "type": "datasource"
            }
          ]
        },
        "time": {
          "from": "now-30m",
          "to": "now"
        },
        "timepicker": {
          "refresh_intervals": [
            "5s",
            "10s",
            "30s",
            "1m",
            "5m",
            "15m",
            "30m",
            "1h",
            "2h",
            "1d"
          ],
          "time_options": [
            "5m",
            "15m",
            "1h",
            "6h",
            "12h",
            "24h",
            "2d",
            "7d",
            "30d"
          ]
        },
        "timezone": "",
        "title": "Kubernetes cluster capacity",
        "uid": "os6Bh8Omk",
        "version": 4
      }
  k8s_cluster_workloads_summary.json: |-
    {
      "annotations": {
        "list": [
          {
            "builtIn": 1,
            "datasource": "-- Grafana --",
            "enable": true,
            "hide": true,
            "iconColor": "rgba(0, 211, 255, 1)",
            "name": "Annotations & Alerts",
            "type": "dashboard"
          }
        ]
      },
      "description": "Summary metrics about Kubernetes workloads",
      "editable": true,
      "gnetId": 8685,
      "graphTooltip": 1,
      "id": 459727,
      "iteration": 1555712638716,
      "links": [
        {
          "asDropdown": true,
          "icon": "external link",
          "includeVars": true,
          "keepTime": false,
          "tags": [
            "kubernetes"
          ],
          "title": "Dashboards",
          "type": "dashboards"
        }
      ],
      "panels": [
        {
          "collapsed": false,
          "gridPos": {
            "h": 1,
            "w": 24,
            "x": 0,
            "y": 0
          },
          "id": 14,
          "panels": [],
          "title": "Deployments",
          "type": "row"
        },
        {
          "columns": [
            {
              "text": "Current",
              "value": "current"
            }
          ],
          "datasource": "$datasource",
          "fontSize": "100%",
          "gridPos": {
            "h": 5,
            "w": 6,
            "x": 0,
            "y": 1
          },
          "id": 16,
          "links": [],
          "pageSize": null,
          "scroll": true,
          "showHeader": true,
          "sort": {
            "col": 1,
            "desc": true
          },
          "styles": [
            {
              "alias": "Time",
              "dateFormat": "YYYY-MM-DD HH:mm:ss",
              "pattern": "Time",
              "type": "date"
            },
            {
              "alias": "",
              "colorMode": "row",
              "colors": [
                "rgba(245, 54, 54, 0.9)",
                "rgba(237, 129, 40, 0.89)",
                "rgba(50, 172, 45, 0.97)"
              ],
              "decimals": 0,
              "pattern": "Metric",
              "thresholds": [
                "0",
                "0",
                ".9"
              ],
              "type": "string",
              "unit": "none"
            },
            {
              "alias": "",
              "colorMode": "row",
              "colors": [
                "rgba(245, 54, 54, 0.9)",
                "rgba(237, 129, 40, 0.89)",
                "rgba(50, 172, 45, 0.97)"
              ],
              "dateFormat": "YYYY-MM-DD HH:mm:ss",
              "decimals": 0,
              "link": false,
              "pattern": "Value",
              "thresholds": [
                "0",
                "1"
              ],
              "type": "number",
              "unit": "none"
            }
          ],
          "targets": [
            {
              "expr": "kube_deployment_status_replicas{namespace=~\"$namespace\"}",
              "format": "time_series",
              "instant": true,
              "interval": "",
              "intervalFactor": 1,
              "legendFormat": "{{ deployment }}",
              "refId": "A"
            }
          ],
          "title": "Deployment Replicas - Up To Date",
          "transform": "timeseries_to_rows",
          "type": "table"
        },
        {
          "cacheTimeout": null,
          "colorBackground": false,
          "colorValue": false,
          "colors": [
            "#299c46",
            "rgba(237, 129, 40, 0.89)",
            "#d44a3a"
          ],
          "datasource": "$datasource",
          "format": "none",
          "gauge": {
            "maxValue": 100,
            "minValue": 0,
            "show": false,
            "thresholdLabels": false,
            "thresholdMarkers": true
          },
          "gridPos": {
            "h": 5,
            "w": 6,
            "x": 6,
            "y": 1
          },
          "id": 18,
          "interval": null,
          "links": [],
          "mappingType": 1,
          "mappingTypes": [
            {
              "name": "value to text",
              "value": 1
            },
            {
              "name": "range to text",
              "value": 2
            }
          ],
          "maxDataPoints": 100,
          "nullPointMode": "connected",
          "nullText": null,
          "postfix": "",
          "postfixFontSize": "50%",
          "prefix": "",
          "prefixFontSize": "50%",
          "rangeMaps": [
            {
              "from": "null",
              "text": "N/A",
              "to": "null"
            }
          ],
          "sparkline": {
            "fillColor": "rgba(31, 118, 189, 0.18)",
            "full": false,
            "lineColor": "rgb(31, 120, 193)",
            "show": false
          },
          "tableColumn": "",
          "targets": [
            {
              "expr": "sum(kube_deployment_status_replicas{namespace=~\"$namespace\"})",
              "format": "time_series",
              "intervalFactor": 1,
              "refId": "A"
            }
          ],
          "thresholds": "",
          "title": "Deployment Replicas",
          "type": "singlestat",
          "valueFontSize": "80%",
          "valueMaps": [
            {
              "op": "=",
              "text": "N/A",
              "value": "null"
            }
          ],
          "valueName": "avg"
        },
        {
          "cacheTimeout": null,
          "colorBackground": false,
          "colorValue": false,
          "colors": [
            "#299c46",
            "rgba(237, 129, 40, 0.89)",
            "#d44a3a"
          ],
          "datasource": "$datasource",
          "format": "none",
          "gauge": {
            "maxValue": 100,
            "minValue": 0,
            "show": false,
            "thresholdLabels": false,
            "thresholdMarkers": true
          },
          "gridPos": {
            "h": 5,
            "w": 6,
            "x": 12,
            "y": 1
          },
          "id": 19,
          "interval": null,
          "links": [],
          "mappingType": 1,
          "mappingTypes": [
            {
              "name": "value to text",
              "value": 1
            },
            {
              "name": "range to text",
              "value": 2
            }
          ],
          "maxDataPoints": 100,
          "nullPointMode": "connected",
          "nullText": null,
          "postfix": "",
          "postfixFontSize": "50%",
          "prefix": "",
          "prefixFontSize": "50%",
          "rangeMaps": [
            {
              "from": "null",
              "text": "N/A",
              "to": "null"
            }
          ],
          "sparkline": {
            "fillColor": "rgba(31, 118, 189, 0.18)",
            "full": false,
            "lineColor": "rgb(31, 120, 193)",
            "show": false
          },
          "tableColumn": "",
          "targets": [
            {
              "expr": "sum(kube_deployment_status_replicas_updated{namespace=~\"$namespace\"})",
              "format": "time_series",
              "intervalFactor": 1,
              "refId": "A"
            }
          ],
          "thresholds": "",
          "title": "Deployment Replicas - Updated",
          "type": "singlestat",
          "valueFontSize": "80%",
          "valueMaps": [
            {
              "op": "=",
              "text": "N/A",
              "value": "null"
            }
          ],
          "valueName": "avg"
        },
        {
          "cacheTimeout": null,
          "colorBackground": false,
          "colorValue": false,
          "colors": [
            "#299c46",
            "rgba(237, 129, 40, 0.89)",
            "#d44a3a"
          ],
          "datasource": "$datasource",
          "format": "none",
          "gauge": {
            "maxValue": 100,
            "minValue": 0,
            "show": false,
            "thresholdLabels": false,
            "thresholdMarkers": true
          },
          "gridPos": {
            "h": 5,
            "w": 6,
            "x": 18,
            "y": 1
          },
          "id": 20,
          "interval": null,
          "links": [],
          "mappingType": 1,
          "mappingTypes": [
            {
              "name": "value to text",
              "value": 1
            },
            {
              "name": "range to text",
              "value": 2
            }
          ],
          "maxDataPoints": 100,
          "nullPointMode": "connected",
          "nullText": null,
          "postfix": "",
          "postfixFontSize": "50%",
          "prefix": "",
          "prefixFontSize": "50%",
          "rangeMaps": [
            {
              "from": "null",
              "text": "N/A",
              "to": "null"
            }
          ],
          "sparkline": {
            "fillColor": "rgba(31, 118, 189, 0.18)",
            "full": false,
            "lineColor": "rgb(31, 120, 193)",
            "show": false
          },
          "tableColumn": "",
          "targets": [
            {
              "expr": "sum(kube_deployment_status_replicas_unavailable{namespace=~\"$namespace\"})",
              "format": "time_series",
              "intervalFactor": 1,
              "refId": "A"
            }
          ],
          "thresholds": "",
          "title": "Deployment Replicas - Unavailable",
          "type": "singlestat",
          "valueFontSize": "80%",
          "valueMaps": [
            {
              "op": "=",
              "text": "N/A",
              "value": "null"
            }
          ],
          "valueName": "avg"
        },
        {
          "collapsed": false,
          "gridPos": {
            "h": 1,
            "w": 24,
            "x": 0,
            "y": 6
          },
          "id": 22,
          "panels": [],
          "title": "Node",
          "type": "row"
        },
        {
          "cacheTimeout": null,
          "colorBackground": false,
          "colorValue": false,
          "colors": [
            "#299c46",
            "rgba(237, 129, 40, 0.89)",
            "#d44a3a"
          ],
          "datasource": "$datasource",
          "format": "none",
          "gauge": {
            "maxValue": 100,
            "minValue": 0,
            "show": false,
            "thresholdLabels": false,
            "thresholdMarkers": true
          },
          "gridPos": {
            "h": 3,
            "w": 8,
            "x": 0,
            "y": 7
          },
          "id": 24,
          "interval": null,
          "links": [],
          "mappingType": 1,
          "mappingTypes": [
            {
              "name": "value to text",
              "value": 1
            },
            {
              "name": "range to text",
              "value": 2
            }
          ],
          "maxDataPoints": 100,
          "nullPointMode": "connected",
          "nullText": null,
          "postfix": "",
          "postfixFontSize": "50%",
          "prefix": "",
          "prefixFontSize": "50%",
          "rangeMaps": [
            {
              "from": "null",
              "text": "N/A",
              "to": "null"
            }
          ],
          "sparkline": {
            "fillColor": "rgba(31, 118, 189, 0.18)",
            "full": false,
            "lineColor": "rgb(31, 120, 193)",
            "show": false
          },
          "tableColumn": "",
          "targets": [
            {
              "expr": "sum(kube_node_info)",
              "format": "time_series",
              "intervalFactor": 1,
              "refId": "A"
            }
          ],
          "thresholds": "",
          "title": "Number Of Nodes",
          "type": "singlestat",
          "valueFontSize": "80%",
          "valueMaps": [
            {
              "op": "=",
              "text": "N/A",
              "value": "null"
            }
          ],
          "valueName": "avg"
        },
        {
          "cacheTimeout": null,
          "colorBackground": true,
          "colorValue": false,
          "colors": [
            "#299c46",
            "rgba(237, 129, 40, 0.89)",
            "#d44a3a"
          ],
          "datasource": "$datasource",
          "format": "none",
          "gauge": {
            "maxValue": 100,
            "minValue": 0,
            "show": false,
            "thresholdLabels": false,
            "thresholdMarkers": true
          },
          "gridPos": {
            "h": 3,
            "w": 8,
            "x": 8,
            "y": 7
          },
          "id": 25,
          "interval": null,
          "links": [],
          "mappingType": 1,
          "mappingTypes": [
            {
              "name": "value to text",
              "value": 1
            },
            {
              "name": "range to text",
              "value": 2
            }
          ],
          "maxDataPoints": 100,
          "nullPointMode": "connected",
          "nullText": null,
          "postfix": "",
          "postfixFontSize": "50%",
          "prefix": "",
          "prefixFontSize": "50%",
          "rangeMaps": [
            {
              "from": "null",
              "text": "N/A",
              "to": "null"
            }
          ],
          "sparkline": {
            "fillColor": "rgba(31, 118, 189, 0.18)",
            "full": false,
            "lineColor": "rgb(31, 120, 193)",
            "show": false
          },
          "tableColumn": "",
          "targets": [
            {
              "expr": "sum(kube_node_status_condition{condition=\"OutOfDisk\", status=\"true\"})",
              "format": "time_series",
              "intervalFactor": 1,
              "refId": "A"
            }
          ],
          "thresholds": "1",
          "title": "Nodes Out of Disk",
          "type": "singlestat",
          "valueFontSize": "80%",
          "valueMaps": [
            {
              "op": "=",
              "text": "N/A",
              "value": "null"
            }
          ],
          "valueName": "current"
        },
        {
          "cacheTimeout": null,
          "colorBackground": true,
          "colorValue": false,
          "colors": [
            "#299c46",
            "rgba(237, 129, 40, 0.89)",
            "#d44a3a"
          ],
          "datasource": "$datasource",
          "format": "none",
          "gauge": {
            "maxValue": 100,
            "minValue": 0,
            "show": false,
            "thresholdLabels": false,
            "thresholdMarkers": true
          },
          "gridPos": {
            "h": 3,
            "w": 8,
            "x": 16,
            "y": 7
          },
          "id": 26,
          "interval": null,
          "links": [],
          "mappingType": 1,
          "mappingTypes": [
            {
              "name": "value to text",
              "value": 1
            },
            {
              "name": "range to text",
              "value": 2
            }
          ],
          "maxDataPoints": 100,
          "nullPointMode": "connected",
          "nullText": null,
          "postfix": "",
          "postfixFontSize": "50%",
          "prefix": "",
          "prefixFontSize": "50%",
          "rangeMaps": [
            {
              "from": "null",
              "text": "N/A",
              "to": "null"
            }
          ],
          "sparkline": {
            "fillColor": "rgba(31, 118, 189, 0.18)",
            "full": false,
            "lineColor": "rgb(31, 120, 193)",
            "show": false
          },
          "tableColumn": "",
          "targets": [
            {
              "expr": "sum(kube_node_spec_unschedulable)",
              "format": "time_series",
              "intervalFactor": 1,
              "refId": "A"
            }
          ],
          "thresholds": "1",
          "title": "Nodes Unavailable",
          "type": "singlestat",
          "valueFontSize": "80%",
          "valueMaps": [
            {
              "op": "=",
              "text": "N/A",
              "value": "null"
            }
          ],
          "valueName": "current"
        },
        {
          "collapsed": false,
          "gridPos": {
            "h": 1,
            "w": 24,
            "x": 0,
            "y": 10
          },
          "id": 28,
          "panels": [],
          "title": "Pods",
          "type": "row"
        },
        {
          "cacheTimeout": null,
          "colorBackground": false,
          "colorValue": false,
          "colors": [
            "#299c46",
            "rgba(237, 129, 40, 0.89)",
            "#d44a3a"
          ],
          "datasource": "$datasource",
          "format": "none",
          "gauge": {
            "maxValue": 100,
            "minValue": 0,
            "show": false,
            "thresholdLabels": false,
            "thresholdMarkers": true
          },
          "gridPos": {
            "h": 3,
            "w": 12,
            "x": 0,
            "y": 11
          },
          "id": 30,
          "interval": null,
          "links": [],
          "mappingType": 1,
          "mappingTypes": [
            {
              "name": "value to text",
              "value": 1
            },
            {
              "name": "range to text",
              "value": 2
            }
          ],
          "maxDataPoints": 100,
          "nullPointMode": "connected",
          "nullText": null,
          "postfix": "",
          "postfixFontSize": "50%",
          "prefix": "",
          "prefixFontSize": "50%",
          "rangeMaps": [
            {
              "from": "null",
              "text": "N/A",
              "to": "null"
            }
          ],
          "sparkline": {
            "fillColor": "rgba(78, 203, 42, 0.28)",
            "full": false,
            "lineColor": "#629e51",
            "show": true
          },
          "tableColumn": "",
          "targets": [
            {
              "expr": "sum(kube_pod_status_phase{namespace=~\"$namespace\", phase=\"Running\"})",
              "format": "time_series",
              "interval": "",
              "intervalFactor": 1,
              "refId": "A"
            }
          ],
          "thresholds": "",
          "title": "Pods Running",
          "type": "singlestat",
          "valueFontSize": "80%",
          "valueMaps": [
            {
              "op": "=",
              "text": "N/A",
              "value": "null"
            }
          ],
          "valueName": "current"
        },
        {
          "cacheTimeout": null,
          "colorBackground": false,
          "colorValue": false,
          "colors": [
            "#299c46",
            "rgba(237, 129, 40, 0.89)",
            "#d44a3a"
          ],
          "datasource": "$datasource",
          "format": "none",
          "gauge": {
            "maxValue": 100,
            "minValue": 0,
            "show": false,
            "thresholdLabels": false,
            "thresholdMarkers": true
          },
          "gridPos": {
            "h": 3,
            "w": 12,
            "x": 12,
            "y": 11
          },
          "id": 31,
          "interval": null,
          "links": [],
          "mappingType": 1,
          "mappingTypes": [
            {
              "name": "value to text",
              "value": 1
            },
            {
              "name": "range to text",
              "value": 2
            }
          ],
          "maxDataPoints": 100,
          "nullPointMode": "connected",
          "nullText": null,
          "postfix": "",
          "postfixFontSize": "50%",
          "prefix": "",
          "prefixFontSize": "50%",
          "rangeMaps": [
            {
              "from": "null",
              "text": "N/A",
              "to": "null"
            }
          ],
          "sparkline": {
            "fillColor": "rgba(78, 203, 42, 0.28)",
            "full": false,
            "lineColor": "#629e51",
            "show": true
          },
          "tableColumn": "",
          "targets": [
            {
              "expr": "sum(kube_pod_status_phase{namespace=~\"$namespace\", phase=\"Pending\"})",
              "format": "time_series",
              "interval": "",
              "intervalFactor": 1,
              "refId": "A"
            }
          ],
          "thresholds": "",
          "title": "Pods Pending",
          "type": "singlestat",
          "valueFontSize": "80%",
          "valueMaps": [
            {
              "op": "=",
              "text": "N/A",
              "value": "null"
            }
          ],
          "valueName": "current"
        },
        {
          "cacheTimeout": null,
          "colorBackground": false,
          "colorValue": false,
          "colors": [
            "#299c46",
            "rgba(237, 129, 40, 0.89)",
            "#d44a3a"
          ],
          "datasource": "$datasource",
          "format": "none",
          "gauge": {
            "maxValue": 100,
            "minValue": 0,
            "show": false,
            "thresholdLabels": false,
            "thresholdMarkers": true
          },
          "gridPos": {
            "h": 3,
            "w": 8,
            "x": 0,
            "y": 14
          },
          "id": 32,
          "interval": null,
          "links": [],
          "mappingType": 1,
          "mappingTypes": [
            {
              "name": "value to text",
              "value": 1
            },
            {
              "name": "range to text",
              "value": 2
            }
          ],
          "maxDataPoints": 100,
          "nullPointMode": "connected",
          "nullText": null,
          "postfix": "",
          "postfixFontSize": "50%",
          "prefix": "",
          "prefixFontSize": "50%",
          "rangeMaps": [
            {
              "from": "null",
              "text": "N/A",
              "to": "null"
            }
          ],
          "sparkline": {
            "fillColor": "rgba(78, 203, 42, 0.28)",
            "full": false,
            "lineColor": "#629e51",
            "show": true
          },
          "tableColumn": "",
          "targets": [
            {
              "expr": "sum(kube_pod_status_phase{namespace=~\"$namespace\", phase=\"Failed\"})",
              "format": "time_series",
              "interval": "",
              "intervalFactor": 1,
              "refId": "A"
            }
          ],
          "thresholds": "",
          "title": "Pods Failed",
          "type": "singlestat",
          "valueFontSize": "80%",
          "valueMaps": [
            {
              "op": "=",
              "text": "N/A",
              "value": "null"
            }
          ],
          "valueName": "current"
        },
        {
          "cacheTimeout": null,
          "colorBackground": false,
          "colorValue": false,
          "colors": [
            "#299c46",
            "rgba(237, 129, 40, 0.89)",
            "#d44a3a"
          ],
          "datasource": "$datasource",
          "format": "none",
          "gauge": {
            "maxValue": 100,
            "minValue": 0,
            "show": false,
            "thresholdLabels": false,
            "thresholdMarkers": true
          },
          "gridPos": {
            "h": 3,
            "w": 8,
            "x": 8,
            "y": 14
          },
          "id": 33,
          "interval": null,
          "links": [],
          "mappingType": 1,
          "mappingTypes": [
            {
              "name": "value to text",
              "value": 1
            },
            {
              "name": "range to text",
              "value": 2
            }
          ],
          "maxDataPoints": 100,
          "nullPointMode": "connected",
          "nullText": null,
          "postfix": "",
          "postfixFontSize": "50%",
          "prefix": "",
          "prefixFontSize": "50%",
          "rangeMaps": [
            {
              "from": "null",
              "text": "N/A",
              "to": "null"
            }
          ],
          "sparkline": {
            "fillColor": "rgba(78, 203, 42, 0.28)",
            "full": false,
            "lineColor": "#629e51",
            "show": true
          },
          "tableColumn": "",
          "targets": [
            {
              "expr": "sum(kube_pod_status_phase{namespace=~\"$namespace\", phase=\"Succeeded\"})",
              "format": "time_series",
              "interval": "",
              "intervalFactor": 1,
              "refId": "A"
            }
          ],
          "thresholds": "",
          "title": "Pods Succeeded",
          "type": "singlestat",
          "valueFontSize": "80%",
          "valueMaps": [
            {
              "op": "=",
              "text": "N/A",
              "value": "null"
            }
          ],
          "valueName": "current"
        },
        {
          "cacheTimeout": null,
          "colorBackground": false,
          "colorValue": false,
          "colors": [
            "#299c46",
            "rgba(237, 129, 40, 0.89)",
            "#d44a3a"
          ],
          "datasource": "$datasource",
          "format": "none",
          "gauge": {
            "maxValue": 100,
            "minValue": 0,
            "show": false,
            "thresholdLabels": false,
            "thresholdMarkers": true
          },
          "gridPos": {
            "h": 3,
            "w": 8,
            "x": 16,
            "y": 14
          },
          "id": 34,
          "interval": null,
          "links": [],
          "mappingType": 1,
          "mappingTypes": [
            {
              "name": "value to text",
              "value": 1
            },
            {
              "name": "range to text",
              "value": 2
            }
          ],
          "maxDataPoints": 100,
          "nullPointMode": "connected",
          "nullText": null,
          "postfix": "",
          "postfixFontSize": "50%",
          "prefix": "",
          "prefixFontSize": "50%",
          "rangeMaps": [
            {
              "from": "null",
              "text": "N/A",
              "to": "null"
            }
          ],
          "sparkline": {
            "fillColor": "rgba(78, 203, 42, 0.28)",
            "full": false,
            "lineColor": "#629e51",
            "show": true
          },
          "tableColumn": "",
          "targets": [
            {
              "expr": "sum(kube_pod_status_phase{namespace=~\"$namespace\", phase=\"Unknown\"})",
              "format": "time_series",
              "interval": "",
              "intervalFactor": 1,
              "refId": "A"
            }
          ],
          "thresholds": "",
          "title": "Pods Unknown",
          "type": "singlestat",
          "valueFontSize": "80%",
          "valueMaps": [
            {
              "op": "=",
              "text": "N/A",
              "value": "null"
            }
          ],
          "valueName": "current"
        },
        {
          "collapsed": false,
          "gridPos": {
            "h": 1,
            "w": 24,
            "x": 0,
            "y": 17
          },
          "id": 36,
          "panels": [],
          "title": "Containers",
          "type": "row"
        },
        {
          "cacheTimeout": null,
          "colorBackground": false,
          "colorValue": false,
          "colors": [
            "#299c46",
            "rgba(237, 129, 40, 0.89)",
            "#d44a3a"
          ],
          "datasource": "$datasource",
          "format": "none",
          "gauge": {
            "maxValue": 100,
            "minValue": 0,
            "show": false,
            "thresholdLabels": false,
            "thresholdMarkers": true
          },
          "gridPos": {
            "h": 3,
            "w": 6,
            "x": 0,
            "y": 18
          },
          "id": 38,
          "interval": null,
          "links": [],
          "mappingType": 1,
          "mappingTypes": [
            {
              "name": "value to text",
              "value": 1
            },
            {
              "name": "range to text",
              "value": 2
            }
          ],
          "maxDataPoints": 100,
          "nullPointMode": "connected",
          "nullText": null,
          "postfix": "",
          "postfixFontSize": "50%",
          "prefix": "",
          "prefixFontSize": "50%",
          "rangeMaps": [
            {
              "from": "null",
              "text": "N/A",
              "to": "null"
            }
          ],
          "sparkline": {
            "fillColor": "rgba(31, 118, 189, 0.18)",
            "full": false,
            "lineColor": "rgb(31, 120, 193)",
            "show": true
          },
          "tableColumn": "",
          "targets": [
            {
              "expr": "sum(kube_pod_container_status_running{namespace=~\"$namespace\"})",
              "format": "time_series",
              "intervalFactor": 1,
              "refId": "A"
            }
          ],
          "thresholds": "",
          "title": "Containers Running",
          "type": "singlestat",
          "valueFontSize": "80%",
          "valueMaps": [
            {
              "op": "=",
              "text": "N/A",
              "value": "null"
            }
          ],
          "valueName": "current"
        },
        {
          "cacheTimeout": null,
          "colorBackground": false,
          "colorValue": false,
          "colors": [
            "#299c46",
            "rgba(237, 129, 40, 0.89)",
            "#d44a3a"
          ],
          "datasource": "$datasource",
          "format": "none",
          "gauge": {
            "maxValue": 100,
            "minValue": 0,
            "show": false,
            "thresholdLabels": false,
            "thresholdMarkers": true
          },
          "gridPos": {
            "h": 3,
            "w": 6,
            "x": 6,
            "y": 18
          },
          "id": 39,
          "interval": null,
          "links": [],
          "mappingType": 1,
          "mappingTypes": [
            {
              "name": "value to text",
              "value": 1
            },
            {
              "name": "range to text",
              "value": 2
            }
          ],
          "maxDataPoints": 100,
          "nullPointMode": "connected",
          "nullText": null,
          "postfix": "",
          "postfixFontSize": "50%",
          "prefix": "",
          "prefixFontSize": "50%",
          "rangeMaps": [
            {
              "from": "null",
              "text": "N/A",
              "to": "null"
            }
          ],
          "sparkline": {
            "fillColor": "rgba(31, 118, 189, 0.18)",
            "full": false,
            "lineColor": "rgb(31, 120, 193)",
            "show": true
          },
          "tableColumn": "",
          "targets": [
            {
              "expr": "sum(kube_pod_container_status_waiting{namespace=~\"$namespace\"})",
              "format": "time_series",
              "intervalFactor": 1,
              "refId": "A"
            }
          ],
          "thresholds": "",
          "title": "Containers Waiting",
          "type": "singlestat",
          "valueFontSize": "80%",
          "valueMaps": [
            {
              "op": "=",
              "text": "N/A",
              "value": "null"
            }
          ],
          "valueName": "current"
        },
        {
          "cacheTimeout": null,
          "colorBackground": false,
          "colorValue": false,
          "colors": [
            "#299c46",
            "rgba(237, 129, 40, 0.89)",
            "#d44a3a"
          ],
          "datasource": "$datasource",
          "format": "none",
          "gauge": {
            "maxValue": 100,
            "minValue": 0,
            "show": false,
            "thresholdLabels": false,
            "thresholdMarkers": true
          },
          "gridPos": {
            "h": 3,
            "w": 6,
            "x": 12,
            "y": 18
          },
          "id": 40,
          "interval": null,
          "links": [],
          "mappingType": 1,
          "mappingTypes": [
            {
              "name": "value to text",
              "value": 1
            },
            {
              "name": "range to text",
              "value": 2
            }
          ],
          "maxDataPoints": 100,
          "nullPointMode": "connected",
          "nullText": null,
          "postfix": "",
          "postfixFontSize": "50%",
          "prefix": "",
          "prefixFontSize": "50%",
          "rangeMaps": [
            {
              "from": "null",
              "text": "N/A",
              "to": "null"
            }
          ],
          "sparkline": {
            "fillColor": "rgba(31, 118, 189, 0.18)",
            "full": false,
            "lineColor": "rgb(31, 120, 193)",
            "show": true
          },
          "tableColumn": "",
          "targets": [
            {
              "expr": "sum(kube_pod_container_status_terminated{namespace=~\"$namespace\"})",
              "format": "time_series",
              "intervalFactor": 1,
              "refId": "A"
            }
          ],
          "thresholds": "",
          "title": "Containers Terminated",
          "type": "singlestat",
          "valueFontSize": "80%",
          "valueMaps": [
            {
              "op": "=",
              "text": "N/A",
              "value": "null"
            }
          ],
          "valueName": "current"
        },
        {
          "cacheTimeout": null,
          "colorBackground": false,
          "colorValue": false,
          "colors": [
            "#299c46",
            "rgba(237, 129, 40, 0.89)",
            "#d44a3a"
          ],
          "datasource": "$datasource",
          "format": "none",
          "gauge": {
            "maxValue": 100,
            "minValue": 0,
            "show": false,
            "thresholdLabels": false,
            "thresholdMarkers": true
          },
          "gridPos": {
            "h": 3,
            "w": 6,
            "x": 18,
            "y": 18
          },
          "id": 41,
          "interval": null,
          "links": [],
          "mappingType": 1,
          "mappingTypes": [
            {
              "name": "value to text",
              "value": 1
            },
            {
              "name": "range to text",
              "value": 2
            }
          ],
          "maxDataPoints": 100,
          "nullPointMode": "connected",
          "nullText": null,
          "postfix": "",
          "postfixFontSize": "50%",
          "prefix": "",
          "prefixFontSize": "50%",
          "rangeMaps": [
            {
              "from": "null",
              "text": "N/A",
              "to": "null"
            }
          ],
          "sparkline": {
            "fillColor": "rgba(31, 118, 189, 0.18)",
            "full": false,
            "lineColor": "rgb(31, 120, 193)",
            "show": true
          },
          "tableColumn": "",
          "targets": [
            {
              "expr": "sum(delta(kube_pod_container_status_restarts_total{namespace!=\"kube-system\"}[30m]))",
              "format": "time_series",
              "intervalFactor": 1,
              "legendFormat": "",
              "refId": "A"
            }
          ],
          "thresholds": "",
          "title": "Containers Restarts (Last 30 Minutes)",
          "type": "singlestat",
          "valueFontSize": "80%",
          "valueMaps": [
            {
              "op": "=",
              "text": "N/A",
              "value": "null"
            }
          ],
          "valueName": "current"
        },
        {
          "cacheTimeout": null,
          "colorBackground": false,
          "colorValue": false,
          "colors": [
            "#299c46",
            "rgba(237, 129, 40, 0.89)",
            "#d44a3a"
          ],
          "datasource": "$datasource",
          "format": "none",
          "gauge": {
            "maxValue": 100,
            "minValue": 0,
            "show": false,
            "thresholdLabels": false,
            "thresholdMarkers": true
          },
          "gridPos": {
            "h": 3,
            "w": 12,
            "x": 0,
            "y": 21
          },
          "id": 43,
          "interval": null,
          "links": [],
          "mappingType": 1,
          "mappingTypes": [
            {
              "name": "value to text",
              "value": 1
            },
            {
              "name": "range to text",
              "value": 2
            }
          ],
          "maxDataPoints": 100,
          "nullPointMode": "connected",
          "nullText": null,
          "postfix": "",
          "postfixFontSize": "50%",
          "prefix": "",
          "prefixFontSize": "50%",
          "rangeMaps": [
            {
              "from": "null",
              "text": "N/A",
              "to": "null"
            }
          ],
          "sparkline": {
            "fillColor": "rgba(31, 118, 189, 0.18)",
            "full": false,
            "lineColor": "rgb(31, 120, 193)",
            "show": true
          },
          "tableColumn": "",
          "targets": [
            {
              "expr": "sum(kube_pod_container_resource_requests_cpu_cores{namespace=~\"$namespace\"})",
              "format": "time_series",
              "intervalFactor": 1,
              "refId": "A"
            }
          ],
          "thresholds": "",
          "title": "CPU Cores Requested by Containers",
          "type": "singlestat",
          "valueFontSize": "80%",
          "valueMaps": [
            {
              "op": "=",
              "text": "N/A",
              "value": "null"
            }
          ],
          "valueName": "current"
        },
        {
          "cacheTimeout": null,
          "colorBackground": false,
          "colorValue": false,
          "colors": [
            "#299c46",
            "rgba(237, 129, 40, 0.89)",
            "#d44a3a"
          ],
          "datasource": "$datasource",
          "format": "decbytes",
          "gauge": {
            "maxValue": 100,
            "minValue": 0,
            "show": false,
            "thresholdLabels": false,
            "thresholdMarkers": true
          },
          "gridPos": {
            "h": 3,
            "w": 12,
            "x": 12,
            "y": 21
          },
          "id": 42,
          "interval": null,
          "links": [],
          "mappingType": 1,
          "mappingTypes": [
            {
              "name": "value to text",
              "value": 1
            },
            {
              "name": "range to text",
              "value": 2
            }
          ],
          "maxDataPoints": 100,
          "nullPointMode": "connected",
          "nullText": null,
          "postfix": "",
          "postfixFontSize": "50%",
          "prefix": "",
          "prefixFontSize": "50%",
          "rangeMaps": [
            {
              "from": "null",
              "text": "N/A",
              "to": "null"
            }
          ],
          "sparkline": {
            "fillColor": "rgba(31, 118, 189, 0.18)",
            "full": false,
            "lineColor": "rgb(31, 120, 193)",
            "show": true
          },
          "tableColumn": "",
          "targets": [
            {
              "dimensions": {},
              "expr": "sum(kube_pod_container_resource_requests_memory_bytes{namespace=~\"$namespace\"})",
              "expression": "",
              "format": "time_series",
              "highResolution": false,
              "id": "",
              "intervalFactor": 1,
              "metricName": "",
              "namespace": "",
              "period": "",
              "refId": "A",
              "region": "default",
              "returnData": false,
              "statistics": [
                "Average"
              ]
            }
          ],
          "thresholds": "",
          "title": "Memory Requested By Containers",
          "type": "singlestat",
          "valueFontSize": "80%",
          "valueMaps": [
            {
              "op": "=",
              "text": "N/A",
              "value": "null"
            }
          ],
          "valueName": "current"
        },
        {
          "collapsed": false,
          "gridPos": {
            "h": 1,
            "w": 24,
            "x": 0,
            "y": 24
          },
          "id": 45,
          "panels": [],
          "title": "Jobs",
          "type": "row"
        },
        {
          "cacheTimeout": null,
          "colorBackground": false,
          "colorValue": false,
          "colors": [
            "#299c46",
            "rgba(237, 129, 40, 0.89)",
            "#d44a3a"
          ],
          "datasource": "$datasource",
          "format": "none",
          "gauge": {
            "maxValue": 100,
            "minValue": 0,
            "show": false,
            "thresholdLabels": false,
            "thresholdMarkers": true
          },
          "gridPos": {
            "h": 3,
            "w": 8,
            "x": 0,
            "y": 25
          },
          "id": 47,
          "interval": null,
          "links": [],
          "mappingType": 1,
          "mappingTypes": [
            {
              "name": "value to text",
              "value": 1
            },
            {
              "name": "range to text",
              "value": 2
            }
          ],
          "maxDataPoints": 100,
          "nullPointMode": "connected",
          "nullText": null,
          "postfix": "",
          "postfixFontSize": "50%",
          "prefix": "",
          "prefixFontSize": "50%",
          "rangeMaps": [
            {
              "from": "null",
              "text": "N/A",
              "to": "null"
            }
          ],
          "sparkline": {
            "fillColor": "rgba(31, 118, 189, 0.18)",
            "full": false,
            "lineColor": "rgb(31, 120, 193)",
            "show": true
          },
          "tableColumn": "",
          "targets": [
            {
              "expr": "sum(kube_job_status_succeeded{namespace=~\"$namespace\"})",
              "format": "time_series",
              "intervalFactor": 1,
              "refId": "A"
            }
          ],
          "thresholds": "",
          "title": "Jobs Succeeded",
          "type": "singlestat",
          "valueFontSize": "80%",
          "valueMaps": [
            {
              "op": "=",
              "text": "N/A",
              "value": "null"
            }
          ],
          "valueName": "current"
        },
        {
          "cacheTimeout": null,
          "colorBackground": false,
          "colorValue": false,
          "colors": [
            "#299c46",
            "rgba(237, 129, 40, 0.89)",
            "#d44a3a"
          ],
          "datasource": "$datasource",
          "format": "none",
          "gauge": {
            "maxValue": 100,
            "minValue": 0,
            "show": false,
            "thresholdLabels": false,
            "thresholdMarkers": true
          },
          "gridPos": {
            "h": 3,
            "w": 8,
            "x": 8,
            "y": 25
          },
          "id": 48,
          "interval": null,
          "links": [],
          "mappingType": 1,
          "mappingTypes": [
            {
              "name": "value to text",
              "value": 1
            },
            {
              "name": "range to text",
              "value": 2
            }
          ],
          "maxDataPoints": 100,
          "nullPointMode": "connected",
          "nullText": null,
          "postfix": "",
          "postfixFontSize": "50%",
          "prefix": "",
          "prefixFontSize": "50%",
          "rangeMaps": [
            {
              "from": "null",
              "text": "N/A",
              "to": "null"
            }
          ],
          "sparkline": {
            "fillColor": "rgba(31, 118, 189, 0.18)",
            "full": false,
            "lineColor": "rgb(31, 120, 193)",
            "show": true
          },
          "tableColumn": "",
          "targets": [
            {
              "expr": "sum(kube_job_status_active{namespace=~\"$namespace\"})",
              "format": "time_series",
              "intervalFactor": 1,
              "refId": "A"
            }
          ],
          "thresholds": "",
          "title": "Jobs Succeeded",
          "type": "singlestat",
          "valueFontSize": "80%",
          "valueMaps": [
            {
              "op": "=",
              "text": "N/A",
              "value": "null"
            }
          ],
          "valueName": "current"
        },
        {
          "cacheTimeout": null,
          "colorBackground": false,
          "colorValue": false,
          "colors": [
            "#299c46",
            "rgba(237, 129, 40, 0.89)",
            "#d44a3a"
          ],
          "datasource": "$datasource",
          "format": "none",
          "gauge": {
            "maxValue": 100,
            "minValue": 0,
            "show": false,
            "thresholdLabels": false,
            "thresholdMarkers": true
          },
          "gridPos": {
            "h": 3,
            "w": 8,
            "x": 16,
            "y": 25
          },
          "id": 49,
          "interval": null,
          "links": [],
          "mappingType": 1,
          "mappingTypes": [
            {
              "name": "value to text",
              "value": 1
            },
            {
              "name": "range to text",
              "value": 2
            }
          ],
          "maxDataPoints": 100,
          "nullPointMode": "connected",
          "nullText": null,
          "postfix": "",
          "postfixFontSize": "50%",
          "prefix": "",
          "prefixFontSize": "50%",
          "rangeMaps": [
            {
              "from": "null",
              "text": "N/A",
              "to": "null"
            }
          ],
          "sparkline": {
            "fillColor": "rgba(31, 118, 189, 0.18)",
            "full": false,
            "lineColor": "rgb(31, 120, 193)",
            "show": true
          },
          "tableColumn": "",
          "targets": [
            {
              "expr": "sum(kube_job_status_failed{namespace=~\"$namespace\"})",
              "format": "time_series",
              "intervalFactor": 1,
              "refId": "A"
            }
          ],
          "thresholds": "",
          "title": "Jobs Failed",
          "type": "singlestat",
          "valueFontSize": "80%",
          "valueMaps": [
            {
              "op": "=",
              "text": "N/A",
              "value": "null"
            }
          ],
          "valueName": "current"
        }
      ],
      "refresh": "30s",
      "schemaVersion": 16,
      "style": "dark",
      "tags": [
        "kubernetes",
        "kubernetes-app"
      ],
      "templating": {
        "list": [
          {
            "current": {
              "tags": [],
              "text": "https://prometheus.k.int.bitnami.net",
              "value": "https://prometheus.k.int.bitnami.net"
            },
            "hide": 0,
            "label": "",
            "name": "datasource",
            "options": [],
            "query": "prometheus",
            "refresh": 1,
            "regex": "",
            "skipUrlSync": false,
            "type": "datasource"
          },
          {
            "allValue": null,
            "current": {
              "text": "All",
              "value": "$__all"
            },
            "datasource": "$datasource",
            "definition": "label_values(node_boot_time_seconds{name='node-exporter'}, instance)",
            "hide": 0,
            "includeAll": true,
            "label": null,
            "multi": true,
            "name": "node",
            "options": [],
            "query": "label_values(node_boot_time_seconds{name='node-exporter'}, instance)",
            "refresh": 1,
            "regex": "/([0-9]{1,3}\\.[0-9]{1,3}\\.[0-9]{1,3}\\.[0-9]{1,3})/",
            "skipUrlSync": false,
            "sort": 0,
            "tagValuesQuery": null,
            "tags": [],
            "tagsQuery": null,
            "type": "query",
            "useTags": false
          },
          {
            "allValue": null,
            "current": {
              "text": "All",
              "value": "$__all"
            },
            "datasource": "$datasource",
            "definition": "kube_pod_container_status_running",
            "hide": 0,
            "includeAll": true,
            "label": null,
            "multi": true,
            "name": "namespace",
            "options": [],
            "query": "kube_pod_container_status_running",
            "refresh": 1,
            "regex": "/.*,namespace=\"([^\"]+)\".*/",
            "skipUrlSync": false,
            "sort": 1,
            "tagValuesQuery": null,
            "tags": [],
            "tagsQuery": null,
            "type": "query",
            "useTags": false
          }
        ]
      },
      "time": {
        "from": "now-30m",
        "to": "now"
      },
      "timepicker": {
        "refresh_intervals": [
          "5s",
          "10s",
          "30s",
          "1m",
          "5m",
          "15m",
          "30m",
          "1h",
          "2h",
          "1d"
        ],
        "time_options": [
          "5m",
          "15m",
          "1h",
          "6h",
          "12h",
          "24h",
          "2d",
          "7d",
          "30d"
        ]
      },
      "timezone": "browser",
      "title": "Kubernetes workloads summary",
      "uid": "9aBygqRZk",
      "version": 6
    }
  k8s_resource_usage_namespace_pods.json: |
    {
      "annotations": {
        "list": [
          {
            "builtIn": 1,
            "datasource": "-- Grafana --",
            "enable": true,
            "hide": true,
            "iconColor": "rgba(0, 211, 255, 1)",
            "name": "Annotations & Alerts",
            "type": "dashboard"
          }
        ]
      },
      "editable": true,
      "gnetId": null,
      "graphTooltip": 1,
      "iteration": 1595347057621,
      "links": [
        {
          "icon": "external link",
          "includeVars": true,
          "tags": [
            "k8s",
            "resources"
          ],
          "targetBlank": true,
          "type": "dashboards"
        }
      ],
      "panels": [
        {
          "collapsed": false,
          "datasource": null,
          "gridPos": {
            "h": 1,
            "w": 24,
            "x": 0,
            "y": 0
          },
          "id": 12,
          "panels": [],
          "repeat": null,
          "title": "Containers CPU and MEM",
          "type": "row"
        },
        {
          "aliasColors": {},
          "bars": false,
          "dashLength": 10,
          "dashes": false,
          "datasource": "$datasource",
          "decimals": 2,
          "fieldConfig": {
            "defaults": {
              "custom": {}
            },
            "overrides": []
          },
          "fill": 1,
          "fillGradient": 0,
          "gridPos": {
            "h": 8,
            "w": 24,
            "x": 0,
            "y": 1
          },
          "hiddenSeries": false,
          "id": 5,
          "legend": {
            "alignAsTable": true,
            "avg": true,
            "current": true,
            "max": true,
            "min": false,
            "rightSide": true,
            "show": true,
            "sort": "max",
            "sortDesc": true,
            "total": false,
            "values": true
          },
          "lines": true,
          "linewidth": 1,
          "links": [],
          "nullPointMode": "null",
          "options": {
            "dataLinks": []
          },
          "percentage": false,
          "pointradius": 5,
          "points": false,
          "renderer": "flot",
          "seriesOverrides": [],
          "spaceLength": 10,
          "stack": false,
          "steppedLine": false,
          "targets": [
            {
              "expr": "topk($top, sum(rate(container_cpu_usage_seconds_total{namespace=~\"$namespace\",pod=~\"$pod.*\",container=~\"$container\"}[$_interval])) without (cpu)) > 1e-3",
              "format": "time_series",
              "hide": false,
              "interval": "",
              "intervalFactor": 2,
              "legendFormat": "{{cluster}} - {{ pod }}/{{ container }}",
              "metric": "container_cpu_usage_seconds_total",
              "refId": "A",
              "step": 60
            },
            {
              "expr": "topk($top, sum(rate(container_cpu_usage_seconds_total{namespace=~\"$namespace\",pod_name=~\"$pod.*\",container_name=~\"$container\"}[$_interval])) without (cpu)) > 1e-3",
              "format": "time_series",
              "hide": false,
              "interval": "",
              "intervalFactor": 2,
              "legendFormat": "{{cluster}} - {{ pod_name }}/{{ container_name }}",
              "metric": "container_cpu_usage_seconds_total",
              "refId": "B",
              "step": 60
            }
          ],
          "thresholds": [],
          "timeFrom": null,
          "timeRegions": [],
          "timeShift": null,
          "title": "top$top container CPU usage  for ns=\"$namespace\" (pod=\"$pod\",container=\"$container\")",
          "tooltip": {
            "shared": true,
            "sort": 2,
            "value_type": "individual"
          },
          "type": "graph",
          "xaxis": {
            "buckets": null,
            "mode": "time",
            "name": null,
            "show": true,
            "values": []
          },
          "yaxes": [
            {
              "format": "short",
              "label": null,
              "logBase": 1,
              "max": null,
              "min": null,
              "show": true
            },
            {
              "format": "short",
              "label": null,
              "logBase": 1,
              "max": null,
              "min": null,
              "show": true
            }
          ],
          "yaxis": {
            "align": false,
            "alignLevel": null
          }
        },
        {
          "aliasColors": {},
          "bars": false,
          "dashLength": 10,
          "dashes": false,
          "datasource": "$datasource",
          "fieldConfig": {
            "defaults": {
              "custom": {}
            },
            "overrides": []
          },
          "fill": 1,
          "fillGradient": 0,
          "gridPos": {
            "h": 8,
            "w": 24,
            "x": 0,
            "y": 9
          },
          "hiddenSeries": false,
          "id": 3,
          "legend": {
            "alignAsTable": true,
            "avg": true,
            "current": false,
            "max": true,
            "min": false,
            "rightSide": true,
            "show": true,
            "sort": "max",
            "sortDesc": true,
            "total": false,
            "values": true
          },
          "lines": true,
          "linewidth": 1,
          "links": [],
          "nullPointMode": "null",
          "options": {
            "dataLinks": []
          },
          "percentage": false,
          "pointradius": 5,
          "points": false,
          "renderer": "flot",
          "seriesOverrides": [],
          "spaceLength": 10,
          "stack": false,
          "steppedLine": false,
          "targets": [
            {
              "expr": "topk($top, container_memory_working_set_bytes{namespace=~\"$namespace\",pod=~\"$pod.*\",container=~\"$container\"})",
              "format": "time_series",
              "hide": false,
              "interval": "",
              "intervalFactor": 2,
              "legendFormat": "{{cluster}} - {{pod}}/{{container}}",
              "metric": "container_memory_rss",
              "refId": "A",
              "step": 60
            },
            {
              "expr": "topk($top, container_memory_working_set_bytes{namespace=~\"$namespace\",pod_name=~\"$pod.*\",container_name=~\"$container\"})",
              "format": "time_series",
              "hide": false,
              "interval": "",
              "intervalFactor": 2,
              "legendFormat": "{{cluster}} - {{pod_name}}/{{container_name}}",
              "metric": "container_memory_rss",
              "refId": "B",
              "step": 60
            }
          ],
          "thresholds": [],
          "timeFrom": null,
          "timeRegions": [],
          "timeShift": null,
          "title": "top$top container MEM usage  for ns=\"$namespace\" (pod=\"$pod\",container=\"$container\")",
          "tooltip": {
            "shared": true,
            "sort": 2,
            "value_type": "individual"
          },
          "type": "graph",
          "xaxis": {
            "buckets": null,
            "mode": "time",
            "name": null,
            "show": true,
            "values": []
          },
          "yaxes": [
            {
              "format": "bytes",
              "label": null,
              "logBase": 1,
              "max": null,
              "min": null,
              "show": true
            },
            {
              "format": "short",
              "label": null,
              "logBase": 1,
              "max": null,
              "min": null,
              "show": true
            }
          ],
          "yaxis": {
            "align": false,
            "alignLevel": null
          }
        },
        {
          "collapsed": true,
          "datasource": null,
          "gridPos": {
            "h": 1,
            "w": 24,
            "x": 0,
            "y": 17
          },
          "id": 13,
          "panels": [
            {
              "aliasColors": {},
              "bars": false,
              "dashLength": 10,
              "dashes": false,
              "datasource": "$datasource",
              "fieldConfig": {
                "defaults": {
                  "custom": {}
                },
                "overrides": []
              },
              "fill": 1,
              "fillGradient": 0,
              "gridPos": {
                "h": 8,
                "w": 24,
                "x": 0,
                "y": 18
              },
              "hiddenSeries": false,
              "id": 7,
              "legend": {
                "alignAsTable": true,
                "avg": false,
                "current": false,
                "max": true,
                "min": true,
                "rightSide": true,
                "show": true,
                "sort": "max",
                "sortDesc": true,
                "total": false,
                "values": true
              },
              "lines": true,
              "linewidth": 1,
              "links": [],
              "nullPointMode": "null",
              "options": {
                "dataLinks": []
              },
              "percentage": false,
              "pointradius": 5,
              "points": false,
              "renderer": "flot",
              "seriesOverrides": [],
              "spaceLength": 10,
              "stack": false,
              "steppedLine": false,
              "targets": [
                {
                  "expr": "topk($top, sum(rate(container_fs_reads_bytes_total{namespace=~\"$namespace\",pod=~\"$pod.*\",container=~\"$container\"}[$_interval])) without (cpu)) > 0",
                  "format": "time_series",
                  "hide": false,
                  "interval": "",
                  "intervalFactor": 2,
                  "legendFormat": "{{cluster}} - {{pod}}/{{container}}",
                  "refId": "A",
                  "step": 4
                },
                {
                  "expr": "- topk($top, sum(rate(container_fs_writes_bytes_total{namespace=~\"$namespace\",pod=~\"$pod.*\",container=~\"$container\"}[$_interval])) without (cpu)) < 0",
                  "format": "time_series",
                  "intervalFactor": 2,
                  "legendFormat": "{{cluster}} - {{pod}}/{{container}}",
                  "refId": "B",
                  "step": 4
                },
                {
                  "expr": "topk($top, sum(rate(container_fs_reads_bytes_total{namespace=~\"$namespace\",pod_name=~\"$pod.*\",container_name=~\"$container\"}[$_interval])) without (cpu)) > 0",
                  "format": "time_series",
                  "hide": false,
                  "interval": "",
                  "intervalFactor": 2,
                  "legendFormat": "{{cluster}} - {{pod_name}}/{{container_name}}",
                  "refId": "C",
                  "step": 4
                },
                {
                  "expr": "- topk($top, sum(rate(container_fs_writes_bytes_total{namespace=~\"$namespace\",pod_name=~\"$pod.*\",container_name=~\"$container\"}[$_interval])) without (cpu)) < 0",
                  "format": "time_series",
                  "intervalFactor": 2,
                  "legendFormat": "{{cluster}} - {{pod_name}}/{{container_name}}",
                  "refId": "D",
                  "step": 4
                }
              ],
              "thresholds": [],
              "timeFrom": null,
              "timeRegions": [],
              "timeShift": null,
              "title": "top$top container IO +R -W for ns=\"$namespace\" (pod=\"$pod\",container=\"$container\") [bytes/sec]",
              "tooltip": {
                "shared": true,
                "sort": 1,
                "value_type": "individual"
              },
              "type": "graph",
              "xaxis": {
                "buckets": null,
                "mode": "time",
                "name": null,
                "show": true,
                "values": []
              },
              "yaxes": [
                {
                  "format": "Bps",
                  "label": null,
                  "logBase": 1,
                  "max": null,
                  "min": null,
                  "show": true
                },
                {
                  "format": "short",
                  "label": null,
                  "logBase": 1,
                  "max": null,
                  "min": null,
                  "show": false
                }
              ],
              "yaxis": {
                "align": false,
                "alignLevel": null
              }
            },
            {
              "aliasColors": {},
              "bars": false,
              "dashLength": 10,
              "dashes": false,
              "datasource": "$datasource",
              "fieldConfig": {
                "defaults": {
                  "custom": {}
                },
                "overrides": []
              },
              "fill": 1,
              "fillGradient": 0,
              "gridPos": {
                "h": 8,
                "w": 24,
                "x": 0,
                "y": 26
              },
              "hiddenSeries": false,
              "id": 8,
              "legend": {
                "alignAsTable": true,
                "avg": false,
                "current": false,
                "max": true,
                "min": true,
                "rightSide": true,
                "show": true,
                "sort": "max",
                "sortDesc": true,
                "total": false,
                "values": true
              },
              "lines": true,
              "linewidth": 1,
              "links": [],
              "nullPointMode": "null",
              "options": {
                "dataLinks": []
              },
              "percentage": false,
              "pointradius": 5,
              "points": false,
              "renderer": "flot",
              "seriesOverrides": [],
              "spaceLength": 10,
              "stack": false,
              "steppedLine": false,
              "targets": [
                {
                  "expr": "topk($top, sum(rate(container_fs_reads_total{namespace=~\"$namespace\",pod=~\"$pod.*\",container=~\"$container\"}[$_interval])) without (cpu)) > 0",
                  "format": "time_series",
                  "hide": false,
                  "interval": "",
                  "intervalFactor": 2,
                  "legendFormat": "{{cluster}} - {{pod}}/{{container}}",
                  "refId": "A",
                  "step": 4
                },
                {
                  "expr": "- topk($top, sum(rate(container_fs_writes_total{namespace=~\"$namespace\",pod=~\"$pod.*\",container=~\"$container\"}[$_interval])) without (cpu)) < 0",
                  "format": "time_series",
                  "intervalFactor": 2,
                  "legendFormat": "{{cluster}} - {{pod}}/{{container}}",
                  "refId": "B",
                  "step": 4
                },
                {
                  "expr": "topk($top, sum(rate(container_fs_reads_total{namespace=~\"$namespace\",pod_name=~\"$pod.*\",container_name=~\"$container\"}[$_interval])) without (cpu)) > 0",
                  "format": "time_series",
                  "hide": false,
                  "interval": "",
                  "intervalFactor": 2,
                  "legendFormat": "{{cluster}} - {{pod_name}}/{{container_name}}",
                  "refId": "C",
                  "step": 4
                },
                {
                  "expr": "- topk($top, sum(rate(container_fs_writes_total{namespace=~\"$namespace\",pod_name=~\"$pod.*\",container_name=~\"$container\"}[$_interval])) without (cpu)) < 0",
                  "format": "time_series",
                  "intervalFactor": 2,
                  "legendFormat": "{{cluster}} - {{pod_name}}/{{container_name}}",
                  "refId": "D",
                  "step": 4
                }
              ],
              "thresholds": [],
              "timeFrom": null,
              "timeRegions": [],
              "timeShift": null,
              "title": "top$top container IO +R -W ns=\"$namespace\" (pod=\"$pod\",container=\"$container\") [iops]",
              "tooltip": {
                "shared": true,
                "sort": 1,
                "value_type": "individual"
              },
              "type": "graph",
              "xaxis": {
                "buckets": null,
                "mode": "time",
                "name": null,
                "show": true,
                "values": []
              },
              "yaxes": [
                {
                  "format": "iops",
                  "label": null,
                  "logBase": 1,
                  "max": null,
                  "min": null,
                  "show": true
                },
                {
                  "format": "short",
                  "label": null,
                  "logBase": 1,
                  "max": null,
                  "min": null,
                  "show": false
                }
              ],
              "yaxis": {
                "align": false,
                "alignLevel": null
              }
            }
          ],
          "repeat": null,
          "title": "Containers I/O",
          "type": "row"
        },
        {
          "collapsed": true,
          "datasource": null,
          "gridPos": {
            "h": 1,
            "w": 24,
            "x": 0,
            "y": 18
          },
          "id": 14,
          "panels": [
            {
              "aliasColors": {},
              "bars": false,
              "dashLength": 10,
              "dashes": false,
              "datasource": "$datasource",
              "fieldConfig": {
                "defaults": {
                  "custom": {}
                },
                "overrides": []
              },
              "fill": 1,
              "fillGradient": 0,
              "gridPos": {
                "h": 8,
                "w": 24,
                "x": 0,
                "y": 19
              },
              "hiddenSeries": false,
              "id": 10,
              "legend": {
                "alignAsTable": true,
                "avg": false,
                "current": false,
                "max": true,
                "min": true,
                "rightSide": true,
                "show": true,
                "sort": "max",
                "sortDesc": true,
                "total": false,
                "values": true
              },
              "lines": true,
              "linewidth": 1,
              "links": [],
              "nullPointMode": "null",
              "options": {
                "dataLinks": []
              },
              "percentage": false,
              "pointradius": 5,
              "points": false,
              "renderer": "flot",
              "seriesOverrides": [],
              "spaceLength": 10,
              "stack": false,
              "steppedLine": false,
              "targets": [
                {
                  "expr": "topk($top, sum(rate(container_network_receive_bytes_total{namespace=~\"$namespace\",pod=~\"$pod.*\"}[$_interval])) without (cpu)) > 0",
                  "format": "time_series",
                  "hide": false,
                  "interval": "",
                  "intervalFactor": 2,
                  "legendFormat": "{{cluster}} - {{pod}}",
                  "refId": "A",
                  "step": 4
                },
                {
                  "expr": "- topk($top, sum(rate(container_network_transmit_bytes_total{namespace=~\"$namespace\",pod=~\"$pod.*\"}[$_interval])) without (cpu)) < 0",
                  "format": "time_series",
                  "intervalFactor": 2,
                  "legendFormat": "{{cluster}} - {{pod}}",
                  "refId": "B",
                  "step": 4
                },
                {
                  "expr": "topk($top, sum(rate(container_network_receive_bytes_total{namespace=~\"$namespace\",pod_name=~\"$pod.*\"}[$_interval])) without (cpu)) > 0",
                  "format": "time_series",
                  "hide": false,
                  "interval": "",
                  "intervalFactor": 2,
                  "legendFormat": "{{cluster}} - {{pod_name}}",
                  "refId": "C",
                  "step": 4
                },
                {
                  "expr": "- topk($top, sum(rate(container_network_transmit_bytes_total{namespace=~\"$namespace\",pod_name=~\"$pod.*\"}[$_interval])) without (cpu)) < 0",
                  "format": "time_series",
                  "intervalFactor": 2,
                  "legendFormat": "{{cluster}} - {{pod_name}}",
                  "refId": "D",
                  "step": 4
                }
              ],
              "thresholds": [],
              "timeFrom": null,
              "timeRegions": [],
              "timeShift": null,
              "title": "top$top Pod Network +RX -TX ns=\"$namespace\" (pod=\"$pod\") [Bytes/sec]",
              "tooltip": {
                "shared": true,
                "sort": 1,
                "value_type": "individual"
              },
              "type": "graph",
              "xaxis": {
                "buckets": null,
                "mode": "time",
                "name": null,
                "show": true,
                "values": []
              },
              "yaxes": [
                {
                  "format": "Bps",
                  "label": null,
                  "logBase": 1,
                  "max": null,
                  "min": null,
                  "show": true
                },
                {
                  "format": "short",
                  "label": null,
                  "logBase": 1,
                  "max": null,
                  "min": null,
                  "show": false
                }
              ],
              "yaxis": {
                "align": false,
                "alignLevel": null
              }
            },
            {
              "aliasColors": {},
              "bars": false,
              "dashLength": 10,
              "dashes": false,
              "datasource": "$datasource",
              "fieldConfig": {
                "defaults": {
                  "custom": {}
                },
                "overrides": []
              },
              "fill": 1,
              "fillGradient": 0,
              "gridPos": {
                "h": 8,
                "w": 24,
                "x": 0,
                "y": 27
              },
              "hiddenSeries": false,
              "id": 11,
              "legend": {
                "alignAsTable": true,
                "avg": false,
                "current": false,
                "max": true,
                "min": true,
                "rightSide": true,
                "show": true,
                "sort": "max",
                "sortDesc": true,
                "total": false,
                "values": true
              },
              "lines": true,
              "linewidth": 1,
              "links": [],
              "nullPointMode": "null",
              "options": {
                "dataLinks": []
              },
              "percentage": false,
              "pointradius": 5,
              "points": false,
              "renderer": "flot",
              "seriesOverrides": [],
              "spaceLength": 10,
              "stack": false,
              "steppedLine": false,
              "targets": [
                {
                  "expr": "topk($top, sum(rate(container_network_receive_packets_total{namespace=~\"$namespace\",pod=~\"$pod.*\"}[$_interval])) without (cpu)) > 0",
                  "format": "time_series",
                  "hide": false,
                  "interval": "",
                  "intervalFactor": 2,
                  "legendFormat": "{{cluster}} - {{pod}}",
                  "refId": "A",
                  "step": 4
                },
                {
                  "expr": "- topk($top, sum(rate(container_network_transmit_packets_total{namespace=~\"$namespace\",pod=~\"$pod.*\"}[$_interval])) without (cpu)) < 0",
                  "format": "time_series",
                  "hide": false,
                  "intervalFactor": 2,
                  "legendFormat": "{{cluster}} - {{pod}}",
                  "refId": "B",
                  "step": 4
                },
                {
                  "expr": "topk($top, sum(rate(container_network_receive_packets_total{namespace=~\"$namespace\",pod_name=~\"$pod.*\"}[$_interval])) without (cpu)) > 0",
                  "format": "time_series",
                  "hide": false,
                  "interval": "",
                  "intervalFactor": 2,
                  "legendFormat": "{{cluster}} - {{pod_name}}",
                  "refId": "C",
                  "step": 4
                },
                {
                  "expr": "- topk($top, sum(rate(container_network_transmit_packets_total{namespace=~\"$namespace\",pod_name=~\"$pod.*\"}[$_interval])) without (cpu)) < 0",
                  "format": "time_series",
                  "hide": false,
                  "intervalFactor": 2,
                  "legendFormat": "{{cluster}} - {{pod_name}}",
                  "refId": "D",
                  "step": 4
                }
              ],
              "thresholds": [],
              "timeFrom": null,
              "timeRegions": [],
              "timeShift": null,
              "title": "top$top Pod Network +RX -TX ns=\"$namespace\" (pod=\"$pod\") [pkts/sec]",
              "tooltip": {
                "shared": true,
                "sort": 1,
                "value_type": "individual"
              },
              "type": "graph",
              "xaxis": {
                "buckets": null,
                "mode": "time",
                "name": null,
                "show": true,
                "values": []
              },
              "yaxes": [
                {
                  "format": "pps",
                  "label": null,
                  "logBase": 1,
                  "max": null,
                  "min": null,
                  "show": true
                },
                {
                  "format": "short",
                  "label": null,
                  "logBase": 1,
                  "max": null,
                  "min": null,
                  "show": false
                }
              ],
              "yaxis": {
                "align": false,
                "alignLevel": null
              }
            }
          ],
          "repeat": null,
          "title": "Pods Network traffic",
          "type": "row"
        }
      ],
      "refresh": false,
      "schemaVersion": 25,
      "style": "dark",
      "tags": [
        "k8s",
        "resources",
        "parm_namespace",
        "view_pod"
      ],
      "templating": {
        "list": [
          {
            "hide": 0,
            "includeAll": false,
            "label": null,
            "multi": false,
            "name": "datasource",
            "options": [],
            "query": "prometheus",
            "queryValue": "",
            "refresh": 1,
            "regex": "",
            "skipUrlSync": false,
            "type": "datasource"
          },
          {
            "allValue": null,
            "current": {
              "selected": true,
              "text": "10",
              "value": "10"
            },
            "hide": 0,
            "includeAll": false,
            "label": null,
            "multi": false,
            "name": "top",
            "options": [
              {
                "selected": false,
                "text": "5",
                "value": "5"
              },
              {
                "selected": true,
                "text": "10",
                "value": "10"
              },
              {
                "selected": false,
                "text": "20",
                "value": "20"
              },
              {
                "selected": false,
                "text": "100",
                "value": "100"
              }
            ],
            "query": "5,10,20,100",
            "skipUrlSync": false,
            "type": "custom"
          },
          {
            "allValue": ".+",
            "current": {
              "selected": true,
              "tags": [],
              "text": "All",
              "value": [
                "$__all"
              ]
            },
            "datasource": "$datasource",
            "definition": "",
            "hide": 0,
            "includeAll": true,
            "label": null,
            "multi": true,
            "name": "namespace",
            "options": [],
            "query": "kube_pod_container_status_running",
            "refresh": 1,
            "regex": "/.*,namespace=\"([^\"]+)\".*/",
            "skipUrlSync": false,
            "sort": 1,
            "tagValuesQuery": "",
            "tags": [],
            "tagsQuery": "",
            "type": "query",
            "useTags": false
          },
          {
            "allValue": ".*",
            "current": {
              "selected": false,
              "text": "All",
              "value": "$__all"
            },
            "datasource": "$datasource",
            "definition": "",
            "hide": 0,
            "includeAll": true,
            "label": "pod",
            "multi": false,
            "name": "pod",
            "options": [],
            "query": "kube_pod_container_status_running",
            "refresh": 1,
            "regex": "/.*pod=\"([a-z0-9-]+?)(?:-([0-9a-f]+-)?.....(-.....)?|-[0-9]+)?\".*/",
            "skipUrlSync": false,
            "sort": 1,
            "tagValuesQuery": "",
            "tags": [],
            "tagsQuery": "",
            "type": "query",
            "useTags": false
          },
          {
            "allValue": ".+",
            "current": {
              "selected": false,
              "text": "All",
              "value": "$__all"
            },
            "datasource": "$datasource",
            "definition": "",
            "hide": 0,
            "includeAll": true,
            "label": "container",
            "multi": false,
            "name": "container",
            "options": [],
            "query": "kube_pod_container_status_running",
            "refresh": 1,
            "regex": "/.*container=\"([^\"]+)\".*/",
            "skipUrlSync": false,
            "sort": 1,
            "tagValuesQuery": "",
            "tags": [],
            "tagsQuery": "",
            "type": "query",
            "useTags": false
          },
          {
            "auto": true,
            "auto_count": 30,
            "auto_min": "5m",
            "current": {
              "selected": false,
              "text": "auto",
              "value": "$__auto_interval__interval"
            },
            "hide": 2,
            "label": null,
            "name": "_interval",
            "options": [
              {
                "selected": true,
                "text": "auto",
                "value": "$__auto_interval__interval"
              },
              {
                "selected": false,
                "text": "5m",
                "value": "5m"
              },
              {
                "selected": false,
                "text": "10m",
                "value": "10m"
              },
              {
                "selected": false,
                "text": "30m",
                "value": "30m"
              },
              {
                "selected": false,
                "text": "1h",
                "value": "1h"
              },
              {
                "selected": false,
                "text": "6h",
                "value": "6h"
              },
              {
                "selected": false,
                "text": "12h",
                "value": "12h"
              },
              {
                "selected": false,
                "text": "1d",
                "value": "1d"
              },
              {
                "selected": false,
                "text": "7d",
                "value": "7d"
              },
              {
                "selected": false,
                "text": "14d",
                "value": "14d"
              },
              {
                "selected": false,
                "text": "30d",
                "value": "30d"
              }
            ],
            "query": "5m,10m,30m,1h,6h,12h,1d,7d,14d,30d",
            "refresh": 2,
            "skipUrlSync": false,
            "type": "interval"
          }
        ]
      },
      "time": {
        "from": "now-12h",
        "to": "now"
      },
      "timepicker": {
        "refresh_intervals": [
          "10s",
          "30s",
          "1m",
          "5m",
          "15m",
          "30m",
          "1h",
          "2h",
          "1d"
        ],
        "time_options": [
          "5m",
          "15m",
          "1h",
          "6h",
          "12h",
          "24h",
          "2d",
          "7d",
          "30d"
        ]
      },
      "timezone": "",
      "title": "Kubernetes resource usage per namespace and pod",
      "uid": "XLehfQoWk",
      "version": 6
    }
kind: ConfigMap
metadata:
  annotations: {}
  labels:
    name: grafana-kubernetes-dashboards
  name: grafana-kubernetes-dashboards-5bbac4b
  namespace: kubeprod
---
apiVersion: v1
kind: Service
metadata:
  annotations: {}
  labels:
    name: grafana
  name: grafana
  namespace: kubeprod
spec:
  ports:
  - name: dashboard
    port: 3000
    targetPort: 3000
  selector:
    name: grafana
  type: ClusterIP
---
apiVersion: v1
data:
  dashboards_provider.yml: |
    apiVersion: 1
    providers:
    - disableDeletion: false
      editable: false
      folder: Kubernetes
      name: kubernetes
      options:
        path: /opt/bitnami/grafana/conf/provisioning/dashboards/kubernetes
      type: file
kind: ConfigMap
metadata:
  annotations: {}
  labels:
    name: grafana-dashboards-configuration
  name: grafana-dashboards-configuration-b7cab55
  namespace: kubeprod
---
apiVersion: v1
data:
  bkpr.yml: |
    apiVersion: 1
    datasources:
    - access: proxy
      isDefault: true
      name: BKPR Prometheus
      type: prometheus
      url: http://prometheus.kubeprod.svc:9090/
kind: ConfigMap
metadata:
  annotations: {}
  labels:
    name: grafana-datasource-configuration
  name: grafana-datasource-configuration-30ac8c3
  namespace: kubeprod
---
apiVersion: apps/v1
kind: StatefulSet
metadata:
  annotations: {}
  labels:
    name: grafana
  name: grafana
  namespace: kubeprod
spec:
  replicas: 1
  selector:
    matchLabels:
      name: grafana
  serviceName: grafana
  template:
    metadata:
      annotations:
        prometheus.io/path: /metrics
        prometheus.io/port: "3000"
        prometheus.io/scrape: "true"
      labels:
        name: grafana
    spec:
      containers:
      - args: []
        env:
        - name: GF_AUTH_PROXY_AUTO_SIGN_UP
          value: "true"
        - name: GF_AUTH_PROXY_ENABLED
          value: "true"
        - name: GF_AUTH_PROXY_HEADERS
          value: Email:X-Auth-Request-Email
        - name: GF_AUTH_PROXY_HEADER_NAME
          value: X-Auth-Request-User
        - name: GF_AUTH_PROXY_HEADER_PROPERTY
          value: username
        - name: GF_EXPLORE_ENABLED
          value: "true"
        - name: GF_INSTALL_PLUGINS
          value: ""
        - name: GF_LOG_LEVEL
          value: warn
        - name: GF_LOG_MODE
          value: console
        - name: GF_METRICS_ENABLED
          value: "true"
        - name: GF_SERVER_DOMAIN
          value: grafana.hosteaching.ovh
        - name: GF_SERVER_PROTOCOL
          value: http
        - name: GF_SERVER_ROOT_URL
          value: https://grafana.hosteaching.ovh
        - name: GF_USERS_ALLOW_SIGN_UP
          value: "false"
        - name: GF_USERS_AUTO_ASSIGN_ORG
          value: "true"
        - name: GF_USERS_AUTO_ASSIGN_ORG_ROLE
          value: Admin
        image: bitnami/grafana:7.0.6-debian-10-r3
        imagePullPolicy: IfNotPresent
        livenessProbe:
          initialDelaySeconds: 60
          successThreshold: 1
          tcpSocket:
            port: dashboard
        name: grafana
        ports:
        - containerPort: 3000
          name: dashboard
        readinessProbe:
          initialDelaySeconds: 30
          successThreshold: 2
          tcpSocket:
            port: dashboard
        resources:
          limits:
            cpu: 100m
            memory: 100Mi
          requests:
            cpu: 100m
            memory: 100Mi
        stdin: false
        tty: false
        volumeMounts:
        - mountPath: /opt/bitnami/grafana/conf/provisioning/dashboards/dashboards_provider.yml
          name: dashboards-provider
          readOnly: true
          subPath: dashboards_provider.yml
        - mountPath: /opt/bitnami/grafana/data
          name: datadir
        - mountPath: /opt/bitnami/grafana/conf/provisioning/datasources/bkpr.yml
          name: datasources
          readOnly: true
          subPath: bkpr.yml
        - mountPath: /opt/bitnami/grafana/conf/provisioning/dashboards/kubernetes
          name: kubernetes-dashboards
          readOnly: true
      imagePullSecrets: []
      initContainers: []
      securityContext:
        fsGroup: 1001
      terminationGracePeriodSeconds: 30
      volumes:
      - configMap:
          name: grafana-dashboards-configuration-b7cab55
        name: dashboards-provider
      - configMap:
          name: grafana-datasource-configuration-30ac8c3
        name: datasources
      - configMap:
          name: grafana-kubernetes-dashboards-5bbac4b
        name: kubernetes-dashboards
  updateStrategy:
    rollingUpdate:
      partition: 0
    type: RollingUpdate
  volumeClaimTemplates:
  - metadata:
      labels:
        name: datadir
      name: datadir
    spec:
      accessModes:
      - ReadWriteOnce
      storageClassName: "rook-cephfs"
      resources:
        requests:
          storage: 1Gi
---
apiVersion: networking.k8s.io/v1beta1
kind: Ingress
metadata:
  annotations:
    kubernetes.io/ingress.class: nginx
    kubernetes.io/tls-acme: "true"
    nginx.ingress.kubernetes.io/auth-response-headers: X-Auth-Request-User, X-Auth-Request-Email
    nginx.ingress.kubernetes.io/auth-signin: https://auth.hosteaching.ovh/oauth2/start?rd=%2F$server_name$escaped_request_uri
    nginx.ingress.kubernetes.io/auth-url: https://auth.hosteaching.ovh/oauth2/auth
  labels:
    name: grafana
  name: grafana
  namespace: kubeprod
spec:
  rules:
  - host: grafana.hosteaching.ovh
    http:
      paths:
      - backend:
          serviceName: grafana
          servicePort: 3000
        path: /
  tls:
  - hosts:
    - grafana.hosteaching.ovh
    secretName: grafana-tls
---
apiVersion: rbac.authorization.k8s.io/v1beta1
kind: RoleBinding
metadata:
  annotations: {}
  labels:
    name: nginx-ingress-controller
  name: nginx-ingress-controller
  namespace: kubeprod
roleRef:
  apiGroup: rbac.authorization.k8s.io
  kind: Role
  name: nginx-ingress-controller
subjects:
- kind: ServiceAccount
  name: nginx-ingress-controller
  namespace: kubeprod
---
apiVersion: policy/v1beta1
kind: PodDisruptionBudget
metadata:
  annotations: {}
  labels:
    name: nginx-ingress-controller
  name: nginx-ingress-controller
  namespace: kubeprod
spec:
  minAvailable: 1
  selector:
    matchLabels:
      name: nginx-ingress-controller
---
apiVersion: v1
kind: Service
metadata:
  annotations: {}
  labels:
    name: nginx-ingress
  name: nginx-ingress
  namespace: kubeprod
spec:
  externalTrafficPolicy: Local
  ports:
  - name: http
    port: 80
    protocol: TCP
  - name: https
    port: 443
    protocol: TCP
  selector:
    name: nginx-ingress-controller
  type: LoadBalancer
---
apiVersion: v1
data: {}
kind: ConfigMap
metadata:
  annotations: {}
  labels:
    name: tcp-services
  name: tcp-services-67c1890
  namespace: kubeprod
---
apiVersion: apps/v1
kind: Deployment
metadata:
  annotations: {}
  labels:
    name: nginx-ingress-controller
  name: nginx-ingress-controller
  namespace: kubeprod
spec:
  minReadySeconds: 30
  replicas: 2
  revisionHistoryLimit: 10
  selector:
    matchLabels:
      name: nginx-ingress-controller
  strategy:
    rollingUpdate:
      maxSurge: 25%
      maxUnavailable: 25%
    type: RollingUpdate
  template:
    metadata:
      annotations:
        prometheus.io/path: /metrics
        prometheus.io/port: "10254"
        prometheus.io/scrape: "true"
      labels:
        name: nginx-ingress-controller
    spec:
      affinity:
        podAntiAffinity:
          preferredDuringSchedulingIgnoredDuringExecution:
          - podAffinityTerm:
              labelSelector:
                matchLabels:
                  name: nginx-ingress-controller
              topologyKey: kubernetes.io/hostname
            weight: 70
          - podAffinityTerm:
              labelSelector:
                matchLabels:
                  name: nginx-ingress-controller
              topologyKey: failure-domain.beta.kubernetes.io/zone
            weight: 70
          - podAffinityTerm:
              labelSelector:
                matchLabels:
                  name: nginx-ingress-controller
              topologyKey: failure-domain.beta.kubernetes.io/region
            weight: 70
      containers:
      - args:
        - --configmap=kubeprod/nginx-ingress-0ff949c
        - --ingress-class=nginx
        - --publish-service=kubeprod/nginx-ingress
        - --tcp-services-configmap=kubeprod/tcp-services-67c1890
        - --udp-services-configmap=kubeprod/udp-services-de038c0
        env:
        - name: POD_NAME
          valueFrom:
            fieldRef:
              apiVersion: v1
              fieldPath: metadata.name
        - name: POD_NAMESPACE
          valueFrom:
            fieldRef:
              apiVersion: v1
              fieldPath: metadata.namespace
        image: bitnami/nginx-ingress-controller:0.33.0-debian-10-r3
        imagePullPolicy: IfNotPresent
        livenessProbe:
          failureThreshold: 3
          httpGet:
            path: /healthz
            port: 10254
            scheme: HTTP
          initialDelaySeconds: 10
          periodSeconds: 10
          successThreshold: 1
          timeoutSeconds: 1
        name: nginx
        ports:
        - containerPort: 80
          name: http
        - containerPort: 443
          name: https
        readinessProbe:
          failureThreshold: 3
          httpGet:
            path: /healthz
            port: 10254
            scheme: HTTP
          periodSeconds: 10
          successThreshold: 1
          timeoutSeconds: 1
        resources:
          requests:
            cpu: 100m
        securityContext:
          capabilities:
            add:
            - NET_BIND_SERVICE
            drop:
            - ALL
          runAsUser: 1001
        stdin: false
        tty: false
        volumeMounts: []
      imagePullSecrets: []
      initContainers: []
      serviceAccountName: nginx-ingress-controller
      terminationGracePeriodSeconds: 60
      volumes: []
---
apiVersion: autoscaling/v1
kind: HorizontalPodAutoscaler
metadata:
  annotations: {}
  labels:
    name: nginx-ingress-controller
  name: nginx-ingress-controller
  namespace: kubeprod
spec:
  maxReplicas: 10
  minReplicas: 2
  scaleTargetRef:
    apiVersion: apps/v1
    kind: Deployment
    name: nginx-ingress-controller
---
apiVersion: rbac.authorization.k8s.io/v1beta1
kind: ClusterRoleBinding
metadata:
  annotations: {}
  labels:
    name: nginx-ingress-controller
  name: nginx-ingress-controller
roleRef:
  apiGroup: rbac.authorization.k8s.io
  kind: ClusterRole
  name: nginx-ingress-controller
subjects:
- kind: ServiceAccount
  name: nginx-ingress-controller
  namespace: kubeprod
---
apiVersion: v1
kind: ServiceAccount
metadata:
  annotations: {}
  labels:
    name: nginx-ingress-controller
  name: nginx-ingress-controller
  namespace: kubeprod
---
apiVersion: v1
data:
  "53": kubeprod/powerdns:53
kind: ConfigMap
metadata:
  annotations: {}
  labels:
    name: udp-services
  name: udp-services-de038c0
  namespace: kubeprod
---
apiVersion: v1
kind: Service
metadata:
  annotations: {}
  labels:
    name: nginx-ingress-udp
  name: nginx-ingress-udp
  namespace: kubeprod
spec:
  externalTrafficPolicy: Cluster
  ports:
  - name: dns-udp
    port: 53
    protocol: UDP
  selector:
    name: nginx-ingress-controller
  type: LoadBalancer
---
apiVersion: v1
data:
  disable-ipv6: "false"
  enable-vts-status: "true"
  hsts: "true"
  http2-max-field-size: 16k
  http2-max-header-size: 64k
  large-client-header-buffers: 8 32k
  no-auth-locations: /.well-known/acme-challenge,/oauth2
  proxy-buffer-size: 32k
  proxy-connect-timeout: "15"
kind: ConfigMap
metadata:
  annotations: {}
  labels:
    name: nginx-ingress
  name: nginx-ingress-0ff949c
  namespace: kubeprod
---
apiVersion: rbac.authorization.k8s.io/v1beta1
kind: ClusterRole
metadata:
  annotations: {}
  labels:
    name: nginx-ingress-controller
  name: nginx-ingress-controller
rules:
- apiGroups:
  - ""
  resources:
  - configmaps
  - endpoints
  - nodes
  - pods
  - secrets
  verbs:
  - list
  - watch
- apiGroups:
  - ""
  resources:
  - nodes
  verbs:
  - get
- apiGroups:
  - ""
  resources:
  - services
  verbs:
  - get
  - list
  - update
  - watch
- apiGroups:
  - extensions
  resources:
  - ingresses
  verbs:
  - get
  - list
  - watch
- apiGroups:
  - extensions
  resources:
  - ingresses/status
  verbs:
  - update
- apiGroups:
  - networking.k8s.io
  resources:
  - ingresses
  verbs:
  - get
  - list
  - watch
- apiGroups:
  - networking.k8s.io
  resources:
  - ingresses/status
  verbs:
  - update
- apiGroups:
  - ""
  resources:
  - events
  verbs:
  - create
  - patch
---
apiVersion: rbac.authorization.k8s.io/v1beta1
kind: Role
metadata:
  annotations: {}
  labels:
    name: nginx-ingress-controller
  name: nginx-ingress-controller
  namespace: kubeprod
rules:
- apiGroups:
  - ""
  resources:
  - namespaces
  verbs:
  - get
- apiGroups:
  - ""
  resources:
  - configmaps
  - endpoints
  - pods
  - secrets
  verbs:
  - get
  - list
  - watch
- apiGroups:
  - ""
  resources:
  - services
  verbs:
  - get
  - list
  - update
  - watch
- apiGroups:
  - extensions
  - networking.k8s.io
  resources:
  - ingresses
  verbs:
  - get
  - list
  - watch
- apiGroups:
  - ""
  resources:
  - configmaps
  verbs:
  - create
- apiGroups:
  - ""
  resources:
  - endpoints
  verbs:
  - create
  - get
  - update
- apiGroups:
  - ""
  resources:
  - events
  verbs:
  - create
  - patch
- apiGroups:
  - extensions
  - networking.k8s.io
  resources:
  - ingresses/status
  verbs:
  - update
- apiGroups:
  - ""
  resourceNames:
  - ingress-controller-leader-nginx
  resources:
  - configmaps
  verbs:
  - get
  - update
---
apiVersion: v1
data:
  release: v1.6.1
kind: ConfigMap
metadata:
  annotations: {}
  labels:
    name: release
  name: release
  namespace: kubeprod
---
apiVersion: rbac.authorization.k8s.io/v1beta1
kind: Role
metadata:
  annotations: {}
  labels:
    name: release-reader
  name: release-reader
  namespace: kubeprod
rules:
- apiGroups:
  - ""
  resourceNames:
  - release
  resources:
  - configmap
  verbs:
  - get
  - list
  - watch
---
apiVersion: rbac.authorization.k8s.io/v1beta1
kind: RoleBinding
metadata:
  annotations: {}
  labels:
    name: release-read-public
  name: release-read-public
  namespace: kubeprod
roleRef:
  apiGroup: rbac.authorization.k8s.io
  kind: Role
  name: release-reader
subjects:
- apiGroup: rbac.authorization.k8s.io
  kind: Group
  name: system:authenticated
---
apiVersion: v1
data:
  api_key: M2ZkODhlNzItYzlmNS00MzFlLWI0N2EtMGVjNDhiYjFhZGRh
  db_password: c2xrbEI4aUtGaThUeHlzeDVERWpjYy94TWRsNFN1Z0Q=
  pdns.conf: ZGFlbW9uPW5vCmNhY2hlLXR0bD02MApjb25maWctZGlyPS9ldGMvcGRucwpkZWZhdWx0LXR0bD0zMDAKZGlzYWJsZS1heGZyPW5vCmRpc2FibGUtc3lzbG9nPXllcwpkaXN0cmlidXRvci10aHJlYWRzPTEKZG5zdXBkYXRlPWZhbHNlCmd1YXJkaWFuPXllcwpsb2NhbC1hZGRyZXNzPTAuMC4wLjAKbG9jYWwtcG9ydD01Mwpsb2dsZXZlbD0zCm1hc3Rlcj15ZXMKbmVncXVlcnktY2FjaGUtdHRsPTYwCnNldGdpZD1wZG5zCnNldHVpZD1wZG5zCnNvYS1leHBpcmUtZGVmYXVsdD0zMDAKc29hLW1pbmltdW0tdHRsPTMwMApzb2EtcmVmcmVzaC1kZWZhdWx0PTMwMApzb2EtcmV0cnktZGVmYXVsdD0zMDAKc29ja2V0LWRpcj0vdmFyL3J1bgp0Y3AtY29udHJvbC1hZGRyZXNzPTAuMC4wLjAKdGNwLWNvbnRyb2wtcG9ydD01MzAwMAp0Y3AtY29udHJvbC1yYW5nZT0xMjcuMC4wLjAvOCwxMC4wLjAuMC84LDE3Mi4xNi4wLjAvMTIsMTkyLjE2OC4wLjAvMTYKdmVyc2lvbi1zdHJpbmc9cG93ZXJkbnMKCmFwaT10cnVlCmFwaS1rZXk9Cgp3ZWJzZXJ2ZXI9eWVzCndlYnNlcnZlci1wb3J0PTgwODEKd2Vic2VydmVyLWFkZHJlc3M9MC4wLjAuMAp3ZWJzZXJ2ZXItYWxsb3ctZnJvbT0wLjAuMC4wLzAKCmxhdW5jaD1nbXlzcWwKZ215c3FsLWhvc3Q9bWFyaWFkYi1nYWxlcmEua3ViZXByb2Quc3ZjCmdteXNxbC1wb3J0PTMzMDYKZ215c3FsLXVzZXI9cG93ZXJkbnMKZ215c3FsLXBhc3N3b3JkPXNsa2xCOGlLRmk4VHh5c3g1REVqY2MveE1kbDRTdWdECmdteXNxbC1kYm5hbWU9cG93ZXJkbnMKZ215c3FsLWRuc3NlYz1ubwo=
kind: Secret
metadata:
  annotations: {}
  labels:
    name: powerdns
  name: powerdns-77ede1a
  namespace: kubeprod
type: Opaque
---
apiVersion: v1
kind: Service
metadata:
  annotations: {}
  labels:
    name: powerdns
  name: powerdns
  namespace: kubeprod
spec:
  ports:
  - name: api
    port: 8081
    protocol: TCP
  - name: dns-tcp
    port: 53
    protocol: TCP
  - name: dns-udp
    port: 53
    protocol: UDP
  selector:
    name: powerdns
  type: ClusterIP
---
apiVersion: apps/v1
kind: Deployment
metadata:
  annotations: {}
  labels:
    name: powerdns
  name: powerdns
  namespace: kubeprod
spec:
  minReadySeconds: 30
  replicas: 2
  revisionHistoryLimit: 10
  selector:
    matchLabels:
      name: powerdns
  strategy:
    rollingUpdate:
      maxSurge: 25%
      maxUnavailable: 25%
    type: RollingUpdate
  template:
    metadata:
      annotations: {}
      labels:
        name: powerdns
    spec:
      containers:
      - args:
        - --api-key=$(POWERDNS_API_KEY)
        - --slave=yes
        command:
        - /scripts/powerdns.sh
        env:
        - name: POWERDNS_API_KEY
          valueFrom:
            secretKeyRef:
              key: api_key
              name: powerdns-77ede1a
        image: psitrax/powerdns:v4.2.0
        imagePullPolicy: IfNotPresent
        livenessProbe:
          httpGet:
            path: /
            port: api
        name: pdns
        ports:
        - containerPort: 8081
          name: api
          protocol: TCP
        - containerPort: 53
          name: dns-tcp
          protocol: TCP
        - containerPort: 53
          name: dns-udp
          protocol: UDP
        readinessProbe:
          httpGet:
            path: /
            port: api
        securityContext:
          runAsUser: 0
        stdin: false
        tty: false
        volumeMounts:
        - mountPath: /scripts
          name: scripts
          readOnly: true
        - mountPath: /etc/pdns/pdns.conf
          name: secret
          readOnly: true
          subPath: pdns.conf
      imagePullSecrets: []
      initContainers:
      - args: []
        command:
        - /scripts/setup-db.sh
        env:
        - name: POWERDNS_DB_DATABASE
          value: powerdns
        - name: POWERDNS_DB_HOST
          value: mariadb-galera.kubeprod.svc
        - name: POWERDNS_DB_PASSWORD
          valueFrom:
            secretKeyRef:
              key: db_password
              name: powerdns-77ede1a
        - name: POWERDNS_DB_PORT
          value: "3306"
        - name: POWERDNS_DB_ROOT_USER
          value: root
        - name: POWERDNS_DB_USER
          value: powerdns
        - name: POWERDNS_DN_ROOT_PASSWORD
          valueFrom:
            secretKeyRef:
              key: root_password
              name: mariadb-galera-dc69b99
        image: bitnami/mariadb-galera:10.5.4-debian-10-r2
        imagePullPolicy: IfNotPresent
        name: setup-db
        ports: []
        stdin: false
        tty: false
        volumeMounts:
        - mountPath: /schema/schema.sql
          name: schema
          readOnly: true
          subPath: schema.sql
        - mountPath: /scripts
          name: scripts
          readOnly: true
      terminationGracePeriodSeconds: 30
      volumes:
      - configMap:
          name: powerdns-7560389
        name: schema
      - configMap:
          defaultMode: 493
          name: powerdns-sh-f727feb
        name: scripts
      - name: secret
        secret:
          secretName: powerdns-77ede1a
---
apiVersion: v1
kind: Service
metadata:
  annotations:
    prometheus.io/port: "9104"
    prometheus.io/scrape: "true"
  labels:
    name: mariadb-galera
  name: mariadb-galera
  namespace: kubeprod
spec:
  ports:
  - name: mysql
    port: 3306
    protocol: TCP
  - name: metrics
    port: 9104
    protocol: TCP
  selector:
    name: mariadb-galera
  type: ClusterIP
---
apiVersion: v1
data:
  my.cnf: |
    [client]
    port=3306
    socket=/opt/bitnami/mariadb/tmp/mysql.sock
    plugin_dir=/opt/bitnami/mariadb/plugin

    [mysqld]
    default-storage-engine=InnoDB
    basedir=/opt/bitnami/mariadb
    datadir=/bitnami/mariadb/data
    plugin_dir=/opt/bitnami/mariadb/plugin
    tmpdir=/opt/bitnami/mariadb/tmp
    socket=/opt/bitnami/mariadb/tmp/mysql.sock
    pid-file=/opt/bitnami/mariadb/tmp/mysqld.pid
    bind-address=0.0.0.0

    ## Character set
    collation-server=utf8_unicode_ci
    init-connect='SET NAMES utf8'
    character-set-server=utf8

    ## MyISAM
    key-buffer-size=32M
    myisam-recover-options=FORCE,BACKUP

    ## safety
    skip-host-cache
    skip-name-resolve
    max-allowed-packet=16M
    max-connect-errors=1000000
    sql-mode=STRICT_TRANS_TABLES,ERROR_FOR_DIVISION_BY_ZERO,NO_AUTO_CREATE_USER,NO_AUTO_VALUE_ON_ZERO,NO_ENGINE_SUBSTITUTION,NO_ZERO_DATE,NO_ZERO_IN_DATE,ONLY_FULL_GROUP_BY
    sysdate-is-now=1
    innodb=FORCE
    innodb-strict-mode=1
    innodb_file_per_table=1

    # Mandatory per https://github.com/codership/documentation/issues/25
    innodb-autoinc-lock-mode=2

    # Per https://www.percona.com/blog/2006/08/04/innodb-double-write/
    innodb-doublewrite=1

    # Not fully ACID compliant, up to 1sec transaction loss in the event of total cluster failure (across both regions)
    # Enabled for performance per https://mariadb.com/kb/en/mariadb/getting-started-with-mariadb-galera-cluster/
    innodb_flush_log_at_trx_commit=0

    ## binary logging
    log-bin=mysql-bin
    expire-logs-days=14

    # Disabling for performance per http://severalnines.com/blog/9-tips-going-production-galera-cluster-mysql
    sync-binlog=0

    # Required for Galera
    binlog-format=row

    ## Caches and limits
    tmp-table-size=32M
    max-heap-table-size=32M

    # Re-enabling as now works with Maria 10.1.2
    query-cache-type=1
    query-cache-limit=4M
    query-cache-size=256M
    max-connections=500
    thread-cache-size=50
    open-files-limit=65535
    table-definition-cache=4096
    table-open-cache=4096

    ## innodb
    innodb-flush-method=O_DIRECT
    innodb-log-files-in-group=2
    innodb-log-file-size=128M
    innodb-flush-log-at-trx-commit=1
    innodb-file-per-table=1

    # 80% Memory is default reco.
    # Need to re-evaluate when DB size grows
    innodb-buffer-pool-size=2G
    innodb_file_format=Barracuda

    ## logging
    log_warnings=2
    log-queries-not-using-indexes=1
    slow-query-log=1

    [galera]
    wsrep_on=ON
    wsrep_provider=/opt/bitnami/mariadb/lib/libgalera_smm.so
    wsrep_sst_method=mariabackup
    wsrep_slave_threads=4
    wsrep_cluster_address=gcomm://
    wsrep_cluster_name=galera
    wsrep_sst_auth="root:"
    innodb-flush-log-at-trx-commit=2
    wsrep_replicate_myisam=ON

    [mariadb]
    plugin_load_add=auth_pam
kind: ConfigMap
metadata:
  annotations: {}
  labels:
    name: mariadb-galera
  name: mariadb-galera-ece316e
  namespace: kubeprod
---
apiVersion: v1
kind: Service
metadata:
  annotations: {}
  labels:
    name: mariadb-galera-headless
  name: mariadb-galera-headless
  namespace: kubeprod
spec:
  clusterIP: None
  ports:
  - name: galera
    port: 4567
    protocol: TCP
  - name: ist
    port: 4568
    protocol: TCP
  - name: sst
    port: 4444
    protocol: TCP
  selector:
    name: mariadb-galera
  type: ClusterIP
---
apiVersion: rbac.authorization.k8s.io/v1beta1
kind: Role
metadata:
  annotations: {}
  labels:
    name: mariadb-galera
  name: mariadb-galera
  namespace: kubeprod
rules:
- apiGroups:
  - ""
  resources:
  - endpoints
  verbs:
  - get
---
apiVersion: rbac.authorization.k8s.io/v1beta1
kind: RoleBinding
metadata:
  annotations: {}
  labels:
    name: mariadb-galera
  name: mariadb-galera
  namespace: kubeprod
roleRef:
  apiGroup: rbac.authorization.k8s.io
  kind: Role
  name: mariadb-galera
subjects:
- kind: ServiceAccount
  name: mariadb-galera
  namespace: kubeprod
---
apiVersion: v1
kind: ServiceAccount
metadata:
  annotations: {}
  labels:
    name: mariadb-galera
  name: mariadb-galera
  namespace: kubeprod
---
apiVersion: v1
data:
  mariabackup_password: cWxhZlhrYjZYd0h1MEpFRG5hbi9RZ3lxM3ptV3Zlbng=
  root_password: TXM1RjJ4R3NsQXpsWjZtZ3JUY1Nod0ZucklwRWNEcTc=
kind: Secret
metadata:
  annotations: {}
  labels:
    name: mariadb-galera
  name: mariadb-galera-dc69b99
  namespace: kubeprod
type: Opaque
---
apiVersion: apps/v1
kind: StatefulSet
metadata:
  annotations: {}
  labels:
    name: mariadb-galera
  name: mariadb-galera
  namespace: kubeprod
spec:
  replicas: 3
  selector:
    matchLabels:
      name: mariadb-galera
  serviceName: mariadb-galera
  template:
    metadata:
      annotations: {}
      labels:
        name: mariadb-galera
    spec:
      affinity:
        podAntiAffinity:
          preferredDuringSchedulingIgnoredDuringExecution:
          - podAffinityTerm:
              labelSelector:
                matchLabels:
                  name: mariadb-galera
              topologyKey: kubernetes.io/hostname
            weight: 70
          - podAffinityTerm:
              labelSelector:
                matchLabels:
                  name: mariadb-galera
              topologyKey: failure-domain.beta.kubernetes.io/zone
            weight: 70
          - podAffinityTerm:
              labelSelector:
                matchLabels:
                  name: mariadb-galera
              topologyKey: failure-domain.beta.kubernetes.io/region
            weight: 70
      containers:
      - args: []
        env:
        - name: MARIADB_GALERA_CLUSTER_ADDRESS
          value: gcomm://mariadb-galera-headless.kubeprod.svc
        - name: MARIADB_GALERA_CLUSTER_NAME
          value: galera
        - name: MARIADB_GALERA_MARIABACKUP_PASSWORD
          valueFrom:
            secretKeyRef:
              key: mariabackup_password
              name: mariadb-galera-dc69b99
        - name: MARIADB_GALERA_MARIABACKUP_USER
          value: mariabackup
        - name: MARIADB_ROOT_PASSWORD
          valueFrom:
            secretKeyRef:
              key: root_password
              name: mariadb-galera-dc69b99
        image: bitnami/mariadb-galera:10.5.4-debian-10-r2
        imagePullPolicy: IfNotPresent
        livenessProbe:
          exec:
            command:
            - /bin/bash
            - -ec
            - |
              exec mysqladmin status -uroot -p$MARIADB_ROOT_PASSWORD
          failureThreshold: 3
          initialDelaySeconds: 120
          periodSeconds: 10
          successThreshold: 1
          timeoutSeconds: 1
        name: mariadb-galera
        ports:
        - containerPort: 4567
          name: galera
        - containerPort: 4568
          name: ist
        - containerPort: 3306
          name: mysql
        - containerPort: 4444
          name: sst
        readinessProbe:
          exec:
            command:
            - /bin/bash
            - -ec
            - |
              exec mysqladmin status -uroot -p$MARIADB_ROOT_PASSWORD
          failureThreshold: 3
          initialDelaySeconds: 30
          periodSeconds: 10
          successThreshold: 1
          timeoutSeconds: 1
        stdin: false
        tty: false
        volumeMounts:
        - mountPath: /opt/bitnami/mariadb/conf/my.cnf
          name: config
          readOnly: true
          subPath: my.cnf
        - mountPath: /bitnami/mariadb
          name: data
      - args: []
        command:
        - sh
        - -c
        - |
          DATA_SOURCE_NAME="root:$MARIADB_ROOT_PASSWORD@(localhost:3306)/" /bin/mysqld_exporter
        env:
        - name: MARIADB_ROOT_PASSWORD
          valueFrom:
            secretKeyRef:
              key: root_password
              name: mariadb-galera-dc69b99
        image: bitnami/mysqld-exporter:0.12.1-debian-10-r86
        imagePullPolicy: IfNotPresent
        livenessProbe:
          httpGet:
            path: /metrics
            port: metrics
          initialDelaySeconds: 30
          timeoutSeconds: 5
        name: metrics
        ports:
        - containerPort: 9104
          name: metrics
        readinessProbe:
          httpGet:
            path: /metrics
            port: metrics
          initialDelaySeconds: 5
          timeoutSeconds: 1
        resources:
          limits:
            cpu: 100m
            memory: 512Mi
          requests:
            cpu: 100m
            memory: 512Mi
        stdin: false
        tty: false
        volumeMounts: []
      imagePullSecrets: []
      initContainers: []
      securityContext:
        fsGroup: 1001
        runAsUser: 1001
      serviceAccountName: mariadb-galera
      terminationGracePeriodSeconds: 30
      volumes:
      - configMap:
          name: mariadb-galera-ece316e
        name: config
  updateStrategy:
    type: RollingUpdate
  volumeClaimTemplates:
  - metadata:
      labels:
        name: data
      name: data
    spec:
      accessModes:
      - ReadWriteOnce
      storageClassName: "rook-cephfs"
      resources:
        requests:
          storage: 10Gi
---
apiVersion: networking.k8s.io/v1beta1
kind: Ingress
metadata:
  annotations:
    kubernetes.io/ingress.class: nginx
    kubernetes.io/tls-acme: "true"
    nginx.ingress.kubernetes.io/auth-response-headers: X-Auth-Request-User, X-Auth-Request-Email
    nginx.ingress.kubernetes.io/auth-signin: https://auth.hosteaching.ovh/oauth2/start?rd=%2F$server_name$escaped_request_uri
    nginx.ingress.kubernetes.io/auth-url: https://auth.hosteaching.ovh/oauth2/auth
  labels:
    name: powerdns
  name: powerdns
  namespace: kubeprod
spec:
  rules:
  - host: pdns.hosteaching.ovh
    http:
      paths:
      - backend:
          serviceName: powerdns
          servicePort: 8081
        path: /
  tls:
  - hosts:
    - pdns.hosteaching.ovh
    secretName: powerdns-tls
---
apiVersion: v1
data:
  schema.sql: |
    CREATE TABLE domains (
      id                    INT AUTO_INCREMENT,
      name                  VARCHAR(255) NOT NULL,
      master                VARCHAR(128) DEFAULT NULL,
      last_check            INT DEFAULT NULL,
      type                  VARCHAR(6) NOT NULL,
      notified_serial       INT UNSIGNED DEFAULT NULL,
      account               VARCHAR(40) CHARACTER SET 'utf8' DEFAULT NULL,
      PRIMARY KEY (id)
    ) Engine=InnoDB CHARACTER SET 'latin1';

    CREATE UNIQUE INDEX name_index ON domains(name);


    CREATE TABLE records (
      id                    BIGINT AUTO_INCREMENT,
      domain_id             INT DEFAULT NULL,
      name                  VARCHAR(255) DEFAULT NULL,
      type                  VARCHAR(10) DEFAULT NULL,
      content               VARCHAR(64000) DEFAULT NULL,
      ttl                   INT DEFAULT NULL,
      prio                  INT DEFAULT NULL,
      disabled              TINYINT(1) DEFAULT 0,
      ordername             VARCHAR(255) BINARY DEFAULT NULL,
      auth                  TINYINT(1) DEFAULT 1,
      PRIMARY KEY (id)
    ) Engine=InnoDB CHARACTER SET 'latin1';

    CREATE INDEX nametype_index ON records(name,type);
    CREATE INDEX domain_id ON records(domain_id);
    CREATE INDEX ordername ON records (ordername);


    CREATE TABLE supermasters (
      ip                    VARCHAR(64) NOT NULL,
      nameserver            VARCHAR(255) NOT NULL,
      account               VARCHAR(40) CHARACTER SET 'utf8' NOT NULL,
      PRIMARY KEY (ip, nameserver)
    ) Engine=InnoDB CHARACTER SET 'latin1';


    CREATE TABLE comments (
      id                    INT AUTO_INCREMENT,
      domain_id             INT NOT NULL,
      name                  VARCHAR(255) NOT NULL,
      type                  VARCHAR(10) NOT NULL,
      modified_at           INT NOT NULL,
      account               VARCHAR(40) CHARACTER SET 'utf8' DEFAULT NULL,
      comment               TEXT CHARACTER SET 'utf8' NOT NULL,
      PRIMARY KEY (id)
    ) Engine=InnoDB CHARACTER SET 'latin1';

    CREATE INDEX comments_name_type_idx ON comments (name, type);
    CREATE INDEX comments_order_idx ON comments (domain_id, modified_at);


    CREATE TABLE domainmetadata (
      id                    INT AUTO_INCREMENT,
      domain_id             INT NOT NULL,
      kind                  VARCHAR(32),
      content               TEXT,
      PRIMARY KEY (id)
    ) Engine=InnoDB CHARACTER SET 'latin1';

    CREATE INDEX domainmetadata_idx ON domainmetadata (domain_id, kind);


    CREATE TABLE cryptokeys (
      id                    INT AUTO_INCREMENT,
      domain_id             INT NOT NULL,
      flags                 INT NOT NULL,
      active                BOOL,
      content               TEXT,
      PRIMARY KEY(id)
    ) Engine=InnoDB CHARACTER SET 'latin1';

    CREATE INDEX domainidindex ON cryptokeys(domain_id);


    CREATE TABLE tsigkeys (
      id                    INT AUTO_INCREMENT,
      name                  VARCHAR(255),
      algorithm             VARCHAR(50),
      secret                VARCHAR(255),
      PRIMARY KEY (id)
    ) Engine=InnoDB CHARACTER SET 'latin1';

    CREATE UNIQUE INDEX namealgoindex ON tsigkeys(name, algorithm);
kind: ConfigMap
metadata:
  annotations: {}
  labels:
    name: powerdns
  name: powerdns-7560389
  namespace: kubeprod
---
apiVersion: v1
data:
  powerdns.sh: |
    #!/usr/bin/env sh

    set -o errexit
    set -o nounset

    ZONE=hosteaching.ovh
    if ! pdnsutil list-zone $ZONE; then
      pdnsutil create-zone $ZONE ns1.$ZONE
    fi

    /usr/sbin/pdns_server "$@"
  setup-db.sh: |
    #!/usr/bin/env sh

    set -o errexit
    set -o nounset

    # wait for mariadb-galera server
    mysqladmin status -h${POWERDNS_DB_HOST} -P${POWERDNS_DB_PORT} -u${POWERDNS_DB_ROOT_USER} -p${POWERDNS_DN_ROOT_PASSWORD}

    echo "Creating database for PowerDNS..."
    mysql -h${POWERDNS_DB_HOST} -P${POWERDNS_DB_PORT} -u${POWERDNS_DB_ROOT_USER} -p${POWERDNS_DN_ROOT_PASSWORD} -e "CREATE DATABASE IF NOT EXISTS \`${POWERDNS_DB_DATABASE}\` DEFAULT CHARACTER SET \`utf8\` COLLATE \`utf8_unicode_ci\`;"

    echo "Creating user for PowerDNS database..."
    mysql -h${POWERDNS_DB_HOST} -P${POWERDNS_DB_PORT} -u${POWERDNS_DB_ROOT_USER} -p${POWERDNS_DN_ROOT_PASSWORD} -e "CREATE USER IF NOT EXISTS '${POWERDNS_DB_USER}'@'%.%.%.%';"
    mysql -h${POWERDNS_DB_HOST} -P${POWERDNS_DB_PORT} -u${POWERDNS_DB_ROOT_USER} -p${POWERDNS_DN_ROOT_PASSWORD} -e "GRANT ALL PRIVILEGES ON \`${POWERDNS_DB_DATABASE}\`.* TO '$POWERDNS_DB_USER'@'%.%.%.%' IDENTIFIED BY '$POWERDNS_DB_PASSWORD';"

    if [ $(mysql -h${POWERDNS_DB_HOST} -P${POWERDNS_DB_PORT} -u${POWERDNS_DB_USER} -p${POWERDNS_DB_PASSWORD} -Nsre "SELECT COUNT(*) FROM information_schema.tables WHERE table_schema = \"${POWERDNS_DB_DATABASE}\";") -le 1 ]; then
      echo "Loading PowerDNS database schema..."
      cat /schema/schema.sql | mysql -h${POWERDNS_DB_HOST} -P${POWERDNS_DB_PORT} -u${POWERDNS_DB_USER} -p${POWERDNS_DB_PASSWORD} ${POWERDNS_DB_DATABASE}
    fi
kind: ConfigMap
metadata:
  annotations: {}
  labels:
    name: powerdns-sh
  name: powerdns-sh-f727feb
  namespace: kubeprod
---
apiVersion: apps/v1
kind: DaemonSet
metadata:
  annotations: {}
  labels:
    name: fluentd-es
  name: fluentd-es
  namespace: kubeprod
spec:
  selector:
    matchLabels:
      name: fluentd-es
  template:
    metadata:
      annotations:
        prometheus.io/path: /metrics
        prometheus.io/port: "24231"
        prometheus.io/scrape: "true"
        scheduler.alpha.kubernetes.io/critical-pod: ""
      labels:
        name: fluentd-es
    spec:
      containers:
      - args:
        - --config=/opt/bitnami/fluentd/conf/fluentd.conf
        - --plugin=/opt/bitnami/fluentd/plugins
        - --log=/opt/bitnami/fluentd/logs/fluentd.log
        - --log-rotate-age=5
        - --log-rotate-size=104857600
        - --no-supervisor
        command:
        - fluentd
        env:
        - name: ES_HOST
          value: elasticsearch-logging.kubeprod.svc
        image: bitnami/fluentd:1.11.1-debian-10-r27
        imagePullPolicy: IfNotPresent
        name: fluentd-es
        ports: []
        resources:
          limits:
            memory: 500Mi
          requests:
            cpu: 100m
            memory: 200Mi
        securityContext:
          runAsUser: 0
        stdin: false
        tty: false
        volumeMounts:
        - mountPath: /opt/bitnami/fluentd/conf
          name: config
          readOnly: true
        - mountPath: /opt/bitnami/fluentd/conf/config.d
          name: configd
          readOnly: true
        - mountPath: /var/lib/docker/containers
          name: varlibdockercontainers
          readOnly: true
        - mountPath: /var/log
          name: varlog
          readOnly: true
        - mountPath: /var/log/fluentd-buffers
          name: varlogbuffers
        - mountPath: /var/log/fluentd-pos
          name: varlogpos
      imagePullSecrets: []
      initContainers: []
      serviceAccountName: fluentd-es
      terminationGracePeriodSeconds: 30
      volumes:
      - configMap:
          name: fluentd-es-30f242f
        name: config
      - configMap:
          name: fluentd-es-configd-cbf6e63
        name: configd
      - hostPath:
          path: /var/lib/docker/containers
          type: Directory
        name: varlibdockercontainers
      - hostPath:
          path: /var/log
          type: Directory
        name: varlog
      - hostPath:
          path: /var/log/fluentd-buffers
          type: DirectoryOrCreate
        name: varlogbuffers
      - hostPath:
          path: /var/log/fluentd-pos
          type: DirectoryOrCreate
        name: varlogpos
  updateStrategy:
    rollingUpdate:
      maxUnavailable: 1
    type: RollingUpdate
---
apiVersion: rbac.authorization.k8s.io/v1beta1
kind: ClusterRoleBinding
metadata:
  annotations: {}
  labels:
    name: fluentd-es
  name: fluentd-es
roleRef:
  apiGroup: rbac.authorization.k8s.io
  kind: ClusterRole
  name: fluentd-es
subjects:
- kind: ServiceAccount
  name: fluentd-es
  namespace: kubeprod
---
apiVersion: rbac.authorization.k8s.io/v1beta1
kind: ClusterRole
metadata:
  annotations: {}
  labels:
    name: fluentd-es
  name: fluentd-es
rules:
- apiGroups:
  - ""
  resources:
  - namespaces
  - pods
  verbs:
  - get
  - watch
  - list
---
apiVersion: v1
data:
  fluentd.conf: |
    # Include config files in the ./config.d directory
    @include config.d/*.conf
kind: ConfigMap
metadata:
  annotations: {}
  labels:
    name: fluentd-es
  name: fluentd-es-30f242f
  namespace: kubeprod
---
apiVersion: v1
data:
  containers.input.conf: |
    # This configuration file for Fluentd / td-agent is used
    # to watch changes to Docker log files. The kubelet creates symlinks that
    # capture the pod name, namespace, container name & Docker container ID
    # to the docker logs for pods in the /var/log/containers directory on the host.
    # If running this fluentd configuration in a Docker container, the /var/log
    # directory should be mounted in the container.
    #
    # These logs are then submitted to Elasticsearch which assumes the
    # installation of the fluent-plugin-elasticsearch & the
    # fluent-plugin-kubernetes_metadata_filter plugins.
    # See https://github.com/uken/fluent-plugin-elasticsearch &
    # https://github.com/fabric8io/fluent-plugin-kubernetes_metadata_filter for
    # more information about the plugins.
    #
    # Example
    # =======
    # A line in the Docker log file might look like this JSON:
    #
    # {"log":"2014/09/25 21:15:03 Got request with path wombat\n",
    #  "stream":"stderr",
    #   "time":"2014-09-25T21:15:03.499185026Z"}
    #
    # The time_format specification below makes sure we properly
    # parse the time format produced by Docker. This will be
    # submitted to Elasticsearch and should appear like:
    # $ curl 'http://elasticsearch-logging:9200/_search?pretty'
    # ...
    # {
    #      "_index" : "logstash-2014.09.25",
    #      "_type" : "fluentd",
    #      "_id" : "VBrbor2QTuGpsQyTCdfzqA",
    #      "_score" : 1.0,
    #      "_source":{"log":"2014/09/25 22:45:50 Got request with path wombat\n",
    #                 "stream":"stderr","tag":"docker.container.all",
    #                 "@timestamp":"2014-09-25T22:45:50+00:00"}
    #    },
    # ...
    #
    # The Kubernetes fluentd plugin is used to write the Kubernetes metadata to the log
    # record & add labels to the log record if properly configured. This enables users
    # to filter & search logs on any metadata.
    # For example a Docker container's logs might be in the directory:
    #
    #  /var/lib/docker/containers/997599971ee6366d4a5920d25b79286ad45ff37a74494f262e3bc98d909d0a7b
    #
    # and in the file:
    #
    #  997599971ee6366d4a5920d25b79286ad45ff37a74494f262e3bc98d909d0a7b-json.log
    #
    # where 997599971ee6... is the Docker ID of the running container.
    # The Kubernetes kubelet makes a symbolic link to this file on the host machine
    # in the /var/log/containers directory which includes the pod name and the Kubernetes
    # container name:
    #
    #    synthetic-logger-0.25lps-pod_default_synth-lgr-997599971ee6366d4a5920d25b79286ad45ff37a74494f262e3bc98d909d0a7b.log
    #    ->
    #    /var/lib/docker/containers/997599971ee6366d4a5920d25b79286ad45ff37a74494f262e3bc98d909d0a7b/997599971ee6366d4a5920d25b79286ad45ff37a74494f262e3bc98d909d0a7b-json.log
    #
    # The /var/log directory on the host is mapped to the /var/log directory in the container
    # running this instance of Fluentd and we end up collecting the file:
    #
    #   /var/log/containers/synthetic-logger-0.25lps-pod_default_synth-lgr-997599971ee6366d4a5920d25b79286ad45ff37a74494f262e3bc98d909d0a7b.log
    #
    # This results in the tag:
    #
    #  var.log.containers.synthetic-logger-0.25lps-pod_default_synth-lgr-997599971ee6366d4a5920d25b79286ad45ff37a74494f262e3bc98d909d0a7b.log
    #
    # The Kubernetes fluentd plugin is used to extract the namespace, pod name & container name
    # which are added to the log message as a kubernetes field object & the Docker container ID
    # is also added under the docker field object.
    # The final tag is:
    #
    #   kubernetes.var.log.containers.synthetic-logger-0.25lps-pod_default_synth-lgr-997599971ee6366d4a5920d25b79286ad45ff37a74494f262e3bc98d909d0a7b.log
    #
    # And the final log record look like:
    #
    # {
    #   "log":"2014/09/25 21:15:03 Got request with path wombat\n",
    #   "stream":"stderr",
    #   "time":"2014-09-25T21:15:03.499185026Z",
    #   "kubernetes": {
    #     "namespace": "default",
    #     "pod_name": "synthetic-logger-0.25lps-pod",
    #     "container_name": "synth-lgr"
    #   },
    #   "docker": {
    #     "container_id": "997599971ee6366d4a5920d25b79286ad45ff37a74494f262e3bc98d909d0a7b"
    #   }
    # }
    #
    # This makes it easier for users to search for logs by pod name or by
    # the name of the Kubernetes container regardless of how many times the
    # Kubernetes pod has been restarted (resulting in a several Docker container IDs).

    # Json Log Example:
    # {"log":"[info:2016-02-16T16:04:05.930-08:00] Some log text here\n","stream":"stdout","time":"2016-02-17T00:04:05.931087621Z"}
    # CRI Log Example:
    # 2016-02-17T00:04:05.931087621Z stdout F [info:2016-02-16T16:04:05.930-08:00] Some log text here
    <source>
      @id fluentd-containers.log
      @type tail
      path /var/log/containers/*.log
      pos_file /var/log/fluentd-pos/es-containers.log.pos
      tag raw.kubernetes.*
      read_from_head true
      <parse>
        @type multi_format
        <pattern>
          format json
          time_key time
          time_format %Y-%m-%dT%H:%M:%S.%NZ
        </pattern>
        <pattern>
          format /^(?<time>.+) (?<stream>stdout|stderr) [^ ]* (?<log>.*)$/
          time_format %Y-%m-%dT%H:%M:%S.%N%:z
        </pattern>
      </parse>
    </source>

    # Detect exceptions in the log output and forward them as one log entry.
    <match raw.kubernetes.**>
      @id raw.kubernetes
      @type detect_exceptions
      remove_tag_prefix raw
      message log
      stream stream
      multiline_flush_interval 5
      max_bytes 500000
      max_lines 1000
    </match>

    # Concatenate multi-line logs
    <filter **>
      @id filter_concat
      @type concat
      key message
      multiline_end_regexp /\n$/
      separator ""
    </filter>

    # Enriches records with Kubernetes metadata
    <filter kubernetes.**>
      @id filter_kubernetes_metadata
      @type kubernetes_metadata
    </filter>
  monitoring.conf: |
    # Prometheus Exporter Plugin
    # input plugin that exports metrics
    <source>
      @id prometheus
      @type prometheus
    </source>

    <source>
      @id monitor_agent
      @type monitor_agent
    </source>

    # input plugin that collects metrics from MonitorAgent
    <source>
      @id prometheus_monitor
      @type prometheus_monitor
      <labels>
        host ${hostname}
      </labels>
    </source>

    # input plugin that collects metrics for output plugin
    <source>
      @id prometheus_output_monitor
      @type prometheus_output_monitor
      <labels>
        host ${hostname}
      </labels>
    </source>

    # input plugin that collects metrics for in_tail plugin
    <source>
      @id prometheus_tail_monitor
      @type prometheus_tail_monitor
      <labels>
        host ${hostname}
      </labels>
    </source>
  output.conf: |
    <match **>
      @id elasticsearch
      @type elasticsearch
      @log_level info
      suppress_type_name true
      include_tag_key true
      host "#{ENV['ES_HOST']}"
      port 9200
      logstash_format true
      <buffer>
        @type file
        path /var/log/fluentd-buffers/kubernetes.system.buffer
        flush_mode interval
        retry_type exponential_backoff
        flush_thread_count 2
        flush_interval 5s
        retry_forever
        retry_max_interval 30
        chunk_limit_size 2M
        total_limit_size 500M
        overflow_action block
      </buffer>
    </match>
  system.conf: |
    <system>
      root_dir /tmp/fluentd-buffers/
    </system>
  system.input.conf: |
    # Example:
    # 2015-12-21 23:17:22,066 [salt.state       ][INFO    ] Completed state [net.ipv4.ip_forward] at time 23:17:22.066081
    <source>
      @id minion
      @type tail
      format /^(?<time>[^ ]* [^ ,]*)[^\[]*\[[^\]]*\]\[(?<severity>[^ \]]*) *\] (?<message>.*)$/
      time_format %Y-%m-%d %H:%M:%S
      path /var/log/salt/minion
      pos_file /var/log/fluentd-pos/salt.pos
      tag salt
    </source>

    # Example:
    # Dec 21 23:17:22 gke-foo-1-1-4b5cbd14-node-4eoj startupscript: Finished running startup script /var/run/google.startup.script
    <source>
      @id startupscript.log
      @type tail
      format syslog
      path /var/log/startupscript.log
      pos_file /var/log/fluentd-pos/es-startupscript.log.pos
      tag startupscript
    </source>

    # Examples:
    # time="2016-02-04T06:51:03.053580605Z" level=info msg="GET /containers/json"
    # time="2016-02-04T07:53:57.505612354Z" level=error msg="HTTP Error" err="No such image: -f" statusCode=404
    # TODO(random-liu): Remove this after cri container runtime rolls out.
    <source>
      @id docker.log
      @type tail
      format /^time="(?<time>[^)]*)" level=(?<severity>[^ ]*) msg="(?<message>[^"]*)"( err="(?<error>[^"]*)")?( statusCode=($<status_code>\d+))?/
      path /var/log/docker.log
      pos_file /var/log/fluentd-pos/es-docker.log.pos
      tag docker
    </source>

    # Example:
    # 2016/02/04 06:52:38 filePurge: successfully removed file /var/etcd/data/member/wal/00000000000006d0-00000000010a23d1.wal
    <source>
      @id etcd.log
      @type tail
      # Not parsing this, because it doesn't have anything particularly useful to
      # parse out of it (like severities).
      format none
      path /var/log/etcd.log
      pos_file /var/log/fluentd-pos/es-etcd.log.pos
      tag etcd
    </source>

    # Multi-line parsing is required for all the kube logs because very large log
    # statements, such as those that include entire object bodies, get split into
    # multiple lines by glog.

    # Example:
    # I0204 07:32:30.020537    3368 server.go:1048] POST /stats/container/: (13.972191ms) 200 [[Go-http-client/1.1] 10.244.1.3:40537]
    <source>
      @id kubelet.log
      @type tail
      format multiline
      multiline_flush_interval 5s
      format_firstline /^\w\d{4}/
      format1 /^(?<severity>\w)(?<time>\d{4} [^\s]*)\s+(?<pid>\d+)\s+(?<source>[^ \]]+)\] (?<message>.*)/
      time_format %m%d %H:%M:%S.%N
      path /var/log/kubelet.log
      pos_file /var/log/fluentd-pos/es-kubelet.log.pos
      tag kubelet
    </source>

    # Example:
    # I1118 21:26:53.975789       6 proxier.go:1096] Port "nodePort for kube-system/default-http-backend:http" (:31429/tcp) was open before and is still needed
    <source>
      @id kube-proxy.log
      @type tail
      format multiline
      multiline_flush_interval 5s
      format_firstline /^\w\d{4}/
      format1 /^(?<severity>\w)(?<time>\d{4} [^\s]*)\s+(?<pid>\d+)\s+(?<source>[^ \]]+)\] (?<message>.*)/
      time_format %m%d %H:%M:%S.%N
      path /var/log/kube-proxy.log
      pos_file /var/log/fluentd-pos/es-kube-proxy.log.pos
      tag kube-proxy
    </source>

    # Example:
    # I0204 07:00:19.604280       5 handlers.go:131] GET /api/v1/nodes: (1.624207ms) 200 [[kube-controller-manager/v1.1.3 (linux/amd64) kubernetes/6a81b50] 127.0.0.1:38266]
    <source>
      @id kube-apiserver.log
      @type tail
      format multiline
      multiline_flush_interval 5s
      format_firstline /^\w\d{4}/
      format1 /^(?<severity>\w)(?<time>\d{4} [^\s]*)\s+(?<pid>\d+)\s+(?<source>[^ \]]+)\] (?<message>.*)/
      time_format %m%d %H:%M:%S.%N
      path /var/log/kube-apiserver.log
      pos_file /var/log/fluentd-pos/es-kube-apiserver.log.pos
      tag kube-apiserver
    </source>

    # Example:
    # I0204 06:55:31.872680       5 servicecontroller.go:277] LB already exists and doesn't need update for service kube-system/kube-ui
    <source>
      @id kube-controller-manager.log
      @type tail
      format multiline
      multiline_flush_interval 5s
      format_firstline /^\w\d{4}/
      format1 /^(?<severity>\w)(?<time>\d{4} [^\s]*)\s+(?<pid>\d+)\s+(?<source>[^ \]]+)\] (?<message>.*)/
      time_format %m%d %H:%M:%S.%N
      path /var/log/kube-controller-manager.log
      pos_file /var/log/fluentd-pos/es-kube-controller-manager.log.pos
      tag kube-controller-manager
    </source>

    # Example:
    # W0204 06:49:18.239674       7 reflector.go:245] pkg/scheduler/factory/factory.go:193: watch of *api.Service ended with: 401: The event in requested index is outdated and cleared (the requested history has been cleared [2578313/2577886]) [2579312]
    <source>
      @id kube-scheduler.log
      @type tail
      format multiline
      multiline_flush_interval 5s
      format_firstline /^\w\d{4}/
      format1 /^(?<severity>\w)(?<time>\d{4} [^\s]*)\s+(?<pid>\d+)\s+(?<source>[^ \]]+)\] (?<message>.*)/
      time_format %m%d %H:%M:%S.%N
      path /var/log/kube-scheduler.log
      pos_file /var/log/fluentd-pos/es-kube-scheduler.log.pos
      tag kube-scheduler
    </source>

    # Example:
    # I0603 15:31:05.793605       6 cluster_manager.go:230] Reading config from path /etc/gce.conf
    <source>
      @id glbc.log
      @type tail
      format multiline
      multiline_flush_interval 5s
      format_firstline /^\w\d{4}/
      format1 /^(?<severity>\w)(?<time>\d{4} [^\s]*)\s+(?<pid>\d+)\s+(?<source>[^ \]]+)\] (?<message>.*)/
      time_format %m%d %H:%M:%S.%N
      path /var/log/glbc.log
      pos_file /var/log/fluentd-pos/es-glbc.log.pos
      tag glbc
    </source>

    # Example:
    # I0603 15:31:05.793605       6 cluster_manager.go:230] Reading config from path /etc/gce.conf
    <source>
      @id cluster-autoscaler.log
      @type tail
      format multiline
      multiline_flush_interval 5s
      format_firstline /^\w\d{4}/
      format1 /^(?<severity>\w)(?<time>\d{4} [^\s]*)\s+(?<pid>\d+)\s+(?<source>[^ \]]+)\] (?<message>.*)/
      time_format %m%d %H:%M:%S.%N
      path /var/log/cluster-autoscaler.log
      pos_file /var/log/fluentd-pos/es-cluster-autoscaler.log.pos
      tag cluster-autoscaler
    </source>

    # Logs from systemd-journal for interesting services.
    # TODO(random-liu): Remove this after cri container runtime rolls out.
    <source>
      @id journald-docker
      @type systemd
      matches [{ "_SYSTEMD_UNIT": "docker.service" }]
      <storage>
        @type local
        persistent true
        path /var/log/fluentd-pos/journald-docker.pos
      </storage>
      read_from_head true
      tag docker
    </source>

    <source>
      @id journald-container-runtime
      @type systemd
      matches [{ "_SYSTEMD_UNIT": "{{ fluentd_container_runtime_service }}.service" }]
      <storage>
        @type local
        persistent true
        path /var/log/fluentd-pos/journald-container-runtime.pos
      </storage>
      read_from_head true
      tag container-runtime
    </source>

    <source>
      @id journald-kubelet
      @type systemd
      matches [{ "_SYSTEMD_UNIT": "kubelet.service" }]
      <storage>
        @type local
        persistent true
        path /var/log/fluentd-pos/journald-kubelet.pos
      </storage>
      read_from_head true
      tag kubelet
    </source>

    <source>
      @id journald-node-problem-detector
      @type systemd
      matches [{ "_SYSTEMD_UNIT": "node-problem-detector.service" }]
      <storage>
        @type local
        persistent true
        path /var/log/fluentd-pos/journald-node-problem-detector.pos
      </storage>
      read_from_head true
      tag node-problem-detector
    </source>

    <source>
      @id kernel
      @type systemd
      matches [{ "_TRANSPORT": "kernel" }]
      <storage>
        @type local
        persistent true
        path /var/log/fluentd-pos/kernel.pos
      </storage>
      <entry>
        fields_strip_underscores true
        fields_lowercase true
      </entry>
      read_from_head true
      tag kernel
    </source>
kind: ConfigMap
metadata:
  annotations: {}
  labels:
    name: fluentd-es-configd
  name: fluentd-es-configd-cbf6e63
  namespace: kubeprod
---
apiVersion: v1
kind: ServiceAccount
metadata:
  annotations: {}
  labels:
    name: fluentd-es
  name: fluentd-es
  namespace: kubeprod
---
apiVersion: v1
kind: Service
metadata:
  annotations: {}
  labels:
    name: mariadb-galera-headless
  name: mariadb-galera-headless
  namespace: kubeprod
spec:
  clusterIP: None
  ports:
  - name: galera
    port: 4567
    protocol: TCP
  - name: ist
    port: 4568
    protocol: TCP
  - name: sst
    port: 4444
    protocol: TCP
  selector:
    name: mariadb-galera
  type: ClusterIP
---
apiVersion: rbac.authorization.k8s.io/v1beta1
kind: Role
metadata:
  annotations: {}
  labels:
    name: mariadb-galera
  name: mariadb-galera
  namespace: kubeprod
rules:
- apiGroups:
  - ""
  resources:
  - endpoints
  verbs:
  - get
---
apiVersion: rbac.authorization.k8s.io/v1beta1
kind: RoleBinding
metadata:
  annotations: {}
  labels:
    name: mariadb-galera
  name: mariadb-galera
  namespace: kubeprod
roleRef:
  apiGroup: rbac.authorization.k8s.io
  kind: Role
  name: mariadb-galera
subjects:
- kind: ServiceAccount
  name: mariadb-galera
  namespace: kubeprod
---
apiVersion: v1
kind: ServiceAccount
metadata:
  annotations: {}
  labels:
    name: mariadb-galera
  name: mariadb-galera
  namespace: kubeprod
---
apiVersion: v1
data:
  mariabackup_password: cWxhZlhrYjZYd0h1MEpFRG5hbi9RZ3lxM3ptV3Zlbng=
  root_password: TXM1RjJ4R3NsQXpsWjZtZ3JUY1Nod0ZucklwRWNEcTc=
kind: Secret
metadata:
  annotations: {}
  labels:
    name: mariadb-galera
  name: mariadb-galera-dc69b99
  namespace: kubeprod
type: Opaque
---
apiVersion: apps/v1
kind: StatefulSet
metadata:
  annotations: {}
  labels:
    name: mariadb-galera
  name: mariadb-galera
  namespace: kubeprod
spec:
  replicas: 3
  selector:
    matchLabels:
      name: mariadb-galera
  serviceName: mariadb-galera
  template:
    metadata:
      annotations: {}
      labels:
        name: mariadb-galera
    spec:
      affinity:
        podAntiAffinity:
          preferredDuringSchedulingIgnoredDuringExecution:
          - podAffinityTerm:
              labelSelector:
                matchLabels:
                  name: mariadb-galera
              topologyKey: kubernetes.io/hostname
            weight: 70
          - podAffinityTerm:
              labelSelector:
                matchLabels:
                  name: mariadb-galera
              topologyKey: failure-domain.beta.kubernetes.io/zone
            weight: 70
          - podAffinityTerm:
              labelSelector:
                matchLabels:
                  name: mariadb-galera
              topologyKey: failure-domain.beta.kubernetes.io/region
            weight: 70
      containers:
      - args: []
        env:
        - name: MARIADB_GALERA_CLUSTER_ADDRESS
          value: gcomm://mariadb-galera-headless.kubeprod.svc
        - name: MARIADB_GALERA_CLUSTER_NAME
          value: galera
        - name: MARIADB_GALERA_MARIABACKUP_PASSWORD
          valueFrom:
            secretKeyRef:
              key: mariabackup_password
              name: mariadb-galera-dc69b99
        - name: MARIADB_GALERA_MARIABACKUP_USER
          value: mariabackup
        - name: MARIADB_ROOT_PASSWORD
          valueFrom:
            secretKeyRef:
              key: root_password
              name: mariadb-galera-dc69b99
        image: bitnami/mariadb-galera:10.5.4-debian-10-r2
        imagePullPolicy: IfNotPresent
        livenessProbe:
          exec:
            command:
            - /bin/bash
            - -ec
            - |
              exec mysqladmin status -uroot -p$MARIADB_ROOT_PASSWORD
          failureThreshold: 3
          initialDelaySeconds: 120
          periodSeconds: 10
          successThreshold: 1
          timeoutSeconds: 1
        name: mariadb-galera
        ports:
        - containerPort: 4567
          name: galera
        - containerPort: 4568
          name: ist
        - containerPort: 3306
          name: mysql
        - containerPort: 4444
          name: sst
        readinessProbe:
          exec:
            command:
            - /bin/bash
            - -ec
            - |
              exec mysqladmin status -uroot -p$MARIADB_ROOT_PASSWORD
          failureThreshold: 3
          initialDelaySeconds: 30
          periodSeconds: 10
          successThreshold: 1
          timeoutSeconds: 1
        stdin: false
        tty: false
        volumeMounts:
        - mountPath: /opt/bitnami/mariadb/conf/my.cnf
          name: config
          readOnly: true
          subPath: my.cnf
        - mountPath: /bitnami/mariadb
          name: data
      - args: []
        command:
        - sh
        - -c
        - |
          DATA_SOURCE_NAME="root:$MARIADB_ROOT_PASSWORD@(localhost:3306)/" /bin/mysqld_exporter
        env:
        - name: MARIADB_ROOT_PASSWORD
          valueFrom:
            secretKeyRef:
              key: root_password
              name: mariadb-galera-dc69b99
        image: bitnami/mysqld-exporter:0.12.1-debian-10-r86
        imagePullPolicy: IfNotPresent
        livenessProbe:
          httpGet:
            path: /metrics
            port: metrics
          initialDelaySeconds: 30
          timeoutSeconds: 5
        name: metrics
        ports:
        - containerPort: 9104
          name: metrics
        readinessProbe:
          httpGet:
            path: /metrics
            port: metrics
          initialDelaySeconds: 5
          timeoutSeconds: 1
        resources:
          limits:
            cpu: 100m
            memory: 512Mi
          requests:
            cpu: 100m
            memory: 512Mi
        stdin: false
        tty: false
        volumeMounts: []
      imagePullSecrets: []
      initContainers: []
      securityContext:
        fsGroup: 1001
        runAsUser: 1001
      serviceAccountName: mariadb-galera
      terminationGracePeriodSeconds: 30
      volumes:
      - configMap:
          name: mariadb-galera-ece316e
        name: config
  updateStrategy:
    type: RollingUpdate
  volumeClaimTemplates:
  - metadata:
      labels:
        name: data
      name: data
    spec:
      accessModes:
      - ReadWriteOnce
      storageClassName: "rook-cephfs"
      resources:
        requests:
          storage: 10Gi
---
apiVersion: v1
kind: Service
metadata:
  annotations:
    prometheus.io/port: "9104"
    prometheus.io/scrape: "true"
  labels:
    name: mariadb-galera
  name: mariadb-galera
  namespace: kubeprod
spec:
  ports:
  - name: mysql
    port: 3306
    protocol: TCP
  - name: metrics
    port: 9104
    protocol: TCP
  selector:
    name: mariadb-galera
  type: ClusterIP
---
apiVersion: v1
data:
  my.cnf: |
    [client]
    port=3306
    socket=/opt/bitnami/mariadb/tmp/mysql.sock
    plugin_dir=/opt/bitnami/mariadb/plugin

    [mysqld]
    default-storage-engine=InnoDB
    basedir=/opt/bitnami/mariadb
    datadir=/bitnami/mariadb/data
    plugin_dir=/opt/bitnami/mariadb/plugin
    tmpdir=/opt/bitnami/mariadb/tmp
    socket=/opt/bitnami/mariadb/tmp/mysql.sock
    pid-file=/opt/bitnami/mariadb/tmp/mysqld.pid
    bind-address=0.0.0.0

    ## Character set
    collation-server=utf8_unicode_ci
    init-connect='SET NAMES utf8'
    character-set-server=utf8

    ## MyISAM
    key-buffer-size=32M
    myisam-recover-options=FORCE,BACKUP

    ## safety
    skip-host-cache
    skip-name-resolve
    max-allowed-packet=16M
    max-connect-errors=1000000
    sql-mode=STRICT_TRANS_TABLES,ERROR_FOR_DIVISION_BY_ZERO,NO_AUTO_CREATE_USER,NO_AUTO_VALUE_ON_ZERO,NO_ENGINE_SUBSTITUTION,NO_ZERO_DATE,NO_ZERO_IN_DATE,ONLY_FULL_GROUP_BY
    sysdate-is-now=1
    innodb=FORCE
    innodb-strict-mode=1
    innodb_file_per_table=1

    # Mandatory per https://github.com/codership/documentation/issues/25
    innodb-autoinc-lock-mode=2

    # Per https://www.percona.com/blog/2006/08/04/innodb-double-write/
    innodb-doublewrite=1

    # Not fully ACID compliant, up to 1sec transaction loss in the event of total cluster failure (across both regions)
    # Enabled for performance per https://mariadb.com/kb/en/mariadb/getting-started-with-mariadb-galera-cluster/
    innodb_flush_log_at_trx_commit=0

    ## binary logging
    log-bin=mysql-bin
    expire-logs-days=14

    # Disabling for performance per http://severalnines.com/blog/9-tips-going-production-galera-cluster-mysql
    sync-binlog=0

    # Required for Galera
    binlog-format=row

    ## Caches and limits
    tmp-table-size=32M
    max-heap-table-size=32M

    # Re-enabling as now works with Maria 10.1.2
    query-cache-type=1
    query-cache-limit=4M
    query-cache-size=256M
    max-connections=500
    thread-cache-size=50
    open-files-limit=65535
    table-definition-cache=4096
    table-open-cache=4096

    ## innodb
    innodb-flush-method=O_DIRECT
    innodb-log-files-in-group=2
    innodb-log-file-size=128M
    innodb-flush-log-at-trx-commit=1
    innodb-file-per-table=1

    # 80% Memory is default reco.
    # Need to re-evaluate when DB size grows
    innodb-buffer-pool-size=2G
    innodb_file_format=Barracuda

    ## logging
    log_warnings=2
    log-queries-not-using-indexes=1
    slow-query-log=1

    [galera]
    wsrep_on=ON
    wsrep_provider=/opt/bitnami/mariadb/lib/libgalera_smm.so
    wsrep_sst_method=mariabackup
    wsrep_slave_threads=4
    wsrep_cluster_address=gcomm://
    wsrep_cluster_name=galera
    wsrep_sst_auth="root:"
    innodb-flush-log-at-trx-commit=2
    wsrep_replicate_myisam=ON

    [mariadb]
    plugin_load_add=auth_pam
kind: ConfigMap
metadata:
  annotations: {}
  labels:
    name: mariadb-galera
  name: mariadb-galera-ece316e
  namespace: kubeprod
---
apiVersion: networking.k8s.io/v1beta1
kind: Ingress
metadata:
  annotations:
    kubernetes.io/ingress.class: nginx
    kubernetes.io/tls-acme: "true"
  labels:
    name: keycloak
  name: keycloak
  namespace: kubeprod
spec:
  rules:
  - host: id.hosteaching.ovh
    http:
      paths:
      - backend:
          serviceName: keycloak
          servicePort: 8080
        path: /
  tls:
  - hosts:
    - id.hosteaching.ovh
    secretName: keycloak-tls
---
apiVersion: v1
data:
  setup-db.sh: |
    #!/usr/bin/env sh

    set -o errexit
    set -o nounset

    # wait for mariadb-galera server
    mysqladmin status -h${KEYCLOAK_DB_HOST} -P${KEYCLOAK_DB_PORT} -u${KEYCLOAK_DB_ROOT_USER} -p${KEYCLOAK_DB_ROOT_PASSWORD}

    echo "Creating database for Keycloak..."
    mysql -h${KEYCLOAK_DB_HOST} -P${KEYCLOAK_DB_PORT} -u${KEYCLOAK_DB_ROOT_USER} -p${KEYCLOAK_DB_ROOT_PASSWORD} -e "CREATE DATABASE IF NOT EXISTS \`${KEYCLOAK_DB_DATABASE}\` DEFAULT CHARACTER SET \`utf8\` COLLATE \`utf8_unicode_ci\`;"

    echo "Creating user for Keycloak database..."
    mysql -h${KEYCLOAK_DB_HOST} -P${KEYCLOAK_DB_PORT} -u${KEYCLOAK_DB_ROOT_USER} -p${KEYCLOAK_DB_ROOT_PASSWORD} -e "CREATE USER IF NOT EXISTS '${KEYCLOAK_DB_USER}'@'%.%.%.%';"
    mysql -h${KEYCLOAK_DB_HOST} -P${KEYCLOAK_DB_PORT} -u${KEYCLOAK_DB_ROOT_USER} -p${KEYCLOAK_DB_ROOT_PASSWORD} -e "GRANT ALL PRIVILEGES ON \`${KEYCLOAK_DB_DATABASE}\`.* TO '$KEYCLOAK_DB_USER'@'%.%.%.%' IDENTIFIED BY '$KEYCLOAK_DB_PASSWORD';"
kind: ConfigMap
metadata:
  annotations: {}
  labels:
    name: keycloak-sh
  name: keycloak-sh-1dedc24
  namespace: kubeprod
---
apiVersion: v1
data:
  admin_password: c2VjcmV0cGFzc3dvcmQ=
  bkpr-realm.json: ewogICJpZCI6ICJCS1BSIiwKICAicmVhbG0iOiAiQktQUiIsCiAgIm5vdEJlZm9yZSI6IDAsCiAgInJldm9rZVJlZnJlc2hUb2tlbiI6IGZhbHNlLAogICJyZWZyZXNoVG9rZW5NYXhSZXVzZSI6IDAsCiAgImFjY2Vzc1Rva2VuTGlmZXNwYW4iOiAzMDAsCiAgImFjY2Vzc1Rva2VuTGlmZXNwYW5Gb3JJbXBsaWNpdEZsb3ciOiA5MDAsCiAgInNzb1Nlc3Npb25JZGxlVGltZW91dCI6IDE4MDAsCiAgInNzb1Nlc3Npb25NYXhMaWZlc3BhbiI6IDM2MDAwLAogICJzc29TZXNzaW9uSWRsZVRpbWVvdXRSZW1lbWJlck1lIjogMCwKICAic3NvU2Vzc2lvbk1heExpZmVzcGFuUmVtZW1iZXJNZSI6IDAsCiAgIm9mZmxpbmVTZXNzaW9uSWRsZVRpbWVvdXQiOiAyNTkyMDAwLAogICJvZmZsaW5lU2Vzc2lvbk1heExpZmVzcGFuRW5hYmxlZCI6IGZhbHNlLAogICJvZmZsaW5lU2Vzc2lvbk1heExpZmVzcGFuIjogNTE4NDAwMCwKICAiYWNjZXNzQ29kZUxpZmVzcGFuIjogNjAsCiAgImFjY2Vzc0NvZGVMaWZlc3BhblVzZXJBY3Rpb24iOiAzMDAsCiAgImFjY2Vzc0NvZGVMaWZlc3BhbkxvZ2luIjogMTgwMCwKICAiYWN0aW9uVG9rZW5HZW5lcmF0ZWRCeUFkbWluTGlmZXNwYW4iOiA0MzIwMCwKICAiYWN0aW9uVG9rZW5HZW5lcmF0ZWRCeVVzZXJMaWZlc3BhbiI6IDMwMCwKICAiZW5hYmxlZCI6IHRydWUsCiAgInNzbFJlcXVpcmVkIjogImV4dGVybmFsIiwKICAicmVnaXN0cmF0aW9uQWxsb3dlZCI6IGZhbHNlLAogICJyZWdpc3RyYXRpb25FbWFpbEFzVXNlcm5hbWUiOiBmYWxzZSwKICAicmVtZW1iZXJNZSI6IGZhbHNlLAogICJ2ZXJpZnlFbWFpbCI6IGZhbHNlLAogICJsb2dpbldpdGhFbWFpbEFsbG93ZWQiOiB0cnVlLAogICJkdXBsaWNhdGVFbWFpbHNBbGxvd2VkIjogZmFsc2UsCiAgInJlc2V0UGFzc3dvcmRBbGxvd2VkIjogZmFsc2UsCiAgImVkaXRVc2VybmFtZUFsbG93ZWQiOiBmYWxzZSwKICAiYnJ1dGVGb3JjZVByb3RlY3RlZCI6IGZhbHNlLAogICJwZXJtYW5lbnRMb2Nrb3V0IjogZmFsc2UsCiAgIm1heEZhaWx1cmVXYWl0U2Vjb25kcyI6IDkwMCwKICAibWluaW11bVF1aWNrTG9naW5XYWl0U2Vjb25kcyI6IDYwLAogICJ3YWl0SW5jcmVtZW50U2Vjb25kcyI6IDYwLAogICJxdWlja0xvZ2luQ2hlY2tNaWxsaVNlY29uZHMiOiAxMDAwLAogICJtYXhEZWx0YVRpbWVTZWNvbmRzIjogNDMyMDAsCiAgImZhaWx1cmVGYWN0b3IiOiAzMCwKICAiZGVmYXVsdFJvbGVzIjogWwogICAgIm9mZmxpbmVfYWNjZXNzIiwKICAgICJ1bWFfYXV0aG9yaXphdGlvbiIKICBdLAogICJyZXF1aXJlZENyZWRlbnRpYWxzIjogWwogICAgInBhc3N3b3JkIgogIF0sCiAgIm90cFBvbGljeVR5cGUiOiAidG90cCIsCiAgIm90cFBvbGljeUFsZ29yaXRobSI6ICJIbWFjU0hBMSIsCiAgIm90cFBvbGljeUluaXRpYWxDb3VudGVyIjogMCwKICAib3RwUG9saWN5RGlnaXRzIjogNiwKICAib3RwUG9saWN5TG9va0FoZWFkV2luZG93IjogMSwKICAib3RwUG9saWN5UGVyaW9kIjogMzAsCiAgIm90cFN1cHBvcnRlZEFwcGxpY2F0aW9ucyI6IFsKICAgICJGcmVlT1RQIiwKICAgICJHb29nbGUgQXV0aGVudGljYXRvciIKICBdLAogICJ3ZWJBdXRoblBvbGljeVJwRW50aXR5TmFtZSI6ICJrZXljbG9hayIsCiAgIndlYkF1dGhuUG9saWN5U2lnbmF0dXJlQWxnb3JpdGhtcyI6IFsKICAgICJFUzI1NiIKICBdLAogICJ3ZWJBdXRoblBvbGljeVJwSWQiOiAiIiwKICAid2ViQXV0aG5Qb2xpY3lBdHRlc3RhdGlvbkNvbnZleWFuY2VQcmVmZXJlbmNlIjogIm5vdCBzcGVjaWZpZWQiLAogICJ3ZWJBdXRoblBvbGljeUF1dGhlbnRpY2F0b3JBdHRhY2htZW50IjogIm5vdCBzcGVjaWZpZWQiLAogICJ3ZWJBdXRoblBvbGljeVJlcXVpcmVSZXNpZGVudEtleSI6ICJub3Qgc3BlY2lmaWVkIiwKICAid2ViQXV0aG5Qb2xpY3lVc2VyVmVyaWZpY2F0aW9uUmVxdWlyZW1lbnQiOiAibm90IHNwZWNpZmllZCIsCiAgIndlYkF1dGhuUG9saWN5Q3JlYXRlVGltZW91dCI6IDAsCiAgIndlYkF1dGhuUG9saWN5QXZvaWRTYW1lQXV0aGVudGljYXRvclJlZ2lzdGVyIjogZmFsc2UsCiAgIndlYkF1dGhuUG9saWN5QWNjZXB0YWJsZUFhZ3VpZHMiOiBbXSwKICAic2NvcGVNYXBwaW5ncyI6IFsKICAgIHsKICAgICAgImNsaWVudFNjb3BlIjogIm9mZmxpbmVfYWNjZXNzIiwKICAgICAgInJvbGVzIjogWwogICAgICAgICJvZmZsaW5lX2FjY2VzcyIKICAgICAgXQogICAgfQogIF0sCiAgImNsaWVudHMiOiBbCiAgICB7CiAgICAgICJpZCI6ICIwYjhiYzRhYi1jMjEzLTRlODgtYWI2OC02MDY3M2ViZDUwNDUiLAogICAgICAiY2xpZW50SWQiOiAiYmtwciIsCiAgICAgICJzdXJyb2dhdGVBdXRoUmVxdWlyZWQiOiBmYWxzZSwKICAgICAgImVuYWJsZWQiOiB0cnVlLAogICAgICAiY2xpZW50QXV0aGVudGljYXRvclR5cGUiOiAiY2xpZW50LXNlY3JldCIsCiAgICAgICJzZWNyZXQiOiAiNmU5ZDRhNDMtMDc5OS00ZTE1LWI5NmQtYWRkN2I4NDJiZDRlIiwKICAgICAgInJlZGlyZWN0VXJpcyI6IFsKICAgICAgICAiaHR0cHM6Ly9hdXRoLmhvc3RlYWNoaW5nLm92aC9vYXV0aDIvY2FsbGJhY2siCiAgICAgIF0sCiAgICAgICJ3ZWJPcmlnaW5zIjogWwogICAgICAgICIqIgogICAgICBdLAogICAgICAibm90QmVmb3JlIjogMCwKICAgICAgImJlYXJlck9ubHkiOiBmYWxzZSwKICAgICAgImNvbnNlbnRSZXF1aXJlZCI6IGZhbHNlLAogICAgICAic3RhbmRhcmRGbG93RW5hYmxlZCI6IHRydWUsCiAgICAgICJpbXBsaWNpdEZsb3dFbmFibGVkIjogZmFsc2UsCiAgICAgICJkaXJlY3RBY2Nlc3NHcmFudHNFbmFibGVkIjogdHJ1ZSwKICAgICAgInNlcnZpY2VBY2NvdW50c0VuYWJsZWQiOiBmYWxzZSwKICAgICAgInB1YmxpY0NsaWVudCI6IGZhbHNlLAogICAgICAiZnJvbnRjaGFubmVsTG9nb3V0IjogZmFsc2UsCiAgICAgICJwcm90b2NvbCI6ICJvcGVuaWQtY29ubmVjdCIsCiAgICAgICJhdHRyaWJ1dGVzIjogewogICAgICAgICJzYW1sLmFzc2VydGlvbi5zaWduYXR1cmUiOiAiZmFsc2UiLAogICAgICAgICJzYW1sLmZvcmNlLnBvc3QuYmluZGluZyI6ICJmYWxzZSIsCiAgICAgICAgInNhbWwubXVsdGl2YWx1ZWQucm9sZXMiOiAiZmFsc2UiLAogICAgICAgICJzYW1sLmVuY3J5cHQiOiAiZmFsc2UiLAogICAgICAgICJzYW1sLnNlcnZlci5zaWduYXR1cmUiOiAiZmFsc2UiLAogICAgICAgICJzYW1sLnNlcnZlci5zaWduYXR1cmUua2V5aW5mby5leHQiOiAiZmFsc2UiLAogICAgICAgICJleGNsdWRlLnNlc3Npb24uc3RhdGUuZnJvbS5hdXRoLnJlc3BvbnNlIjogImZhbHNlIiwKICAgICAgICAic2FtbF9mb3JjZV9uYW1lX2lkX2Zvcm1hdCI6ICJmYWxzZSIsCiAgICAgICAgInNhbWwuY2xpZW50LnNpZ25hdHVyZSI6ICJmYWxzZSIsCiAgICAgICAgInRscy5jbGllbnQuY2VydGlmaWNhdGUuYm91bmQuYWNjZXNzLnRva2VucyI6ICJmYWxzZSIsCiAgICAgICAgInNhbWwuYXV0aG5zdGF0ZW1lbnQiOiAiZmFsc2UiLAogICAgICAgICJkaXNwbGF5Lm9uLmNvbnNlbnQuc2NyZWVuIjogImZhbHNlIiwKICAgICAgICAic2FtbC5vbmV0aW1ldXNlLmNvbmRpdGlvbiI6ICJmYWxzZSIKICAgICAgfSwKICAgICAgImF1dGhlbnRpY2F0aW9uRmxvd0JpbmRpbmdPdmVycmlkZXMiOiB7fSwKICAgICAgImZ1bGxTY29wZUFsbG93ZWQiOiB0cnVlLAogICAgICAibm9kZVJlUmVnaXN0cmF0aW9uVGltZW91dCI6IC0xLAogICAgICAicHJvdG9jb2xNYXBwZXJzIjogWwogICAgICAgIHsKICAgICAgICAgICJpZCI6ICJjM2JiOTIxOC04Yzc5LTQzYzYtOWZkNi05NjFjODkxZTU5YzciLAogICAgICAgICAgIm5hbWUiOiAiZ3JvdXBzIiwKICAgICAgICAgICJwcm90b2NvbCI6ICJvcGVuaWQtY29ubmVjdCIsCiAgICAgICAgICAicHJvdG9jb2xNYXBwZXIiOiAib2lkYy11c2VybW9kZWwtcmVhbG0tcm9sZS1tYXBwZXIiLAogICAgICAgICAgImNvbnNlbnRSZXF1aXJlZCI6IGZhbHNlLAogICAgICAgICAgImNvbmZpZyI6IHsKICAgICAgICAgICAgIm11bHRpdmFsdWVkIjogInRydWUiLAogICAgICAgICAgICAidXNlci5hdHRyaWJ1dGUiOiAiZm9vIiwKICAgICAgICAgICAgImlkLnRva2VuLmNsYWltIjogInRydWUiLAogICAgICAgICAgICAiYWNjZXNzLnRva2VuLmNsYWltIjogInRydWUiLAogICAgICAgICAgICAiY2xhaW0ubmFtZSI6ICJncm91cHMiLAogICAgICAgICAgICAianNvblR5cGUubGFiZWwiOiAiU3RyaW5nIgogICAgICAgICAgfQogICAgICAgIH0sCiAgICAgICAgewogICAgICAgICAgImlkIjogIjM5ZTNkNWZlLWRkNGMtNDQwNi1hOGY5LWRhM2JhMDA5MjkyMiIsCiAgICAgICAgICAibmFtZSI6ICJ1c2VybmFtZSIsCiAgICAgICAgICAicHJvdG9jb2wiOiAib3BlbmlkLWNvbm5lY3QiLAogICAgICAgICAgInByb3RvY29sTWFwcGVyIjogIm9pZGMtdXNlcm1vZGVsLXByb3BlcnR5LW1hcHBlciIsCiAgICAgICAgICAiY29uc2VudFJlcXVpcmVkIjogZmFsc2UsCiAgICAgICAgICAiY29uZmlnIjogewogICAgICAgICAgICAidXNlcmluZm8udG9rZW4uY2xhaW0iOiAidHJ1ZSIsCiAgICAgICAgICAgICJ1c2VyLmF0dHJpYnV0ZSI6ICJ1c2VybmFtZSIsCiAgICAgICAgICAgICJpZC50b2tlbi5jbGFpbSI6ICJ0cnVlIiwKICAgICAgICAgICAgImFjY2Vzcy50b2tlbi5jbGFpbSI6ICJ0cnVlIiwKICAgICAgICAgICAgImNsYWltLm5hbWUiOiAicHJlZmVycmVkX3VzZXJuYW1lIiwKICAgICAgICAgICAgImpzb25UeXBlLmxhYmVsIjogIlN0cmluZyIKICAgICAgICAgIH0KICAgICAgICB9LAogICAgICAgIHsKICAgICAgICAgICJpZCI6ICIyNDZkNDUxNS0xM2U3LTRlNTctYWYxNy1hZTI5ODZmMDllYWYiLAogICAgICAgICAgIm5hbWUiOiAiZW1haWwiLAogICAgICAgICAgInByb3RvY29sIjogIm9wZW5pZC1jb25uZWN0IiwKICAgICAgICAgICJwcm90b2NvbE1hcHBlciI6ICJvaWRjLXVzZXJtb2RlbC1wcm9wZXJ0eS1tYXBwZXIiLAogICAgICAgICAgImNvbnNlbnRSZXF1aXJlZCI6IGZhbHNlLAogICAgICAgICAgImNvbmZpZyI6IHsKICAgICAgICAgICAgInVzZXJpbmZvLnRva2VuLmNsYWltIjogInRydWUiLAogICAgICAgICAgICAidXNlci5hdHRyaWJ1dGUiOiAiZW1haWwiLAogICAgICAgICAgICAiaWQudG9rZW4uY2xhaW0iOiAidHJ1ZSIsCiAgICAgICAgICAgICJhY2Nlc3MudG9rZW4uY2xhaW0iOiAidHJ1ZSIsCiAgICAgICAgICAgICJjbGFpbS5uYW1lIjogImVtYWlsIiwKICAgICAgICAgICAgImpzb25UeXBlLmxhYmVsIjogIlN0cmluZyIKICAgICAgICAgIH0KICAgICAgICB9LAogICAgICAgIHsKICAgICAgICAgICJpZCI6ICI0YmVlMzBiYS04OTVjLTRkMTktYWMwNi02MDg3ODkwNmY0OTIiLAogICAgICAgICAgIm5hbWUiOiAiZnVsbCBuYW1lIiwKICAgICAgICAgICJwcm90b2NvbCI6ICJvcGVuaWQtY29ubmVjdCIsCiAgICAgICAgICAicHJvdG9jb2xNYXBwZXIiOiAib2lkYy1mdWxsLW5hbWUtbWFwcGVyIiwKICAgICAgICAgICJjb25zZW50UmVxdWlyZWQiOiBmYWxzZSwKICAgICAgICAgICJjb25maWciOiB7CiAgICAgICAgICAgICJpZC50b2tlbi5jbGFpbSI6ICJ0cnVlIiwKICAgICAgICAgICAgImFjY2Vzcy50b2tlbi5jbGFpbSI6ICJ0cnVlIiwKICAgICAgICAgICAgInVzZXJpbmZvLnRva2VuLmNsYWltIjogInRydWUiCiAgICAgICAgICB9CiAgICAgICAgfQogICAgICBdLAogICAgICAiZGVmYXVsdENsaWVudFNjb3BlcyI6IFsKICAgICAgICAid2ViLW9yaWdpbnMiLAogICAgICAgICJyb2xlX2xpc3QiLAogICAgICAgICJyb2xlcyIsCiAgICAgICAgInByb2ZpbGUiLAogICAgICAgICJlbWFpbCIKICAgICAgXSwKICAgICAgIm9wdGlvbmFsQ2xpZW50U2NvcGVzIjogWwogICAgICAgICJhZGRyZXNzIiwKICAgICAgICAicGhvbmUiLAogICAgICAgICJvZmZsaW5lX2FjY2VzcyIsCiAgICAgICAgIm1pY3JvcHJvZmlsZS1qd3QiCiAgICAgIF0KICAgIH0KICBdLAogICJjbGllbnRTY29wZXMiOiBbCiAgICB7CiAgICAgICJpZCI6ICJhN2NkMDlmMC1lMGRlLTQwY2QtYmM2OC1kMzhlZjFhNzE4ZTIiLAogICAgICAibmFtZSI6ICJhZGRyZXNzIiwKICAgICAgImRlc2NyaXB0aW9uIjogIk9wZW5JRCBDb25uZWN0IGJ1aWx0LWluIHNjb3BlOiBhZGRyZXNzIiwKICAgICAgInByb3RvY29sIjogIm9wZW5pZC1jb25uZWN0IiwKICAgICAgImF0dHJpYnV0ZXMiOiB7CiAgICAgICAgImluY2x1ZGUuaW4udG9rZW4uc2NvcGUiOiAidHJ1ZSIsCiAgICAgICAgImRpc3BsYXkub24uY29uc2VudC5zY3JlZW4iOiAidHJ1ZSIsCiAgICAgICAgImNvbnNlbnQuc2NyZWVuLnRleHQiOiAiJHthZGRyZXNzU2NvcGVDb25zZW50VGV4dH0iCiAgICAgIH0sCiAgICAgICJwcm90b2NvbE1hcHBlcnMiOiBbCiAgICAgICAgewogICAgICAgICAgImlkIjogIjU4YzUyMGMyLWY2MzEtNDY0MS1hNzQ4LTM3MzRmNGE2ZDkzYSIsCiAgICAgICAgICAibmFtZSI6ICJhZGRyZXNzIiwKICAgICAgICAgICJwcm90b2NvbCI6ICJvcGVuaWQtY29ubmVjdCIsCiAgICAgICAgICAicHJvdG9jb2xNYXBwZXIiOiAib2lkYy1hZGRyZXNzLW1hcHBlciIsCiAgICAgICAgICAiY29uc2VudFJlcXVpcmVkIjogZmFsc2UsCiAgICAgICAgICAiY29uZmlnIjogewogICAgICAgICAgICAidXNlci5hdHRyaWJ1dGUuZm9ybWF0dGVkIjogImZvcm1hdHRlZCIsCiAgICAgICAgICAgICJ1c2VyLmF0dHJpYnV0ZS5jb3VudHJ5IjogImNvdW50cnkiLAogICAgICAgICAgICAidXNlci5hdHRyaWJ1dGUucG9zdGFsX2NvZGUiOiAicG9zdGFsX2NvZGUiLAogICAgICAgICAgICAidXNlcmluZm8udG9rZW4uY2xhaW0iOiAidHJ1ZSIsCiAgICAgICAgICAgICJ1c2VyLmF0dHJpYnV0ZS5zdHJlZXQiOiAic3RyZWV0IiwKICAgICAgICAgICAgImlkLnRva2VuLmNsYWltIjogInRydWUiLAogICAgICAgICAgICAidXNlci5hdHRyaWJ1dGUucmVnaW9uIjogInJlZ2lvbiIsCiAgICAgICAgICAgICJhY2Nlc3MudG9rZW4uY2xhaW0iOiAidHJ1ZSIsCiAgICAgICAgICAgICJ1c2VyLmF0dHJpYnV0ZS5sb2NhbGl0eSI6ICJsb2NhbGl0eSIKICAgICAgICAgIH0KICAgICAgICB9CiAgICAgIF0KICAgIH0sCiAgICB7CiAgICAgICJpZCI6ICJjNjc3M2E4YS0zMTNkLTQyYTMtOGE3Yy1jZGRjMWNhNWMyZjYiLAogICAgICAibmFtZSI6ICJlbWFpbCIsCiAgICAgICJkZXNjcmlwdGlvbiI6ICJPcGVuSUQgQ29ubmVjdCBidWlsdC1pbiBzY29wZTogZW1haWwiLAogICAgICAicHJvdG9jb2wiOiAib3BlbmlkLWNvbm5lY3QiLAogICAgICAiYXR0cmlidXRlcyI6IHsKICAgICAgICAiaW5jbHVkZS5pbi50b2tlbi5zY29wZSI6ICJ0cnVlIiwKICAgICAgICAiZGlzcGxheS5vbi5jb25zZW50LnNjcmVlbiI6ICJ0cnVlIiwKICAgICAgICAiY29uc2VudC5zY3JlZW4udGV4dCI6ICIke2VtYWlsU2NvcGVDb25zZW50VGV4dH0iCiAgICAgIH0sCiAgICAgICJwcm90b2NvbE1hcHBlcnMiOiBbCiAgICAgICAgewogICAgICAgICAgImlkIjogIjQ5ZTRmZWM4LWZmOTAtNDgwMS1hZmQ0LTE5YjMwOTY1NDQzOSIsCiAgICAgICAgICAibmFtZSI6ICJlbWFpbCB2ZXJpZmllZCIsCiAgICAgICAgICAicHJvdG9jb2wiOiAib3BlbmlkLWNvbm5lY3QiLAogICAgICAgICAgInByb3RvY29sTWFwcGVyIjogIm9pZGMtdXNlcm1vZGVsLXByb3BlcnR5LW1hcHBlciIsCiAgICAgICAgICAiY29uc2VudFJlcXVpcmVkIjogZmFsc2UsCiAgICAgICAgICAiY29uZmlnIjogewogICAgICAgICAgICAidXNlcmluZm8udG9rZW4uY2xhaW0iOiAidHJ1ZSIsCiAgICAgICAgICAgICJ1c2VyLmF0dHJpYnV0ZSI6ICJlbWFpbFZlcmlmaWVkIiwKICAgICAgICAgICAgImlkLnRva2VuLmNsYWltIjogInRydWUiLAogICAgICAgICAgICAiYWNjZXNzLnRva2VuLmNsYWltIjogInRydWUiLAogICAgICAgICAgICAiY2xhaW0ubmFtZSI6ICJlbWFpbF92ZXJpZmllZCIsCiAgICAgICAgICAgICJqc29uVHlwZS5sYWJlbCI6ICJib29sZWFuIgogICAgICAgICAgfQogICAgICAgIH0sCiAgICAgICAgewogICAgICAgICAgImlkIjogIjY0MTg4Yjc4LTQ1NmYtNDI2Ny1hOTcyLTM1MTYxNGQ2ZGVjNiIsCiAgICAgICAgICAibmFtZSI6ICJlbWFpbCIsCiAgICAgICAgICAicHJvdG9jb2wiOiAib3BlbmlkLWNvbm5lY3QiLAogICAgICAgICAgInByb3RvY29sTWFwcGVyIjogIm9pZGMtdXNlcm1vZGVsLXByb3BlcnR5LW1hcHBlciIsCiAgICAgICAgICAiY29uc2VudFJlcXVpcmVkIjogZmFsc2UsCiAgICAgICAgICAiY29uZmlnIjogewogICAgICAgICAgICAidXNlcmluZm8udG9rZW4uY2xhaW0iOiAidHJ1ZSIsCiAgICAgICAgICAgICJ1c2VyLmF0dHJpYnV0ZSI6ICJlbWFpbCIsCiAgICAgICAgICAgICJpZC50b2tlbi5jbGFpbSI6ICJ0cnVlIiwKICAgICAgICAgICAgImFjY2Vzcy50b2tlbi5jbGFpbSI6ICJ0cnVlIiwKICAgICAgICAgICAgImNsYWltLm5hbWUiOiAiZW1haWwiLAogICAgICAgICAgICAianNvblR5cGUubGFiZWwiOiAiU3RyaW5nIgogICAgICAgICAgfQogICAgICAgIH0KICAgICAgXQogICAgfSwKICAgIHsKICAgICAgImlkIjogIjE1MDA2MDNlLTM1YWItNDhiYS1hMmZmLTdmMDBlOTA4Y2FlMSIsCiAgICAgICJuYW1lIjogIm1pY3JvcHJvZmlsZS1qd3QiLAogICAgICAiZGVzY3JpcHRpb24iOiAiTWljcm9wcm9maWxlIC0gSldUIGJ1aWx0LWluIHNjb3BlIiwKICAgICAgInByb3RvY29sIjogIm9wZW5pZC1jb25uZWN0IiwKICAgICAgImF0dHJpYnV0ZXMiOiB7CiAgICAgICAgImluY2x1ZGUuaW4udG9rZW4uc2NvcGUiOiAidHJ1ZSIsCiAgICAgICAgImRpc3BsYXkub24uY29uc2VudC5zY3JlZW4iOiAiZmFsc2UiCiAgICAgIH0sCiAgICAgICJwcm90b2NvbE1hcHBlcnMiOiBbCiAgICAgICAgewogICAgICAgICAgImlkIjogImQzN2RkYWYwLTYwMzEtNGVmOC1hNzU4LTkxOTk0NDM3NTVmOCIsCiAgICAgICAgICAibmFtZSI6ICJ1cG4iLAogICAgICAgICAgInByb3RvY29sIjogIm9wZW5pZC1jb25uZWN0IiwKICAgICAgICAgICJwcm90b2NvbE1hcHBlciI6ICJvaWRjLXVzZXJtb2RlbC1wcm9wZXJ0eS1tYXBwZXIiLAogICAgICAgICAgImNvbnNlbnRSZXF1aXJlZCI6IGZhbHNlLAogICAgICAgICAgImNvbmZpZyI6IHsKICAgICAgICAgICAgInVzZXJpbmZvLnRva2VuLmNsYWltIjogInRydWUiLAogICAgICAgICAgICAidXNlci5hdHRyaWJ1dGUiOiAidXNlcm5hbWUiLAogICAgICAgICAgICAiaWQudG9rZW4uY2xhaW0iOiAidHJ1ZSIsCiAgICAgICAgICAgICJhY2Nlc3MudG9rZW4uY2xhaW0iOiAidHJ1ZSIsCiAgICAgICAgICAgICJjbGFpbS5uYW1lIjogInVwbiIsCiAgICAgICAgICAgICJqc29uVHlwZS5sYWJlbCI6ICJTdHJpbmciCiAgICAgICAgICB9CiAgICAgICAgfSwKICAgICAgICB7CiAgICAgICAgICAiaWQiOiAiODk4OTg0NTAtMjFlMS00N2MwLWI1ZWMtMjFkY2E3YmRmYjUwIiwKICAgICAgICAgICJuYW1lIjogImdyb3VwcyIsCiAgICAgICAgICAicHJvdG9jb2wiOiAib3BlbmlkLWNvbm5lY3QiLAogICAgICAgICAgInByb3RvY29sTWFwcGVyIjogIm9pZGMtdXNlcm1vZGVsLXJlYWxtLXJvbGUtbWFwcGVyIiwKICAgICAgICAgICJjb25zZW50UmVxdWlyZWQiOiBmYWxzZSwKICAgICAgICAgICJjb25maWciOiB7CiAgICAgICAgICAgICJtdWx0aXZhbHVlZCI6ICJ0cnVlIiwKICAgICAgICAgICAgInVzZXJpbmZvLnRva2VuLmNsYWltIjogInRydWUiLAogICAgICAgICAgICAidXNlci5hdHRyaWJ1dGUiOiAiZm9vIiwKICAgICAgICAgICAgImlkLnRva2VuLmNsYWltIjogInRydWUiLAogICAgICAgICAgICAiYWNjZXNzLnRva2VuLmNsYWltIjogInRydWUiLAogICAgICAgICAgICAiY2xhaW0ubmFtZSI6ICJncm91cHMiLAogICAgICAgICAgICAianNvblR5cGUubGFiZWwiOiAiU3RyaW5nIgogICAgICAgICAgfQogICAgICAgIH0KICAgICAgXQogICAgfSwKICAgIHsKICAgICAgImlkIjogIjVkZGJhMzU4LTNkMGUtNDc4ZC05MTlkLTBlMWZlOTM0NjY2YyIsCiAgICAgICJuYW1lIjogIm9mZmxpbmVfYWNjZXNzIiwKICAgICAgImRlc2NyaXB0aW9uIjogIk9wZW5JRCBDb25uZWN0IGJ1aWx0LWluIHNjb3BlOiBvZmZsaW5lX2FjY2VzcyIsCiAgICAgICJwcm90b2NvbCI6ICJvcGVuaWQtY29ubmVjdCIsCiAgICAgICJhdHRyaWJ1dGVzIjogewogICAgICAgICJjb25zZW50LnNjcmVlbi50ZXh0IjogIiR7b2ZmbGluZUFjY2Vzc1Njb3BlQ29uc2VudFRleHR9IiwKICAgICAgICAiZGlzcGxheS5vbi5jb25zZW50LnNjcmVlbiI6ICJ0cnVlIgogICAgICB9CiAgICB9LAogICAgewogICAgICAiaWQiOiAiM2U2ODUzZmYtMjRmMS00ZmQ4LTgwOTUtNzY5ZTE2ZGRjYjE1IiwKICAgICAgIm5hbWUiOiAicGhvbmUiLAogICAgICAiZGVzY3JpcHRpb24iOiAiT3BlbklEIENvbm5lY3QgYnVpbHQtaW4gc2NvcGU6IHBob25lIiwKICAgICAgInByb3RvY29sIjogIm9wZW5pZC1jb25uZWN0IiwKICAgICAgImF0dHJpYnV0ZXMiOiB7CiAgICAgICAgImluY2x1ZGUuaW4udG9rZW4uc2NvcGUiOiAidHJ1ZSIsCiAgICAgICAgImRpc3BsYXkub24uY29uc2VudC5zY3JlZW4iOiAidHJ1ZSIsCiAgICAgICAgImNvbnNlbnQuc2NyZWVuLnRleHQiOiAiJHtwaG9uZVNjb3BlQ29uc2VudFRleHR9IgogICAgICB9LAogICAgICAicHJvdG9jb2xNYXBwZXJzIjogWwogICAgICAgIHsKICAgICAgICAgICJpZCI6ICJhMDc0NTdiMS0yYzM1LTRhYWQtYjFiOS1jNDA3MmY4YTMyZDciLAogICAgICAgICAgIm5hbWUiOiAicGhvbmUgbnVtYmVyIHZlcmlmaWVkIiwKICAgICAgICAgICJwcm90b2NvbCI6ICJvcGVuaWQtY29ubmVjdCIsCiAgICAgICAgICAicHJvdG9jb2xNYXBwZXIiOiAib2lkYy11c2VybW9kZWwtYXR0cmlidXRlLW1hcHBlciIsCiAgICAgICAgICAiY29uc2VudFJlcXVpcmVkIjogZmFsc2UsCiAgICAgICAgICAiY29uZmlnIjogewogICAgICAgICAgICAidXNlcmluZm8udG9rZW4uY2xhaW0iOiAidHJ1ZSIsCiAgICAgICAgICAgICJ1c2VyLmF0dHJpYnV0ZSI6ICJwaG9uZU51bWJlclZlcmlmaWVkIiwKICAgICAgICAgICAgImlkLnRva2VuLmNsYWltIjogInRydWUiLAogICAgICAgICAgICAiYWNjZXNzLnRva2VuLmNsYWltIjogInRydWUiLAogICAgICAgICAgICAiY2xhaW0ubmFtZSI6ICJwaG9uZV9udW1iZXJfdmVyaWZpZWQiLAogICAgICAgICAgICAianNvblR5cGUubGFiZWwiOiAiYm9vbGVhbiIKICAgICAgICAgIH0KICAgICAgICB9LAogICAgICAgIHsKICAgICAgICAgICJpZCI6ICJhYWM2NjVhZC01NDU3LTQ3MjktYTJjNS0xNTRmMGMzNjc0MTAiLAogICAgICAgICAgIm5hbWUiOiAicGhvbmUgbnVtYmVyIiwKICAgICAgICAgICJwcm90b2NvbCI6ICJvcGVuaWQtY29ubmVjdCIsCiAgICAgICAgICAicHJvdG9jb2xNYXBwZXIiOiAib2lkYy11c2VybW9kZWwtYXR0cmlidXRlLW1hcHBlciIsCiAgICAgICAgICAiY29uc2VudFJlcXVpcmVkIjogZmFsc2UsCiAgICAgICAgICAiY29uZmlnIjogewogICAgICAgICAgICAidXNlcmluZm8udG9rZW4uY2xhaW0iOiAidHJ1ZSIsCiAgICAgICAgICAgICJ1c2VyLmF0dHJpYnV0ZSI6ICJwaG9uZU51bWJlciIsCiAgICAgICAgICAgICJpZC50b2tlbi5jbGFpbSI6ICJ0cnVlIiwKICAgICAgICAgICAgImFjY2Vzcy50b2tlbi5jbGFpbSI6ICJ0cnVlIiwKICAgICAgICAgICAgImNsYWltLm5hbWUiOiAicGhvbmVfbnVtYmVyIiwKICAgICAgICAgICAgImpzb25UeXBlLmxhYmVsIjogIlN0cmluZyIKICAgICAgICAgIH0KICAgICAgICB9CiAgICAgIF0KICAgIH0sCiAgICB7CiAgICAgICJpZCI6ICJjNjBhYjNjMS0yMmRkLTRkMzYtYjY4OS1lNzc2MzcyZDJiOTIiLAogICAgICAibmFtZSI6ICJwcm9maWxlIiwKICAgICAgImRlc2NyaXB0aW9uIjogIk9wZW5JRCBDb25uZWN0IGJ1aWx0LWluIHNjb3BlOiBwcm9maWxlIiwKICAgICAgInByb3RvY29sIjogIm9wZW5pZC1jb25uZWN0IiwKICAgICAgImF0dHJpYnV0ZXMiOiB7CiAgICAgICAgImluY2x1ZGUuaW4udG9rZW4uc2NvcGUiOiAidHJ1ZSIsCiAgICAgICAgImRpc3BsYXkub24uY29uc2VudC5zY3JlZW4iOiAidHJ1ZSIsCiAgICAgICAgImNvbnNlbnQuc2NyZWVuLnRleHQiOiAiJHtwcm9maWxlU2NvcGVDb25zZW50VGV4dH0iCiAgICAgIH0sCiAgICAgICJwcm90b2NvbE1hcHBlcnMiOiBbCiAgICAgICAgewogICAgICAgICAgImlkIjogIjVlYjYxZWFmLTMyYjItNDljZS05MzEyLTkwNWU3M2IzZmNmMSIsCiAgICAgICAgICAibmFtZSI6ICJnZW5kZXIiLAogICAgICAgICAgInByb3RvY29sIjogIm9wZW5pZC1jb25uZWN0IiwKICAgICAgICAgICJwcm90b2NvbE1hcHBlciI6ICJvaWRjLXVzZXJtb2RlbC1hdHRyaWJ1dGUtbWFwcGVyIiwKICAgICAgICAgICJjb25zZW50UmVxdWlyZWQiOiBmYWxzZSwKICAgICAgICAgICJjb25maWciOiB7CiAgICAgICAgICAgICJ1c2VyaW5mby50b2tlbi5jbGFpbSI6ICJ0cnVlIiwKICAgICAgICAgICAgInVzZXIuYXR0cmlidXRlIjogImdlbmRlciIsCiAgICAgICAgICAgICJpZC50b2tlbi5jbGFpbSI6ICJ0cnVlIiwKICAgICAgICAgICAgImFjY2Vzcy50b2tlbi5jbGFpbSI6ICJ0cnVlIiwKICAgICAgICAgICAgImNsYWltLm5hbWUiOiAiZ2VuZGVyIiwKICAgICAgICAgICAgImpzb25UeXBlLmxhYmVsIjogIlN0cmluZyIKICAgICAgICAgIH0KICAgICAgICB9LAogICAgICAgIHsKICAgICAgICAgICJpZCI6ICJlYmQzNGU3My0xNTlkLTQ4ODEtYWEyZC1iODcwYzIwMTUzOGUiLAogICAgICAgICAgIm5hbWUiOiAicHJvZmlsZSIsCiAgICAgICAgICAicHJvdG9jb2wiOiAib3BlbmlkLWNvbm5lY3QiLAogICAgICAgICAgInByb3RvY29sTWFwcGVyIjogIm9pZGMtdXNlcm1vZGVsLWF0dHJpYnV0ZS1tYXBwZXIiLAogICAgICAgICAgImNvbnNlbnRSZXF1aXJlZCI6IGZhbHNlLAogICAgICAgICAgImNvbmZpZyI6IHsKICAgICAgICAgICAgInVzZXJpbmZvLnRva2VuLmNsYWltIjogInRydWUiLAogICAgICAgICAgICAidXNlci5hdHRyaWJ1dGUiOiAicHJvZmlsZSIsCiAgICAgICAgICAgICJpZC50b2tlbi5jbGFpbSI6ICJ0cnVlIiwKICAgICAgICAgICAgImFjY2Vzcy50b2tlbi5jbGFpbSI6ICJ0cnVlIiwKICAgICAgICAgICAgImNsYWltLm5hbWUiOiAicHJvZmlsZSIsCiAgICAgICAgICAgICJqc29uVHlwZS5sYWJlbCI6ICJTdHJpbmciCiAgICAgICAgICB9CiAgICAgICAgfSwKICAgICAgICB7CiAgICAgICAgICAiaWQiOiAiYjAxMTEwZWEtZWFkZC00MmRiLTgzYzctOGUzNzI2ZmRmOWE0IiwKICAgICAgICAgICJuYW1lIjogIndlYnNpdGUiLAogICAgICAgICAgInByb3RvY29sIjogIm9wZW5pZC1jb25uZWN0IiwKICAgICAgICAgICJwcm90b2NvbE1hcHBlciI6ICJvaWRjLXVzZXJtb2RlbC1hdHRyaWJ1dGUtbWFwcGVyIiwKICAgICAgICAgICJjb25zZW50UmVxdWlyZWQiOiBmYWxzZSwKICAgICAgICAgICJjb25maWciOiB7CiAgICAgICAgICAgICJ1c2VyaW5mby50b2tlbi5jbGFpbSI6ICJ0cnVlIiwKICAgICAgICAgICAgInVzZXIuYXR0cmlidXRlIjogIndlYnNpdGUiLAogICAgICAgICAgICAiaWQudG9rZW4uY2xhaW0iOiAidHJ1ZSIsCiAgICAgICAgICAgICJhY2Nlc3MudG9rZW4uY2xhaW0iOiAidHJ1ZSIsCiAgICAgICAgICAgICJjbGFpbS5uYW1lIjogIndlYnNpdGUiLAogICAgICAgICAgICAianNvblR5cGUubGFiZWwiOiAiU3RyaW5nIgogICAgICAgICAgfQogICAgICAgIH0sCiAgICAgICAgewogICAgICAgICAgImlkIjogIjM0MmVhNGY2LWYyNTAtNDM0MC05ODM2LTYxYmFlM2VlOWUzYyIsCiAgICAgICAgICAibmFtZSI6ICJ1cGRhdGVkIGF0IiwKICAgICAgICAgICJwcm90b2NvbCI6ICJvcGVuaWQtY29ubmVjdCIsCiAgICAgICAgICAicHJvdG9jb2xNYXBwZXIiOiAib2lkYy11c2VybW9kZWwtYXR0cmlidXRlLW1hcHBlciIsCiAgICAgICAgICAiY29uc2VudFJlcXVpcmVkIjogZmFsc2UsCiAgICAgICAgICAiY29uZmlnIjogewogICAgICAgICAgICAidXNlcmluZm8udG9rZW4uY2xhaW0iOiAidHJ1ZSIsCiAgICAgICAgICAgICJ1c2VyLmF0dHJpYnV0ZSI6ICJ1cGRhdGVkQXQiLAogICAgICAgICAgICAiaWQudG9rZW4uY2xhaW0iOiAidHJ1ZSIsCiAgICAgICAgICAgICJhY2Nlc3MudG9rZW4uY2xhaW0iOiAidHJ1ZSIsCiAgICAgICAgICAgICJjbGFpbS5uYW1lIjogInVwZGF0ZWRfYXQiLAogICAgICAgICAgICAianNvblR5cGUubGFiZWwiOiAiU3RyaW5nIgogICAgICAgICAgfQogICAgICAgIH0sCiAgICAgICAgewogICAgICAgICAgImlkIjogImNlNDYwYmI5LWQ3MGUtNDY4MC1iNTIxLWYxYTkxMTQ2ZGQ5NiIsCiAgICAgICAgICAibmFtZSI6ICJmdWxsIG5hbWUiLAogICAgICAgICAgInByb3RvY29sIjogIm9wZW5pZC1jb25uZWN0IiwKICAgICAgICAgICJwcm90b2NvbE1hcHBlciI6ICJvaWRjLWZ1bGwtbmFtZS1tYXBwZXIiLAogICAgICAgICAgImNvbnNlbnRSZXF1aXJlZCI6IGZhbHNlLAogICAgICAgICAgImNvbmZpZyI6IHsKICAgICAgICAgICAgImlkLnRva2VuLmNsYWltIjogInRydWUiLAogICAgICAgICAgICAiYWNjZXNzLnRva2VuLmNsYWltIjogInRydWUiLAogICAgICAgICAgICAidXNlcmluZm8udG9rZW4uY2xhaW0iOiAidHJ1ZSIKICAgICAgICAgIH0KICAgICAgICB9LAogICAgICAgIHsKICAgICAgICAgICJpZCI6ICI5ZTkyODkwMS0wNDkyLTRlYTctOWUyOS1kM2VkNTdjOTAxYWMiLAogICAgICAgICAgIm5hbWUiOiAiYmlydGhkYXRlIiwKICAgICAgICAgICJwcm90b2NvbCI6ICJvcGVuaWQtY29ubmVjdCIsCiAgICAgICAgICAicHJvdG9jb2xNYXBwZXIiOiAib2lkYy11c2VybW9kZWwtYXR0cmlidXRlLW1hcHBlciIsCiAgICAgICAgICAiY29uc2VudFJlcXVpcmVkIjogZmFsc2UsCiAgICAgICAgICAiY29uZmlnIjogewogICAgICAgICAgICAidXNlcmluZm8udG9rZW4uY2xhaW0iOiAidHJ1ZSIsCiAgICAgICAgICAgICJ1c2VyLmF0dHJpYnV0ZSI6ICJiaXJ0aGRhdGUiLAogICAgICAgICAgICAiaWQudG9rZW4uY2xhaW0iOiAidHJ1ZSIsCiAgICAgICAgICAgICJhY2Nlc3MudG9rZW4uY2xhaW0iOiAidHJ1ZSIsCiAgICAgICAgICAgICJjbGFpbS5uYW1lIjogImJpcnRoZGF0ZSIsCiAgICAgICAgICAgICJqc29uVHlwZS5sYWJlbCI6ICJTdHJpbmciCiAgICAgICAgICB9CiAgICAgICAgfSwKICAgICAgICB7CiAgICAgICAgICAiaWQiOiAiOTg4MmE5ZjEtMjYxMS00NTE1LThhNjUtNDIwYmI4MmMxMTU2IiwKICAgICAgICAgICJuYW1lIjogInBpY3R1cmUiLAogICAgICAgICAgInByb3RvY29sIjogIm9wZW5pZC1jb25uZWN0IiwKICAgICAgICAgICJwcm90b2NvbE1hcHBlciI6ICJvaWRjLXVzZXJtb2RlbC1hdHRyaWJ1dGUtbWFwcGVyIiwKICAgICAgICAgICJjb25zZW50UmVxdWlyZWQiOiBmYWxzZSwKICAgICAgICAgICJjb25maWciOiB7CiAgICAgICAgICAgICJ1c2VyaW5mby50b2tlbi5jbGFpbSI6ICJ0cnVlIiwKICAgICAgICAgICAgInVzZXIuYXR0cmlidXRlIjogInBpY3R1cmUiLAogICAgICAgICAgICAiaWQudG9rZW4uY2xhaW0iOiAidHJ1ZSIsCiAgICAgICAgICAgICJhY2Nlc3MudG9rZW4uY2xhaW0iOiAidHJ1ZSIsCiAgICAgICAgICAgICJjbGFpbS5uYW1lIjogInBpY3R1cmUiLAogICAgICAgICAgICAianNvblR5cGUubGFiZWwiOiAiU3RyaW5nIgogICAgICAgICAgfQogICAgICAgIH0sCiAgICAgICAgewogICAgICAgICAgImlkIjogImEzYzUyNWU2LWZmMWUtNDdmYS1hMzNjLTJmMjljNmI2MzI4ZCIsCiAgICAgICAgICAibmFtZSI6ICJsb2NhbGUiLAogICAgICAgICAgInByb3RvY29sIjogIm9wZW5pZC1jb25uZWN0IiwKICAgICAgICAgICJwcm90b2NvbE1hcHBlciI6ICJvaWRjLXVzZXJtb2RlbC1hdHRyaWJ1dGUtbWFwcGVyIiwKICAgICAgICAgICJjb25zZW50UmVxdWlyZWQiOiBmYWxzZSwKICAgICAgICAgICJjb25maWciOiB7CiAgICAgICAgICAgICJ1c2VyaW5mby50b2tlbi5jbGFpbSI6ICJ0cnVlIiwKICAgICAgICAgICAgInVzZXIuYXR0cmlidXRlIjogImxvY2FsZSIsCiAgICAgICAgICAgICJpZC50b2tlbi5jbGFpbSI6ICJ0cnVlIiwKICAgICAgICAgICAgImFjY2Vzcy50b2tlbi5jbGFpbSI6ICJ0cnVlIiwKICAgICAgICAgICAgImNsYWltLm5hbWUiOiAibG9jYWxlIiwKICAgICAgICAgICAgImpzb25UeXBlLmxhYmVsIjogIlN0cmluZyIKICAgICAgICAgIH0KICAgICAgICB9LAogICAgICAgIHsKICAgICAgICAgICJpZCI6ICIwM2IyYjhiNi0yZDhkLTQ0MjctODc0NC04MjZlM2U4Nzc2NDUiLAogICAgICAgICAgIm5hbWUiOiAiZ2l2ZW4gbmFtZSIsCiAgICAgICAgICAicHJvdG9jb2wiOiAib3BlbmlkLWNvbm5lY3QiLAogICAgICAgICAgInByb3RvY29sTWFwcGVyIjogIm9pZGMtdXNlcm1vZGVsLXByb3BlcnR5LW1hcHBlciIsCiAgICAgICAgICAiY29uc2VudFJlcXVpcmVkIjogZmFsc2UsCiAgICAgICAgICAiY29uZmlnIjogewogICAgICAgICAgICAidXNlcmluZm8udG9rZW4uY2xhaW0iOiAidHJ1ZSIsCiAgICAgICAgICAgICJ1c2VyLmF0dHJpYnV0ZSI6ICJmaXJzdE5hbWUiLAogICAgICAgICAgICAiaWQudG9rZW4uY2xhaW0iOiAidHJ1ZSIsCiAgICAgICAgICAgICJhY2Nlc3MudG9rZW4uY2xhaW0iOiAidHJ1ZSIsCiAgICAgICAgICAgICJjbGFpbS5uYW1lIjogImdpdmVuX25hbWUiLAogICAgICAgICAgICAianNvblR5cGUubGFiZWwiOiAiU3RyaW5nIgogICAgICAgICAgfQogICAgICAgIH0sCiAgICAgICAgewogICAgICAgICAgImlkIjogIjQ2NTEzNWJjLWY3YTQtNDZlNS05NjY1LTg2MDM5NzYzMTBmZCIsCiAgICAgICAgICAibmFtZSI6ICJtaWRkbGUgbmFtZSIsCiAgICAgICAgICAicHJvdG9jb2wiOiAib3BlbmlkLWNvbm5lY3QiLAogICAgICAgICAgInByb3RvY29sTWFwcGVyIjogIm9pZGMtdXNlcm1vZGVsLWF0dHJpYnV0ZS1tYXBwZXIiLAogICAgICAgICAgImNvbnNlbnRSZXF1aXJlZCI6IGZhbHNlLAogICAgICAgICAgImNvbmZpZyI6IHsKICAgICAgICAgICAgInVzZXJpbmZvLnRva2VuLmNsYWltIjogInRydWUiLAogICAgICAgICAgICAidXNlci5hdHRyaWJ1dGUiOiAibWlkZGxlTmFtZSIsCiAgICAgICAgICAgICJpZC50b2tlbi5jbGFpbSI6ICJ0cnVlIiwKICAgICAgICAgICAgImFjY2Vzcy50b2tlbi5jbGFpbSI6ICJ0cnVlIiwKICAgICAgICAgICAgImNsYWltLm5hbWUiOiAibWlkZGxlX25hbWUiLAogICAgICAgICAgICAianNvblR5cGUubGFiZWwiOiAiU3RyaW5nIgogICAgICAgICAgfQogICAgICAgIH0sCiAgICAgICAgewogICAgICAgICAgImlkIjogIjYwYjhlYjBiLTA3OGUtNDdkNC04ODBjLTNkZTQ3ODUwN2NkZiIsCiAgICAgICAgICAibmFtZSI6ICJ1c2VybmFtZSIsCiAgICAgICAgICAicHJvdG9jb2wiOiAib3BlbmlkLWNvbm5lY3QiLAogICAgICAgICAgInByb3RvY29sTWFwcGVyIjogIm9pZGMtdXNlcm1vZGVsLXByb3BlcnR5LW1hcHBlciIsCiAgICAgICAgICAiY29uc2VudFJlcXVpcmVkIjogZmFsc2UsCiAgICAgICAgICAiY29uZmlnIjogewogICAgICAgICAgICAidXNlcmluZm8udG9rZW4uY2xhaW0iOiAidHJ1ZSIsCiAgICAgICAgICAgICJ1c2VyLmF0dHJpYnV0ZSI6ICJ1c2VybmFtZSIsCiAgICAgICAgICAgICJpZC50b2tlbi5jbGFpbSI6ICJ0cnVlIiwKICAgICAgICAgICAgImFjY2Vzcy50b2tlbi5jbGFpbSI6ICJ0cnVlIiwKICAgICAgICAgICAgImNsYWltLm5hbWUiOiAicHJlZmVycmVkX3VzZXJuYW1lIiwKICAgICAgICAgICAgImpzb25UeXBlLmxhYmVsIjogIlN0cmluZyIKICAgICAgICAgIH0KICAgICAgICB9LAogICAgICAgIHsKICAgICAgICAgICJpZCI6ICI2ZTg3ZTI5Yy1iMDk2LTQ4NmEtODk2NS05YmIzMGZhYWQ4OTIiLAogICAgICAgICAgIm5hbWUiOiAibmlja25hbWUiLAogICAgICAgICAgInByb3RvY29sIjogIm9wZW5pZC1jb25uZWN0IiwKICAgICAgICAgICJwcm90b2NvbE1hcHBlciI6ICJvaWRjLXVzZXJtb2RlbC1hdHRyaWJ1dGUtbWFwcGVyIiwKICAgICAgICAgICJjb25zZW50UmVxdWlyZWQiOiBmYWxzZSwKICAgICAgICAgICJjb25maWciOiB7CiAgICAgICAgICAgICJ1c2VyaW5mby50b2tlbi5jbGFpbSI6ICJ0cnVlIiwKICAgICAgICAgICAgInVzZXIuYXR0cmlidXRlIjogIm5pY2tuYW1lIiwKICAgICAgICAgICAgImlkLnRva2VuLmNsYWltIjogInRydWUiLAogICAgICAgICAgICAiYWNjZXNzLnRva2VuLmNsYWltIjogInRydWUiLAogICAgICAgICAgICAiY2xhaW0ubmFtZSI6ICJuaWNrbmFtZSIsCiAgICAgICAgICAgICJqc29uVHlwZS5sYWJlbCI6ICJTdHJpbmciCiAgICAgICAgICB9CiAgICAgICAgfSwKICAgICAgICB7CiAgICAgICAgICAiaWQiOiAiOTJjY2FkMzMtNDhjNi00NTlmLWFmMWMtMTQ4ZDFmOTFiOTZjIiwKICAgICAgICAgICJuYW1lIjogInpvbmVpbmZvIiwKICAgICAgICAgICJwcm90b2NvbCI6ICJvcGVuaWQtY29ubmVjdCIsCiAgICAgICAgICAicHJvdG9jb2xNYXBwZXIiOiAib2lkYy11c2VybW9kZWwtYXR0cmlidXRlLW1hcHBlciIsCiAgICAgICAgICAiY29uc2VudFJlcXVpcmVkIjogZmFsc2UsCiAgICAgICAgICAiY29uZmlnIjogewogICAgICAgICAgICAidXNlcmluZm8udG9rZW4uY2xhaW0iOiAidHJ1ZSIsCiAgICAgICAgICAgICJ1c2VyLmF0dHJpYnV0ZSI6ICJ6b25laW5mbyIsCiAgICAgICAgICAgICJpZC50b2tlbi5jbGFpbSI6ICJ0cnVlIiwKICAgICAgICAgICAgImFjY2Vzcy50b2tlbi5jbGFpbSI6ICJ0cnVlIiwKICAgICAgICAgICAgImNsYWltLm5hbWUiOiAiem9uZWluZm8iLAogICAgICAgICAgICAianNvblR5cGUubGFiZWwiOiAiU3RyaW5nIgogICAgICAgICAgfQogICAgICAgIH0sCiAgICAgICAgewogICAgICAgICAgImlkIjogIjQ4YzE4M2M3LTc0NzItNDgxNy1hYjczLTc2MTZiYzdhY2E2YiIsCiAgICAgICAgICAibmFtZSI6ICJmYW1pbHkgbmFtZSIsCiAgICAgICAgICAicHJvdG9jb2wiOiAib3BlbmlkLWNvbm5lY3QiLAogICAgICAgICAgInByb3RvY29sTWFwcGVyIjogIm9pZGMtdXNlcm1vZGVsLXByb3BlcnR5LW1hcHBlciIsCiAgICAgICAgICAiY29uc2VudFJlcXVpcmVkIjogZmFsc2UsCiAgICAgICAgICAiY29uZmlnIjogewogICAgICAgICAgICAidXNlcmluZm8udG9rZW4uY2xhaW0iOiAidHJ1ZSIsCiAgICAgICAgICAgICJ1c2VyLmF0dHJpYnV0ZSI6ICJsYXN0TmFtZSIsCiAgICAgICAgICAgICJpZC50b2tlbi5jbGFpbSI6ICJ0cnVlIiwKICAgICAgICAgICAgImFjY2Vzcy50b2tlbi5jbGFpbSI6ICJ0cnVlIiwKICAgICAgICAgICAgImNsYWltLm5hbWUiOiAiZmFtaWx5X25hbWUiLAogICAgICAgICAgICAianNvblR5cGUubGFiZWwiOiAiU3RyaW5nIgogICAgICAgICAgfQogICAgICAgIH0KICAgICAgXQogICAgfSwKICAgIHsKICAgICAgImlkIjogIjBkYmZlOTZjLTFhNGQtNDc1MS05NWYzLWY1YjQ0ZGI1ZjU5ZiIsCiAgICAgICJuYW1lIjogInJvbGVfbGlzdCIsCiAgICAgICJkZXNjcmlwdGlvbiI6ICJTQU1MIHJvbGUgbGlzdCIsCiAgICAgICJwcm90b2NvbCI6ICJzYW1sIiwKICAgICAgImF0dHJpYnV0ZXMiOiB7CiAgICAgICAgImNvbnNlbnQuc2NyZWVuLnRleHQiOiAiJHtzYW1sUm9sZUxpc3RTY29wZUNvbnNlbnRUZXh0fSIsCiAgICAgICAgImRpc3BsYXkub24uY29uc2VudC5zY3JlZW4iOiAidHJ1ZSIKICAgICAgfSwKICAgICAgInByb3RvY29sTWFwcGVycyI6IFsKICAgICAgICB7CiAgICAgICAgICAiaWQiOiAiNjNiMWQzMjQtZWU4MC00MzI5LTk0OTQtM2Q0M2VjN2I5ODAzIiwKICAgICAgICAgICJuYW1lIjogInJvbGUgbGlzdCIsCiAgICAgICAgICAicHJvdG9jb2wiOiAic2FtbCIsCiAgICAgICAgICAicHJvdG9jb2xNYXBwZXIiOiAic2FtbC1yb2xlLWxpc3QtbWFwcGVyIiwKICAgICAgICAgICJjb25zZW50UmVxdWlyZWQiOiBmYWxzZSwKICAgICAgICAgICJjb25maWciOiB7CiAgICAgICAgICAgICJzaW5nbGUiOiAiZmFsc2UiLAogICAgICAgICAgICAiYXR0cmlidXRlLm5hbWVmb3JtYXQiOiAiQmFzaWMiLAogICAgICAgICAgICAiYXR0cmlidXRlLm5hbWUiOiAiUm9sZSIKICAgICAgICAgIH0KICAgICAgICB9CiAgICAgIF0KICAgIH0sCiAgICB7CiAgICAgICJpZCI6ICJhMjQzZmQxNS00MTY5LTQzM2QtYjIxOC1jYjJjYzA4MzQxYWUiLAogICAgICAibmFtZSI6ICJyb2xlcyIsCiAgICAgICJkZXNjcmlwdGlvbiI6ICJPcGVuSUQgQ29ubmVjdCBzY29wZSBmb3IgYWRkIHVzZXIgcm9sZXMgdG8gdGhlIGFjY2VzcyB0b2tlbiIsCiAgICAgICJwcm90b2NvbCI6ICJvcGVuaWQtY29ubmVjdCIsCiAgICAgICJhdHRyaWJ1dGVzIjogewogICAgICAgICJpbmNsdWRlLmluLnRva2VuLnNjb3BlIjogImZhbHNlIiwKICAgICAgICAiZGlzcGxheS5vbi5jb25zZW50LnNjcmVlbiI6ICJ0cnVlIiwKICAgICAgICAiY29uc2VudC5zY3JlZW4udGV4dCI6ICIke3JvbGVzU2NvcGVDb25zZW50VGV4dH0iCiAgICAgIH0sCiAgICAgICJwcm90b2NvbE1hcHBlcnMiOiBbCiAgICAgICAgewogICAgICAgICAgImlkIjogImU5MWU2ZDA3LWRjMjQtNDlhMS04OGUyLTMxNjA5ZDA1MDY4NiIsCiAgICAgICAgICAibmFtZSI6ICJjbGllbnQgcm9sZXMiLAogICAgICAgICAgInByb3RvY29sIjogIm9wZW5pZC1jb25uZWN0IiwKICAgICAgICAgICJwcm90b2NvbE1hcHBlciI6ICJvaWRjLXVzZXJtb2RlbC1jbGllbnQtcm9sZS1tYXBwZXIiLAogICAgICAgICAgImNvbnNlbnRSZXF1aXJlZCI6IGZhbHNlLAogICAgICAgICAgImNvbmZpZyI6IHsKICAgICAgICAgICAgInVzZXIuYXR0cmlidXRlIjogImZvbyIsCiAgICAgICAgICAgICJhY2Nlc3MudG9rZW4uY2xhaW0iOiAidHJ1ZSIsCiAgICAgICAgICAgICJjbGFpbS5uYW1lIjogInJlc291cmNlX2FjY2Vzcy4ke2NsaWVudF9pZH0ucm9sZXMiLAogICAgICAgICAgICAianNvblR5cGUubGFiZWwiOiAiU3RyaW5nIiwKICAgICAgICAgICAgIm11bHRpdmFsdWVkIjogInRydWUiCiAgICAgICAgICB9CiAgICAgICAgfSwKICAgICAgICB7CiAgICAgICAgICAiaWQiOiAiNzgxNTM3ODEtODRkMi00Zjk1LWI5NzQtZmEwZGUxYzdjYmUzIiwKICAgICAgICAgICJuYW1lIjogImF1ZGllbmNlIHJlc29sdmUiLAogICAgICAgICAgInByb3RvY29sIjogIm9wZW5pZC1jb25uZWN0IiwKICAgICAgICAgICJwcm90b2NvbE1hcHBlciI6ICJvaWRjLWF1ZGllbmNlLXJlc29sdmUtbWFwcGVyIiwKICAgICAgICAgICJjb25zZW50UmVxdWlyZWQiOiBmYWxzZSwKICAgICAgICAgICJjb25maWciOiB7fQogICAgICAgIH0sCiAgICAgICAgewogICAgICAgICAgImlkIjogIjI0ZTZhNmIyLTJjM2ItNDY4YS04NWM1LTQ1ZGQ1ZjJkZmYzOCIsCiAgICAgICAgICAibmFtZSI6ICJyZWFsbSByb2xlcyIsCiAgICAgICAgICAicHJvdG9jb2wiOiAib3BlbmlkLWNvbm5lY3QiLAogICAgICAgICAgInByb3RvY29sTWFwcGVyIjogIm9pZGMtdXNlcm1vZGVsLXJlYWxtLXJvbGUtbWFwcGVyIiwKICAgICAgICAgICJjb25zZW50UmVxdWlyZWQiOiBmYWxzZSwKICAgICAgICAgICJjb25maWciOiB7CiAgICAgICAgICAgICJ1c2VyLmF0dHJpYnV0ZSI6ICJmb28iLAogICAgICAgICAgICAiYWNjZXNzLnRva2VuLmNsYWltIjogInRydWUiLAogICAgICAgICAgICAiY2xhaW0ubmFtZSI6ICJyZWFsbV9hY2Nlc3Mucm9sZXMiLAogICAgICAgICAgICAianNvblR5cGUubGFiZWwiOiAiU3RyaW5nIiwKICAgICAgICAgICAgIm11bHRpdmFsdWVkIjogInRydWUiCiAgICAgICAgICB9CiAgICAgICAgfQogICAgICBdCiAgICB9LAogICAgewogICAgICAiaWQiOiAiZmU4YzZlYjAtOTBjYi00MGMyLWIzNGMtMWFmNDY0ZjJiNDc4IiwKICAgICAgIm5hbWUiOiAid2ViLW9yaWdpbnMiLAogICAgICAiZGVzY3JpcHRpb24iOiAiT3BlbklEIENvbm5lY3Qgc2NvcGUgZm9yIGFkZCBhbGxvd2VkIHdlYiBvcmlnaW5zIHRvIHRoZSBhY2Nlc3MgdG9rZW4iLAogICAgICAicHJvdG9jb2wiOiAib3BlbmlkLWNvbm5lY3QiLAogICAgICAiYXR0cmlidXRlcyI6IHsKICAgICAgICAiaW5jbHVkZS5pbi50b2tlbi5zY29wZSI6ICJmYWxzZSIsCiAgICAgICAgImRpc3BsYXkub24uY29uc2VudC5zY3JlZW4iOiAiZmFsc2UiLAogICAgICAgICJjb25zZW50LnNjcmVlbi50ZXh0IjogIiIKICAgICAgfSwKICAgICAgInByb3RvY29sTWFwcGVycyI6IFsKICAgICAgICB7CiAgICAgICAgICAiaWQiOiAiZTkzMDE4MzktNDgzZC00OGZlLTgzZmItNDNjZTQwYTI3YWRmIiwKICAgICAgICAgICJuYW1lIjogImFsbG93ZWQgd2ViIG9yaWdpbnMiLAogICAgICAgICAgInByb3RvY29sIjogIm9wZW5pZC1jb25uZWN0IiwKICAgICAgICAgICJwcm90b2NvbE1hcHBlciI6ICJvaWRjLWFsbG93ZWQtb3JpZ2lucy1tYXBwZXIiLAogICAgICAgICAgImNvbnNlbnRSZXF1aXJlZCI6IGZhbHNlLAogICAgICAgICAgImNvbmZpZyI6IHt9CiAgICAgICAgfQogICAgICBdCiAgICB9CiAgXSwKICAiZGVmYXVsdERlZmF1bHRDbGllbnRTY29wZXMiOiBbCiAgICAicm9sZV9saXN0IiwKICAgICJyb2xlcyIsCiAgICAicHJvZmlsZSIsCiAgICAiZW1haWwiLAogICAgIndlYi1vcmlnaW5zIgogIF0sCiAgImRlZmF1bHRPcHRpb25hbENsaWVudFNjb3BlcyI6IFsKICAgICJtaWNyb3Byb2ZpbGUtand0IiwKICAgICJwaG9uZSIsCiAgICAib2ZmbGluZV9hY2Nlc3MiLAogICAgImFkZHJlc3MiCiAgXSwKICAiYnJvd3NlclNlY3VyaXR5SGVhZGVycyI6IHsKICAgICJjb250ZW50U2VjdXJpdHlQb2xpY3lSZXBvcnRPbmx5IjogIiIsCiAgICAieENvbnRlbnRUeXBlT3B0aW9ucyI6ICJub3NuaWZmIiwKICAgICJ4Um9ib3RzVGFnIjogIm5vbmUiLAogICAgInhGcmFtZU9wdGlvbnMiOiAiU0FNRU9SSUdJTiIsCiAgICAiY29udGVudFNlY3VyaXR5UG9saWN5IjogImZyYW1lLXNyYyAnc2VsZic7IGZyYW1lLWFuY2VzdG9ycyAnc2VsZic7IG9iamVjdC1zcmMgJ25vbmUnOyIsCiAgICAieFhTU1Byb3RlY3Rpb24iOiAiMTsgbW9kZT1ibG9jayIsCiAgICAic3RyaWN0VHJhbnNwb3J0U2VjdXJpdHkiOiAibWF4LWFnZT0zMTUzNjAwMDsgaW5jbHVkZVN1YkRvbWFpbnMiCiAgfSwKICAic210cFNlcnZlciI6IHt9LAogICJldmVudHNFbmFibGVkIjogZmFsc2UsCiAgImV2ZW50c0xpc3RlbmVycyI6IFsKICAgICJqYm9zcy1sb2dnaW5nIgogIF0sCiAgImVuYWJsZWRFdmVudFR5cGVzIjogW10sCiAgImFkbWluRXZlbnRzRW5hYmxlZCI6IGZhbHNlLAogICJhZG1pbkV2ZW50c0RldGFpbHNFbmFibGVkIjogZmFsc2UsCiAgImNvbXBvbmVudHMiOiB7CiAgICAib3JnLmtleWNsb2FrLnNlcnZpY2VzLmNsaWVudHJlZ2lzdHJhdGlvbi5wb2xpY3kuQ2xpZW50UmVnaXN0cmF0aW9uUG9saWN5IjogWwogICAgICB7CiAgICAgICAgImlkIjogIjkyOTk4ZDVmLTk0NWItNDIyNC1hZjUxLTExNDkyOGRjMzBlNyIsCiAgICAgICAgIm5hbWUiOiAiQ29uc2VudCBSZXF1aXJlZCIsCiAgICAgICAgInByb3ZpZGVySWQiOiAiY29uc2VudC1yZXF1aXJlZCIsCiAgICAgICAgInN1YlR5cGUiOiAiYW5vbnltb3VzIiwKICAgICAgICAic3ViQ29tcG9uZW50cyI6IHt9LAogICAgICAgICJjb25maWciOiB7fQogICAgICB9LAogICAgICB7CiAgICAgICAgImlkIjogIjY5YWEyNTI4LTA5YTAtNDVhYi1hZGFhLWI4NjdkMzMyYzExZSIsCiAgICAgICAgIm5hbWUiOiAiQWxsb3dlZCBDbGllbnQgU2NvcGVzIiwKICAgICAgICAicHJvdmlkZXJJZCI6ICJhbGxvd2VkLWNsaWVudC10ZW1wbGF0ZXMiLAogICAgICAgICJzdWJUeXBlIjogImF1dGhlbnRpY2F0ZWQiLAogICAgICAgICJzdWJDb21wb25lbnRzIjoge30sCiAgICAgICAgImNvbmZpZyI6IHsKICAgICAgICAgICJhbGxvdy1kZWZhdWx0LXNjb3BlcyI6IFsKICAgICAgICAgICAgInRydWUiCiAgICAgICAgICBdCiAgICAgICAgfQogICAgICB9LAogICAgICB7CiAgICAgICAgImlkIjogIjcyMTIyMjIxLTg2ZmItNGNlMi05Y2M3LTVkNDU0YjNkYzQ5OSIsCiAgICAgICAgIm5hbWUiOiAiTWF4IENsaWVudHMgTGltaXQiLAogICAgICAgICJwcm92aWRlcklkIjogIm1heC1jbGllbnRzIiwKICAgICAgICAic3ViVHlwZSI6ICJhbm9ueW1vdXMiLAogICAgICAgICJzdWJDb21wb25lbnRzIjoge30sCiAgICAgICAgImNvbmZpZyI6IHsKICAgICAgICAgICJtYXgtY2xpZW50cyI6IFsKICAgICAgICAgICAgIjIwMCIKICAgICAgICAgIF0KICAgICAgICB9CiAgICAgIH0sCiAgICAgIHsKICAgICAgICAiaWQiOiAiMDU0OWYzNDktZTY4My00OTI3LTk3OWEtYzlkNDk0Y2E5MmU1IiwKICAgICAgICAibmFtZSI6ICJBbGxvd2VkIENsaWVudCBTY29wZXMiLAogICAgICAgICJwcm92aWRlcklkIjogImFsbG93ZWQtY2xpZW50LXRlbXBsYXRlcyIsCiAgICAgICAgInN1YlR5cGUiOiAiYW5vbnltb3VzIiwKICAgICAgICAic3ViQ29tcG9uZW50cyI6IHt9LAogICAgICAgICJjb25maWciOiB7CiAgICAgICAgICAiYWxsb3ctZGVmYXVsdC1zY29wZXMiOiBbCiAgICAgICAgICAgICJ0cnVlIgogICAgICAgICAgXQogICAgICAgIH0KICAgICAgfSwKICAgICAgewogICAgICAgICJpZCI6ICJhNzFlZDNmZi00YzhiLTRhOTgtOTdhMC1kN2Y1OWYzNzZiYTIiLAogICAgICAgICJuYW1lIjogIkFsbG93ZWQgUHJvdG9jb2wgTWFwcGVyIFR5cGVzIiwKICAgICAgICAicHJvdmlkZXJJZCI6ICJhbGxvd2VkLXByb3RvY29sLW1hcHBlcnMiLAogICAgICAgICJzdWJUeXBlIjogImFub255bW91cyIsCiAgICAgICAgInN1YkNvbXBvbmVudHMiOiB7fSwKICAgICAgICAiY29uZmlnIjogewogICAgICAgICAgImFsbG93ZWQtcHJvdG9jb2wtbWFwcGVyLXR5cGVzIjogWwogICAgICAgICAgICAic2FtbC11c2VyLXByb3BlcnR5LW1hcHBlciIsCiAgICAgICAgICAgICJvaWRjLWFkZHJlc3MtbWFwcGVyIiwKICAgICAgICAgICAgInNhbWwtcm9sZS1saXN0LW1hcHBlciIsCiAgICAgICAgICAgICJvaWRjLXVzZXJtb2RlbC1hdHRyaWJ1dGUtbWFwcGVyIiwKICAgICAgICAgICAgIm9pZGMtc2hhMjU2LXBhaXJ3aXNlLXN1Yi1tYXBwZXIiLAogICAgICAgICAgICAib2lkYy11c2VybW9kZWwtcHJvcGVydHktbWFwcGVyIiwKICAgICAgICAgICAgInNhbWwtdXNlci1hdHRyaWJ1dGUtbWFwcGVyIiwKICAgICAgICAgICAgIm9pZGMtZnVsbC1uYW1lLW1hcHBlciIKICAgICAgICAgIF0KICAgICAgICB9CiAgICAgIH0sCiAgICAgIHsKICAgICAgICAiaWQiOiAiOWI1YTcwZGQtNmJiNy00YjdjLWIzMGEtYTQ3YmRkMTg5ODU5IiwKICAgICAgICAibmFtZSI6ICJGdWxsIFNjb3BlIERpc2FibGVkIiwKICAgICAgICAicHJvdmlkZXJJZCI6ICJzY29wZSIsCiAgICAgICAgInN1YlR5cGUiOiAiYW5vbnltb3VzIiwKICAgICAgICAic3ViQ29tcG9uZW50cyI6IHt9LAogICAgICAgICJjb25maWciOiB7fQogICAgICB9LAogICAgICB7CiAgICAgICAgImlkIjogImFmNDk1MmUwLTBhZjktNDkyMS05NDAyLTk3MzQwNDFlNjVjYiIsCiAgICAgICAgIm5hbWUiOiAiQWxsb3dlZCBQcm90b2NvbCBNYXBwZXIgVHlwZXMiLAogICAgICAgICJwcm92aWRlcklkIjogImFsbG93ZWQtcHJvdG9jb2wtbWFwcGVycyIsCiAgICAgICAgInN1YlR5cGUiOiAiYXV0aGVudGljYXRlZCIsCiAgICAgICAgInN1YkNvbXBvbmVudHMiOiB7fSwKICAgICAgICAiY29uZmlnIjogewogICAgICAgICAgImFsbG93ZWQtcHJvdG9jb2wtbWFwcGVyLXR5cGVzIjogWwogICAgICAgICAgICAib2lkYy1zaGEyNTYtcGFpcndpc2Utc3ViLW1hcHBlciIsCiAgICAgICAgICAgICJvaWRjLXVzZXJtb2RlbC1wcm9wZXJ0eS1tYXBwZXIiLAogICAgICAgICAgICAic2FtbC1yb2xlLWxpc3QtbWFwcGVyIiwKICAgICAgICAgICAgInNhbWwtdXNlci1hdHRyaWJ1dGUtbWFwcGVyIiwKICAgICAgICAgICAgIm9pZGMtZnVsbC1uYW1lLW1hcHBlciIsCiAgICAgICAgICAgICJvaWRjLXVzZXJtb2RlbC1hdHRyaWJ1dGUtbWFwcGVyIiwKICAgICAgICAgICAgIm9pZGMtYWRkcmVzcy1tYXBwZXIiLAogICAgICAgICAgICAic2FtbC11c2VyLXByb3BlcnR5LW1hcHBlciIKICAgICAgICAgIF0KICAgICAgICB9CiAgICAgIH0sCiAgICAgIHsKICAgICAgICAiaWQiOiAiMmM5NGExYmMtYjU4ZC00YjY5LWFlODgtNmRkNDNmMDExMjEwIiwKICAgICAgICAibmFtZSI6ICJUcnVzdGVkIEhvc3RzIiwKICAgICAgICAicHJvdmlkZXJJZCI6ICJ0cnVzdGVkLWhvc3RzIiwKICAgICAgICAic3ViVHlwZSI6ICJhbm9ueW1vdXMiLAogICAgICAgICJzdWJDb21wb25lbnRzIjoge30sCiAgICAgICAgImNvbmZpZyI6IHsKICAgICAgICAgICJob3N0LXNlbmRpbmctcmVnaXN0cmF0aW9uLXJlcXVlc3QtbXVzdC1tYXRjaCI6IFsKICAgICAgICAgICAgInRydWUiCiAgICAgICAgICBdLAogICAgICAgICAgImNsaWVudC11cmlzLW11c3QtbWF0Y2giOiBbCiAgICAgICAgICAgICJ0cnVlIgogICAgICAgICAgXQogICAgICAgIH0KICAgICAgfQogICAgXSwKICAgICJvcmcua2V5Y2xvYWsua2V5cy5LZXlQcm92aWRlciI6IFsKICAgICAgewogICAgICAgICJpZCI6ICIwZDNmYTgyYS1lNzk2LTRjNjItODY2Ny0zOTY2NzY0Y2ZjODciLAogICAgICAgICJuYW1lIjogImFlcy1nZW5lcmF0ZWQiLAogICAgICAgICJwcm92aWRlcklkIjogImFlcy1nZW5lcmF0ZWQiLAogICAgICAgICJzdWJDb21wb25lbnRzIjoge30sCiAgICAgICAgImNvbmZpZyI6IHsKICAgICAgICAgICJwcmlvcml0eSI6IFsKICAgICAgICAgICAgIjEwMCIKICAgICAgICAgIF0KICAgICAgICB9CiAgICAgIH0sCiAgICAgIHsKICAgICAgICAiaWQiOiAiMDlhMDI2OGUtOTMxNC00ZjkwLTk2MWQtMzBlMDhlOThiZTU2IiwKICAgICAgICAibmFtZSI6ICJobWFjLWdlbmVyYXRlZCIsCiAgICAgICAgInByb3ZpZGVySWQiOiAiaG1hYy1nZW5lcmF0ZWQiLAogICAgICAgICJzdWJDb21wb25lbnRzIjoge30sCiAgICAgICAgImNvbmZpZyI6IHsKICAgICAgICAgICJwcmlvcml0eSI6IFsKICAgICAgICAgICAgIjEwMCIKICAgICAgICAgIF0sCiAgICAgICAgICAiYWxnb3JpdGhtIjogWwogICAgICAgICAgICAiSFMyNTYiCiAgICAgICAgICBdCiAgICAgICAgfQogICAgICB9LAogICAgICB7CiAgICAgICAgImlkIjogIjY4MGZjODI3LTIyZDgtNGMyMy05ZGIyLWUyMzViOWIwYzJlMyIsCiAgICAgICAgIm5hbWUiOiAicnNhLWdlbmVyYXRlZCIsCiAgICAgICAgInByb3ZpZGVySWQiOiAicnNhLWdlbmVyYXRlZCIsCiAgICAgICAgInN1YkNvbXBvbmVudHMiOiB7fSwKICAgICAgICAiY29uZmlnIjogewogICAgICAgICAgInByaW9yaXR5IjogWwogICAgICAgICAgICAiMTAwIgogICAgICAgICAgXQogICAgICAgIH0KICAgICAgfQogICAgXQogIH0sCiAgImludGVybmF0aW9uYWxpemF0aW9uRW5hYmxlZCI6IGZhbHNlLAogICJzdXBwb3J0ZWRMb2NhbGVzIjogW10sCiAgImF1dGhlbnRpY2F0aW9uRmxvd3MiOiBbCiAgICB7CiAgICAgICJpZCI6ICJmYzdiNzJlMC01YjlhLTRmZTUtODY0OC1lYjdiMTdjNGNmY2EiLAogICAgICAiYWxpYXMiOiAiQWNjb3VudCB2ZXJpZmljYXRpb24gb3B0aW9ucyIsCiAgICAgICJkZXNjcmlwdGlvbiI6ICJNZXRob2Qgd2l0aCB3aGljaCB0byB2ZXJpdHkgdGhlIGV4aXN0aW5nIGFjY291bnQiLAogICAgICAicHJvdmlkZXJJZCI6ICJiYXNpYy1mbG93IiwKICAgICAgInRvcExldmVsIjogZmFsc2UsCiAgICAgICJidWlsdEluIjogdHJ1ZSwKICAgICAgImF1dGhlbnRpY2F0aW9uRXhlY3V0aW9ucyI6IFsKICAgICAgICB7CiAgICAgICAgICAiYXV0aGVudGljYXRvciI6ICJpZHAtZW1haWwtdmVyaWZpY2F0aW9uIiwKICAgICAgICAgICJyZXF1aXJlbWVudCI6ICJBTFRFUk5BVElWRSIsCiAgICAgICAgICAicHJpb3JpdHkiOiAxMCwKICAgICAgICAgICJ1c2VyU2V0dXBBbGxvd2VkIjogZmFsc2UsCiAgICAgICAgICAiYXV0aGV0aWNhdG9yRmxvdyI6IGZhbHNlCiAgICAgICAgfSwKICAgICAgICB7CiAgICAgICAgICAicmVxdWlyZW1lbnQiOiAiQUxURVJOQVRJVkUiLAogICAgICAgICAgInByaW9yaXR5IjogMjAsCiAgICAgICAgICAiZmxvd0FsaWFzIjogIlZlcmlmeSBFeGlzdGluZyBBY2NvdW50IGJ5IFJlLWF1dGhlbnRpY2F0aW9uIiwKICAgICAgICAgICJ1c2VyU2V0dXBBbGxvd2VkIjogZmFsc2UsCiAgICAgICAgICAiYXV0aGV0aWNhdG9yRmxvdyI6IHRydWUKICAgICAgICB9CiAgICAgIF0KICAgIH0sCiAgICB7CiAgICAgICJpZCI6ICJlZjA5NmVlYy03MGI1LTQwNjItOWYyOC02ODU4NjQ0ZDhiNmEiLAogICAgICAiYWxpYXMiOiAiQXV0aGVudGljYXRpb24gT3B0aW9ucyIsCiAgICAgICJkZXNjcmlwdGlvbiI6ICJBdXRoZW50aWNhdGlvbiBvcHRpb25zLiIsCiAgICAgICJwcm92aWRlcklkIjogImJhc2ljLWZsb3ciLAogICAgICAidG9wTGV2ZWwiOiBmYWxzZSwKICAgICAgImJ1aWx0SW4iOiB0cnVlLAogICAgICAiYXV0aGVudGljYXRpb25FeGVjdXRpb25zIjogWwogICAgICAgIHsKICAgICAgICAgICJhdXRoZW50aWNhdG9yIjogImJhc2ljLWF1dGgiLAogICAgICAgICAgInJlcXVpcmVtZW50IjogIlJFUVVJUkVEIiwKICAgICAgICAgICJwcmlvcml0eSI6IDEwLAogICAgICAgICAgInVzZXJTZXR1cEFsbG93ZWQiOiBmYWxzZSwKICAgICAgICAgICJhdXRoZXRpY2F0b3JGbG93IjogZmFsc2UKICAgICAgICB9LAogICAgICAgIHsKICAgICAgICAgICJhdXRoZW50aWNhdG9yIjogImJhc2ljLWF1dGgtb3RwIiwKICAgICAgICAgICJyZXF1aXJlbWVudCI6ICJESVNBQkxFRCIsCiAgICAgICAgICAicHJpb3JpdHkiOiAyMCwKICAgICAgICAgICJ1c2VyU2V0dXBBbGxvd2VkIjogZmFsc2UsCiAgICAgICAgICAiYXV0aGV0aWNhdG9yRmxvdyI6IGZhbHNlCiAgICAgICAgfSwKICAgICAgICB7CiAgICAgICAgICAiYXV0aGVudGljYXRvciI6ICJhdXRoLXNwbmVnbyIsCiAgICAgICAgICAicmVxdWlyZW1lbnQiOiAiRElTQUJMRUQiLAogICAgICAgICAgInByaW9yaXR5IjogMzAsCiAgICAgICAgICAidXNlclNldHVwQWxsb3dlZCI6IGZhbHNlLAogICAgICAgICAgImF1dGhldGljYXRvckZsb3ciOiBmYWxzZQogICAgICAgIH0KICAgICAgXQogICAgfSwKICAgIHsKICAgICAgImlkIjogImMyZjQxMzgyLTViOGMtNGQyYy1hN2M1LWNmMmVhN2I5OGUzNSIsCiAgICAgICJhbGlhcyI6ICJCcm93c2VyIC0gQ29uZGl0aW9uYWwgT1RQIiwKICAgICAgImRlc2NyaXB0aW9uIjogIkZsb3cgdG8gZGV0ZXJtaW5lIGlmIHRoZSBPVFAgaXMgcmVxdWlyZWQgZm9yIHRoZSBhdXRoZW50aWNhdGlvbiIsCiAgICAgICJwcm92aWRlcklkIjogImJhc2ljLWZsb3ciLAogICAgICAidG9wTGV2ZWwiOiBmYWxzZSwKICAgICAgImJ1aWx0SW4iOiB0cnVlLAogICAgICAiYXV0aGVudGljYXRpb25FeGVjdXRpb25zIjogWwogICAgICAgIHsKICAgICAgICAgICJhdXRoZW50aWNhdG9yIjogImNvbmRpdGlvbmFsLXVzZXItY29uZmlndXJlZCIsCiAgICAgICAgICAicmVxdWlyZW1lbnQiOiAiUkVRVUlSRUQiLAogICAgICAgICAgInByaW9yaXR5IjogMTAsCiAgICAgICAgICAidXNlclNldHVwQWxsb3dlZCI6IGZhbHNlLAogICAgICAgICAgImF1dGhldGljYXRvckZsb3ciOiBmYWxzZQogICAgICAgIH0sCiAgICAgICAgewogICAgICAgICAgImF1dGhlbnRpY2F0b3IiOiAiYXV0aC1vdHAtZm9ybSIsCiAgICAgICAgICAicmVxdWlyZW1lbnQiOiAiUkVRVUlSRUQiLAogICAgICAgICAgInByaW9yaXR5IjogMjAsCiAgICAgICAgICAidXNlclNldHVwQWxsb3dlZCI6IGZhbHNlLAogICAgICAgICAgImF1dGhldGljYXRvckZsb3ciOiBmYWxzZQogICAgICAgIH0KICAgICAgXQogICAgfSwKICAgIHsKICAgICAgImlkIjogImU1MDE1YWNlLWQyZTUtNGQ4NC04OWIwLTI1NWIxZDAwMzljMyIsCiAgICAgICJhbGlhcyI6ICJEaXJlY3QgR3JhbnQgLSBDb25kaXRpb25hbCBPVFAiLAogICAgICAiZGVzY3JpcHRpb24iOiAiRmxvdyB0byBkZXRlcm1pbmUgaWYgdGhlIE9UUCBpcyByZXF1aXJlZCBmb3IgdGhlIGF1dGhlbnRpY2F0aW9uIiwKICAgICAgInByb3ZpZGVySWQiOiAiYmFzaWMtZmxvdyIsCiAgICAgICJ0b3BMZXZlbCI6IGZhbHNlLAogICAgICAiYnVpbHRJbiI6IHRydWUsCiAgICAgICJhdXRoZW50aWNhdGlvbkV4ZWN1dGlvbnMiOiBbCiAgICAgICAgewogICAgICAgICAgImF1dGhlbnRpY2F0b3IiOiAiY29uZGl0aW9uYWwtdXNlci1jb25maWd1cmVkIiwKICAgICAgICAgICJyZXF1aXJlbWVudCI6ICJSRVFVSVJFRCIsCiAgICAgICAgICAicHJpb3JpdHkiOiAxMCwKICAgICAgICAgICJ1c2VyU2V0dXBBbGxvd2VkIjogZmFsc2UsCiAgICAgICAgICAiYXV0aGV0aWNhdG9yRmxvdyI6IGZhbHNlCiAgICAgICAgfSwKICAgICAgICB7CiAgICAgICAgICAiYXV0aGVudGljYXRvciI6ICJkaXJlY3QtZ3JhbnQtdmFsaWRhdGUtb3RwIiwKICAgICAgICAgICJyZXF1aXJlbWVudCI6ICJSRVFVSVJFRCIsCiAgICAgICAgICAicHJpb3JpdHkiOiAyMCwKICAgICAgICAgICJ1c2VyU2V0dXBBbGxvd2VkIjogZmFsc2UsCiAgICAgICAgICAiYXV0aGV0aWNhdG9yRmxvdyI6IGZhbHNlCiAgICAgICAgfQogICAgICBdCiAgICB9LAogICAgewogICAgICAiaWQiOiAiNTFkMzU3MTktZmVhMi00ZDNlLTljMzAtMDQ5ZDZkMmQxMjhiIiwKICAgICAgImFsaWFzIjogIkZpcnN0IGJyb2tlciBsb2dpbiAtIENvbmRpdGlvbmFsIE9UUCIsCiAgICAgICJkZXNjcmlwdGlvbiI6ICJGbG93IHRvIGRldGVybWluZSBpZiB0aGUgT1RQIGlzIHJlcXVpcmVkIGZvciB0aGUgYXV0aGVudGljYXRpb24iLAogICAgICAicHJvdmlkZXJJZCI6ICJiYXNpYy1mbG93IiwKICAgICAgInRvcExldmVsIjogZmFsc2UsCiAgICAgICJidWlsdEluIjogdHJ1ZSwKICAgICAgImF1dGhlbnRpY2F0aW9uRXhlY3V0aW9ucyI6IFsKICAgICAgICB7CiAgICAgICAgICAiYXV0aGVudGljYXRvciI6ICJjb25kaXRpb25hbC11c2VyLWNvbmZpZ3VyZWQiLAogICAgICAgICAgInJlcXVpcmVtZW50IjogIlJFUVVJUkVEIiwKICAgICAgICAgICJwcmlvcml0eSI6IDEwLAogICAgICAgICAgInVzZXJTZXR1cEFsbG93ZWQiOiBmYWxzZSwKICAgICAgICAgICJhdXRoZXRpY2F0b3JGbG93IjogZmFsc2UKICAgICAgICB9LAogICAgICAgIHsKICAgICAgICAgICJhdXRoZW50aWNhdG9yIjogImF1dGgtb3RwLWZvcm0iLAogICAgICAgICAgInJlcXVpcmVtZW50IjogIlJFUVVJUkVEIiwKICAgICAgICAgICJwcmlvcml0eSI6IDIwLAogICAgICAgICAgInVzZXJTZXR1cEFsbG93ZWQiOiBmYWxzZSwKICAgICAgICAgICJhdXRoZXRpY2F0b3JGbG93IjogZmFsc2UKICAgICAgICB9CiAgICAgIF0KICAgIH0sCiAgICB7CiAgICAgICJpZCI6ICJiOGY4YTllZi1kNmQyLTQ1M2EtOGMxYS0yN2ZjM2Y4M2VmMDgiLAogICAgICAiYWxpYXMiOiAiSGFuZGxlIEV4aXN0aW5nIEFjY291bnQiLAogICAgICAiZGVzY3JpcHRpb24iOiAiSGFuZGxlIHdoYXQgdG8gZG8gaWYgdGhlcmUgaXMgZXhpc3RpbmcgYWNjb3VudCB3aXRoIHNhbWUgZW1haWwvdXNlcm5hbWUgbGlrZSBhdXRoZW50aWNhdGVkIGlkZW50aXR5IHByb3ZpZGVyIiwKICAgICAgInByb3ZpZGVySWQiOiAiYmFzaWMtZmxvdyIsCiAgICAgICJ0b3BMZXZlbCI6IGZhbHNlLAogICAgICAiYnVpbHRJbiI6IHRydWUsCiAgICAgICJhdXRoZW50aWNhdGlvbkV4ZWN1dGlvbnMiOiBbCiAgICAgICAgewogICAgICAgICAgImF1dGhlbnRpY2F0b3IiOiAiaWRwLWNvbmZpcm0tbGluayIsCiAgICAgICAgICAicmVxdWlyZW1lbnQiOiAiUkVRVUlSRUQiLAogICAgICAgICAgInByaW9yaXR5IjogMTAsCiAgICAgICAgICAidXNlclNldHVwQWxsb3dlZCI6IGZhbHNlLAogICAgICAgICAgImF1dGhldGljYXRvckZsb3ciOiBmYWxzZQogICAgICAgIH0sCiAgICAgICAgewogICAgICAgICAgInJlcXVpcmVtZW50IjogIlJFUVVJUkVEIiwKICAgICAgICAgICJwcmlvcml0eSI6IDIwLAogICAgICAgICAgImZsb3dBbGlhcyI6ICJBY2NvdW50IHZlcmlmaWNhdGlvbiBvcHRpb25zIiwKICAgICAgICAgICJ1c2VyU2V0dXBBbGxvd2VkIjogZmFsc2UsCiAgICAgICAgICAiYXV0aGV0aWNhdG9yRmxvdyI6IHRydWUKICAgICAgICB9CiAgICAgIF0KICAgIH0sCiAgICB7CiAgICAgICJpZCI6ICJlNzg4ZTQwMS1lNTdmLTQyNGItYjdlOS05ZDg2ZjMyNDFlNTgiLAogICAgICAiYWxpYXMiOiAiUmVzZXQgLSBDb25kaXRpb25hbCBPVFAiLAogICAgICAiZGVzY3JpcHRpb24iOiAiRmxvdyB0byBkZXRlcm1pbmUgaWYgdGhlIE9UUCBzaG91bGQgYmUgcmVzZXQgb3Igbm90LiBTZXQgdG8gUkVRVUlSRUQgdG8gZm9yY2UuIiwKICAgICAgInByb3ZpZGVySWQiOiAiYmFzaWMtZmxvdyIsCiAgICAgICJ0b3BMZXZlbCI6IGZhbHNlLAogICAgICAiYnVpbHRJbiI6IHRydWUsCiAgICAgICJhdXRoZW50aWNhdGlvbkV4ZWN1dGlvbnMiOiBbCiAgICAgICAgewogICAgICAgICAgImF1dGhlbnRpY2F0b3IiOiAiY29uZGl0aW9uYWwtdXNlci1jb25maWd1cmVkIiwKICAgICAgICAgICJyZXF1aXJlbWVudCI6ICJSRVFVSVJFRCIsCiAgICAgICAgICAicHJpb3JpdHkiOiAxMCwKICAgICAgICAgICJ1c2VyU2V0dXBBbGxvd2VkIjogZmFsc2UsCiAgICAgICAgICAiYXV0aGV0aWNhdG9yRmxvdyI6IGZhbHNlCiAgICAgICAgfSwKICAgICAgICB7CiAgICAgICAgICAiYXV0aGVudGljYXRvciI6ICJyZXNldC1vdHAiLAogICAgICAgICAgInJlcXVpcmVtZW50IjogIlJFUVVJUkVEIiwKICAgICAgICAgICJwcmlvcml0eSI6IDIwLAogICAgICAgICAgInVzZXJTZXR1cEFsbG93ZWQiOiBmYWxzZSwKICAgICAgICAgICJhdXRoZXRpY2F0b3JGbG93IjogZmFsc2UKICAgICAgICB9CiAgICAgIF0KICAgIH0sCiAgICB7CiAgICAgICJpZCI6ICJkNDViMjM0Ni0zNGJlLTQxMjYtYjMzZi05ZjE1NmUzMTFjNTEiLAogICAgICAiYWxpYXMiOiAiVXNlciBjcmVhdGlvbiBvciBsaW5raW5nIiwKICAgICAgImRlc2NyaXB0aW9uIjogIkZsb3cgZm9yIHRoZSBleGlzdGluZy9ub24tZXhpc3RpbmcgdXNlciBhbHRlcm5hdGl2ZXMiLAogICAgICAicHJvdmlkZXJJZCI6ICJiYXNpYy1mbG93IiwKICAgICAgInRvcExldmVsIjogZmFsc2UsCiAgICAgICJidWlsdEluIjogdHJ1ZSwKICAgICAgImF1dGhlbnRpY2F0aW9uRXhlY3V0aW9ucyI6IFsKICAgICAgICB7CiAgICAgICAgICAiYXV0aGVudGljYXRvckNvbmZpZyI6ICJjcmVhdGUgdW5pcXVlIHVzZXIgY29uZmlnIiwKICAgICAgICAgICJhdXRoZW50aWNhdG9yIjogImlkcC1jcmVhdGUtdXNlci1pZi11bmlxdWUiLAogICAgICAgICAgInJlcXVpcmVtZW50IjogIkFMVEVSTkFUSVZFIiwKICAgICAgICAgICJwcmlvcml0eSI6IDEwLAogICAgICAgICAgInVzZXJTZXR1cEFsbG93ZWQiOiBmYWxzZSwKICAgICAgICAgICJhdXRoZXRpY2F0b3JGbG93IjogZmFsc2UKICAgICAgICB9LAogICAgICAgIHsKICAgICAgICAgICJyZXF1aXJlbWVudCI6ICJBTFRFUk5BVElWRSIsCiAgICAgICAgICAicHJpb3JpdHkiOiAyMCwKICAgICAgICAgICJmbG93QWxpYXMiOiAiSGFuZGxlIEV4aXN0aW5nIEFjY291bnQiLAogICAgICAgICAgInVzZXJTZXR1cEFsbG93ZWQiOiBmYWxzZSwKICAgICAgICAgICJhdXRoZXRpY2F0b3JGbG93IjogdHJ1ZQogICAgICAgIH0KICAgICAgXQogICAgfSwKICAgIHsKICAgICAgImlkIjogImVlNTg2ZTY3LTdlYTItNGEwOC1iMzNlLTlhOWZkODdmZWVhYSIsCiAgICAgICJhbGlhcyI6ICJWZXJpZnkgRXhpc3RpbmcgQWNjb3VudCBieSBSZS1hdXRoZW50aWNhdGlvbiIsCiAgICAgICJkZXNjcmlwdGlvbiI6ICJSZWF1dGhlbnRpY2F0aW9uIG9mIGV4aXN0aW5nIGFjY291bnQiLAogICAgICAicHJvdmlkZXJJZCI6ICJiYXNpYy1mbG93IiwKICAgICAgInRvcExldmVsIjogZmFsc2UsCiAgICAgICJidWlsdEluIjogdHJ1ZSwKICAgICAgImF1dGhlbnRpY2F0aW9uRXhlY3V0aW9ucyI6IFsKICAgICAgICB7CiAgICAgICAgICAiYXV0aGVudGljYXRvciI6ICJpZHAtdXNlcm5hbWUtcGFzc3dvcmQtZm9ybSIsCiAgICAgICAgICAicmVxdWlyZW1lbnQiOiAiUkVRVUlSRUQiLAogICAgICAgICAgInByaW9yaXR5IjogMTAsCiAgICAgICAgICAidXNlclNldHVwQWxsb3dlZCI6IGZhbHNlLAogICAgICAgICAgImF1dGhldGljYXRvckZsb3ciOiBmYWxzZQogICAgICAgIH0sCiAgICAgICAgewogICAgICAgICAgInJlcXVpcmVtZW50IjogIkNPTkRJVElPTkFMIiwKICAgICAgICAgICJwcmlvcml0eSI6IDIwLAogICAgICAgICAgImZsb3dBbGlhcyI6ICJGaXJzdCBicm9rZXIgbG9naW4gLSBDb25kaXRpb25hbCBPVFAiLAogICAgICAgICAgInVzZXJTZXR1cEFsbG93ZWQiOiBmYWxzZSwKICAgICAgICAgICJhdXRoZXRpY2F0b3JGbG93IjogdHJ1ZQogICAgICAgIH0KICAgICAgXQogICAgfSwKICAgIHsKICAgICAgImlkIjogIjExNzE1MTA4LWM1ZTYtNDgyZC1hODdiLTIzOGIxZjRlOTkzNCIsCiAgICAgICJhbGlhcyI6ICJicm93c2VyIiwKICAgICAgImRlc2NyaXB0aW9uIjogImJyb3dzZXIgYmFzZWQgYXV0aGVudGljYXRpb24iLAogICAgICAicHJvdmlkZXJJZCI6ICJiYXNpYy1mbG93IiwKICAgICAgInRvcExldmVsIjogdHJ1ZSwKICAgICAgImJ1aWx0SW4iOiB0cnVlLAogICAgICAiYXV0aGVudGljYXRpb25FeGVjdXRpb25zIjogWwogICAgICAgIHsKICAgICAgICAgICJhdXRoZW50aWNhdG9yIjogImF1dGgtY29va2llIiwKICAgICAgICAgICJyZXF1aXJlbWVudCI6ICJBTFRFUk5BVElWRSIsCiAgICAgICAgICAicHJpb3JpdHkiOiAxMCwKICAgICAgICAgICJ1c2VyU2V0dXBBbGxvd2VkIjogZmFsc2UsCiAgICAgICAgICAiYXV0aGV0aWNhdG9yRmxvdyI6IGZhbHNlCiAgICAgICAgfSwKICAgICAgICB7CiAgICAgICAgICAiYXV0aGVudGljYXRvciI6ICJhdXRoLXNwbmVnbyIsCiAgICAgICAgICAicmVxdWlyZW1lbnQiOiAiRElTQUJMRUQiLAogICAgICAgICAgInByaW9yaXR5IjogMjAsCiAgICAgICAgICAidXNlclNldHVwQWxsb3dlZCI6IGZhbHNlLAogICAgICAgICAgImF1dGhldGljYXRvckZsb3ciOiBmYWxzZQogICAgICAgIH0sCiAgICAgICAgewogICAgICAgICAgImF1dGhlbnRpY2F0b3IiOiAiaWRlbnRpdHktcHJvdmlkZXItcmVkaXJlY3RvciIsCiAgICAgICAgICAicmVxdWlyZW1lbnQiOiAiQUxURVJOQVRJVkUiLAogICAgICAgICAgInByaW9yaXR5IjogMjUsCiAgICAgICAgICAidXNlclNldHVwQWxsb3dlZCI6IGZhbHNlLAogICAgICAgICAgImF1dGhldGljYXRvckZsb3ciOiBmYWxzZQogICAgICAgIH0sCiAgICAgICAgewogICAgICAgICAgInJlcXVpcmVtZW50IjogIkFMVEVSTkFUSVZFIiwKICAgICAgICAgICJwcmlvcml0eSI6IDMwLAogICAgICAgICAgImZsb3dBbGlhcyI6ICJmb3JtcyIsCiAgICAgICAgICAidXNlclNldHVwQWxsb3dlZCI6IGZhbHNlLAogICAgICAgICAgImF1dGhldGljYXRvckZsb3ciOiB0cnVlCiAgICAgICAgfQogICAgICBdCiAgICB9LAogICAgewogICAgICAiaWQiOiAiYTM3NGY4MzEtMzRhYi00YjA3LWI4ZGItMjkxZDUyNWVkOTRjIiwKICAgICAgImFsaWFzIjogImNsaWVudHMiLAogICAgICAiZGVzY3JpcHRpb24iOiAiQmFzZSBhdXRoZW50aWNhdGlvbiBmb3IgY2xpZW50cyIsCiAgICAgICJwcm92aWRlcklkIjogImNsaWVudC1mbG93IiwKICAgICAgInRvcExldmVsIjogdHJ1ZSwKICAgICAgImJ1aWx0SW4iOiB0cnVlLAogICAgICAiYXV0aGVudGljYXRpb25FeGVjdXRpb25zIjogWwogICAgICAgIHsKICAgICAgICAgICJhdXRoZW50aWNhdG9yIjogImNsaWVudC1zZWNyZXQiLAogICAgICAgICAgInJlcXVpcmVtZW50IjogIkFMVEVSTkFUSVZFIiwKICAgICAgICAgICJwcmlvcml0eSI6IDEwLAogICAgICAgICAgInVzZXJTZXR1cEFsbG93ZWQiOiBmYWxzZSwKICAgICAgICAgICJhdXRoZXRpY2F0b3JGbG93IjogZmFsc2UKICAgICAgICB9LAogICAgICAgIHsKICAgICAgICAgICJhdXRoZW50aWNhdG9yIjogImNsaWVudC1qd3QiLAogICAgICAgICAgInJlcXVpcmVtZW50IjogIkFMVEVSTkFUSVZFIiwKICAgICAgICAgICJwcmlvcml0eSI6IDIwLAogICAgICAgICAgInVzZXJTZXR1cEFsbG93ZWQiOiBmYWxzZSwKICAgICAgICAgICJhdXRoZXRpY2F0b3JGbG93IjogZmFsc2UKICAgICAgICB9LAogICAgICAgIHsKICAgICAgICAgICJhdXRoZW50aWNhdG9yIjogImNsaWVudC1zZWNyZXQtand0IiwKICAgICAgICAgICJyZXF1aXJlbWVudCI6ICJBTFRFUk5BVElWRSIsCiAgICAgICAgICAicHJpb3JpdHkiOiAzMCwKICAgICAgICAgICJ1c2VyU2V0dXBBbGxvd2VkIjogZmFsc2UsCiAgICAgICAgICAiYXV0aGV0aWNhdG9yRmxvdyI6IGZhbHNlCiAgICAgICAgfSwKICAgICAgICB7CiAgICAgICAgICAiYXV0aGVudGljYXRvciI6ICJjbGllbnQteDUwOSIsCiAgICAgICAgICAicmVxdWlyZW1lbnQiOiAiQUxURVJOQVRJVkUiLAogICAgICAgICAgInByaW9yaXR5IjogNDAsCiAgICAgICAgICAidXNlclNldHVwQWxsb3dlZCI6IGZhbHNlLAogICAgICAgICAgImF1dGhldGljYXRvckZsb3ciOiBmYWxzZQogICAgICAgIH0KICAgICAgXQogICAgfSwKICAgIHsKICAgICAgImlkIjogIjAwZDc5ZjcyLWUyY2UtNDM4NC04YjhmLTRiMTcxOTkyOGRkZSIsCiAgICAgICJhbGlhcyI6ICJkaXJlY3QgZ3JhbnQiLAogICAgICAiZGVzY3JpcHRpb24iOiAiT3BlbklEIENvbm5lY3QgUmVzb3VyY2UgT3duZXIgR3JhbnQiLAogICAgICAicHJvdmlkZXJJZCI6ICJiYXNpYy1mbG93IiwKICAgICAgInRvcExldmVsIjogdHJ1ZSwKICAgICAgImJ1aWx0SW4iOiB0cnVlLAogICAgICAiYXV0aGVudGljYXRpb25FeGVjdXRpb25zIjogWwogICAgICAgIHsKICAgICAgICAgICJhdXRoZW50aWNhdG9yIjogImRpcmVjdC1ncmFudC12YWxpZGF0ZS11c2VybmFtZSIsCiAgICAgICAgICAicmVxdWlyZW1lbnQiOiAiUkVRVUlSRUQiLAogICAgICAgICAgInByaW9yaXR5IjogMTAsCiAgICAgICAgICAidXNlclNldHVwQWxsb3dlZCI6IGZhbHNlLAogICAgICAgICAgImF1dGhldGljYXRvckZsb3ciOiBmYWxzZQogICAgICAgIH0sCiAgICAgICAgewogICAgICAgICAgImF1dGhlbnRpY2F0b3IiOiAiZGlyZWN0LWdyYW50LXZhbGlkYXRlLXBhc3N3b3JkIiwKICAgICAgICAgICJyZXF1aXJlbWVudCI6ICJSRVFVSVJFRCIsCiAgICAgICAgICAicHJpb3JpdHkiOiAyMCwKICAgICAgICAgICJ1c2VyU2V0dXBBbGxvd2VkIjogZmFsc2UsCiAgICAgICAgICAiYXV0aGV0aWNhdG9yRmxvdyI6IGZhbHNlCiAgICAgICAgfSwKICAgICAgICB7CiAgICAgICAgICAicmVxdWlyZW1lbnQiOiAiQ09ORElUSU9OQUwiLAogICAgICAgICAgInByaW9yaXR5IjogMzAsCiAgICAgICAgICAiZmxvd0FsaWFzIjogIkRpcmVjdCBHcmFudCAtIENvbmRpdGlvbmFsIE9UUCIsCiAgICAgICAgICAidXNlclNldHVwQWxsb3dlZCI6IGZhbHNlLAogICAgICAgICAgImF1dGhldGljYXRvckZsb3ciOiB0cnVlCiAgICAgICAgfQogICAgICBdCiAgICB9LAogICAgewogICAgICAiaWQiOiAiNjYyODFiZTAtZDBmNC00OWI3LWE1YzktMDVkMmM2MzAwMWQwIiwKICAgICAgImFsaWFzIjogImRvY2tlciBhdXRoIiwKICAgICAgImRlc2NyaXB0aW9uIjogIlVzZWQgYnkgRG9ja2VyIGNsaWVudHMgdG8gYXV0aGVudGljYXRlIGFnYWluc3QgdGhlIElEUCIsCiAgICAgICJwcm92aWRlcklkIjogImJhc2ljLWZsb3ciLAogICAgICAidG9wTGV2ZWwiOiB0cnVlLAogICAgICAiYnVpbHRJbiI6IHRydWUsCiAgICAgICJhdXRoZW50aWNhdGlvbkV4ZWN1dGlvbnMiOiBbCiAgICAgICAgewogICAgICAgICAgImF1dGhlbnRpY2F0b3IiOiAiZG9ja2VyLWh0dHAtYmFzaWMtYXV0aGVudGljYXRvciIsCiAgICAgICAgICAicmVxdWlyZW1lbnQiOiAiUkVRVUlSRUQiLAogICAgICAgICAgInByaW9yaXR5IjogMTAsCiAgICAgICAgICAidXNlclNldHVwQWxsb3dlZCI6IGZhbHNlLAogICAgICAgICAgImF1dGhldGljYXRvckZsb3ciOiBmYWxzZQogICAgICAgIH0KICAgICAgXQogICAgfSwKICAgIHsKICAgICAgImlkIjogIjMxNDM3YmExLTM0NWQtNDkyYS1hN2Q2LTJmYzJlNzI4YTdjOSIsCiAgICAgICJhbGlhcyI6ICJmaXJzdCBicm9rZXIgbG9naW4iLAogICAgICAiZGVzY3JpcHRpb24iOiAiQWN0aW9ucyB0YWtlbiBhZnRlciBmaXJzdCBicm9rZXIgbG9naW4gd2l0aCBpZGVudGl0eSBwcm92aWRlciBhY2NvdW50LCB3aGljaCBpcyBub3QgeWV0IGxpbmtlZCB0byBhbnkgS2V5Y2xvYWsgYWNjb3VudCIsCiAgICAgICJwcm92aWRlcklkIjogImJhc2ljLWZsb3ciLAogICAgICAidG9wTGV2ZWwiOiB0cnVlLAogICAgICAiYnVpbHRJbiI6IHRydWUsCiAgICAgICJhdXRoZW50aWNhdGlvbkV4ZWN1dGlvbnMiOiBbCiAgICAgICAgewogICAgICAgICAgImF1dGhlbnRpY2F0b3JDb25maWciOiAicmV2aWV3IHByb2ZpbGUgY29uZmlnIiwKICAgICAgICAgICJhdXRoZW50aWNhdG9yIjogImlkcC1yZXZpZXctcHJvZmlsZSIsCiAgICAgICAgICAicmVxdWlyZW1lbnQiOiAiUkVRVUlSRUQiLAogICAgICAgICAgInByaW9yaXR5IjogMTAsCiAgICAgICAgICAidXNlclNldHVwQWxsb3dlZCI6IGZhbHNlLAogICAgICAgICAgImF1dGhldGljYXRvckZsb3ciOiBmYWxzZQogICAgICAgIH0sCiAgICAgICAgewogICAgICAgICAgInJlcXVpcmVtZW50IjogIlJFUVVJUkVEIiwKICAgICAgICAgICJwcmlvcml0eSI6IDIwLAogICAgICAgICAgImZsb3dBbGlhcyI6ICJVc2VyIGNyZWF0aW9uIG9yIGxpbmtpbmciLAogICAgICAgICAgInVzZXJTZXR1cEFsbG93ZWQiOiBmYWxzZSwKICAgICAgICAgICJhdXRoZXRpY2F0b3JGbG93IjogdHJ1ZQogICAgICAgIH0KICAgICAgXQogICAgfSwKICAgIHsKICAgICAgImlkIjogIjM5NzVjNjZhLTc4MmEtNGY0Zi1iYTkwLTVhODAwNDY4YTA4OCIsCiAgICAgICJhbGlhcyI6ICJmb3JtcyIsCiAgICAgICJkZXNjcmlwdGlvbiI6ICJVc2VybmFtZSwgcGFzc3dvcmQsIG90cCBhbmQgb3RoZXIgYXV0aCBmb3Jtcy4iLAogICAgICAicHJvdmlkZXJJZCI6ICJiYXNpYy1mbG93IiwKICAgICAgInRvcExldmVsIjogZmFsc2UsCiAgICAgICJidWlsdEluIjogdHJ1ZSwKICAgICAgImF1dGhlbnRpY2F0aW9uRXhlY3V0aW9ucyI6IFsKICAgICAgICB7CiAgICAgICAgICAiYXV0aGVudGljYXRvciI6ICJhdXRoLXVzZXJuYW1lLXBhc3N3b3JkLWZvcm0iLAogICAgICAgICAgInJlcXVpcmVtZW50IjogIlJFUVVJUkVEIiwKICAgICAgICAgICJwcmlvcml0eSI6IDEwLAogICAgICAgICAgInVzZXJTZXR1cEFsbG93ZWQiOiBmYWxzZSwKICAgICAgICAgICJhdXRoZXRpY2F0b3JGbG93IjogZmFsc2UKICAgICAgICB9LAogICAgICAgIHsKICAgICAgICAgICJyZXF1aXJlbWVudCI6ICJDT05ESVRJT05BTCIsCiAgICAgICAgICAicHJpb3JpdHkiOiAyMCwKICAgICAgICAgICJmbG93QWxpYXMiOiAiQnJvd3NlciAtIENvbmRpdGlvbmFsIE9UUCIsCiAgICAgICAgICAidXNlclNldHVwQWxsb3dlZCI6IGZhbHNlLAogICAgICAgICAgImF1dGhldGljYXRvckZsb3ciOiB0cnVlCiAgICAgICAgfQogICAgICBdCiAgICB9LAogICAgewogICAgICAiaWQiOiAiYjY4OTIxMDctNWY2MS00ZDRmLWJhYmItYjg4OWVjYmQyNThlIiwKICAgICAgImFsaWFzIjogImh0dHAgY2hhbGxlbmdlIiwKICAgICAgImRlc2NyaXB0aW9uIjogIkFuIGF1dGhlbnRpY2F0aW9uIGZsb3cgYmFzZWQgb24gY2hhbGxlbmdlLXJlc3BvbnNlIEhUVFAgQXV0aGVudGljYXRpb24gU2NoZW1lcyIsCiAgICAgICJwcm92aWRlcklkIjogImJhc2ljLWZsb3ciLAogICAgICAidG9wTGV2ZWwiOiB0cnVlLAogICAgICAiYnVpbHRJbiI6IHRydWUsCiAgICAgICJhdXRoZW50aWNhdGlvbkV4ZWN1dGlvbnMiOiBbCiAgICAgICAgewogICAgICAgICAgImF1dGhlbnRpY2F0b3IiOiAibm8tY29va2llLXJlZGlyZWN0IiwKICAgICAgICAgICJyZXF1aXJlbWVudCI6ICJSRVFVSVJFRCIsCiAgICAgICAgICAicHJpb3JpdHkiOiAxMCwKICAgICAgICAgICJ1c2VyU2V0dXBBbGxvd2VkIjogZmFsc2UsCiAgICAgICAgICAiYXV0aGV0aWNhdG9yRmxvdyI6IGZhbHNlCiAgICAgICAgfSwKICAgICAgICB7CiAgICAgICAgICAicmVxdWlyZW1lbnQiOiAiUkVRVUlSRUQiLAogICAgICAgICAgInByaW9yaXR5IjogMjAsCiAgICAgICAgICAiZmxvd0FsaWFzIjogIkF1dGhlbnRpY2F0aW9uIE9wdGlvbnMiLAogICAgICAgICAgInVzZXJTZXR1cEFsbG93ZWQiOiBmYWxzZSwKICAgICAgICAgICJhdXRoZXRpY2F0b3JGbG93IjogdHJ1ZQogICAgICAgIH0KICAgICAgXQogICAgfSwKICAgIHsKICAgICAgImlkIjogImFjNzRlNGE5LTBkZjUtNGVmNC05MDM2LTAwY2U1NjliNjQ0MCIsCiAgICAgICJhbGlhcyI6ICJyZWdpc3RyYXRpb24iLAogICAgICAiZGVzY3JpcHRpb24iOiAicmVnaXN0cmF0aW9uIGZsb3ciLAogICAgICAicHJvdmlkZXJJZCI6ICJiYXNpYy1mbG93IiwKICAgICAgInRvcExldmVsIjogdHJ1ZSwKICAgICAgImJ1aWx0SW4iOiB0cnVlLAogICAgICAiYXV0aGVudGljYXRpb25FeGVjdXRpb25zIjogWwogICAgICAgIHsKICAgICAgICAgICJhdXRoZW50aWNhdG9yIjogInJlZ2lzdHJhdGlvbi1wYWdlLWZvcm0iLAogICAgICAgICAgInJlcXVpcmVtZW50IjogIlJFUVVJUkVEIiwKICAgICAgICAgICJwcmlvcml0eSI6IDEwLAogICAgICAgICAgImZsb3dBbGlhcyI6ICJyZWdpc3RyYXRpb24gZm9ybSIsCiAgICAgICAgICAidXNlclNldHVwQWxsb3dlZCI6IGZhbHNlLAogICAgICAgICAgImF1dGhldGljYXRvckZsb3ciOiB0cnVlCiAgICAgICAgfQogICAgICBdCiAgICB9LAogICAgewogICAgICAiaWQiOiAiODY4YWQ0YmMtNWQ0MS00NmZlLWJmZGUtY2IwMzIwMGU1M2YwIiwKICAgICAgImFsaWFzIjogInJlZ2lzdHJhdGlvbiBmb3JtIiwKICAgICAgImRlc2NyaXB0aW9uIjogInJlZ2lzdHJhdGlvbiBmb3JtIiwKICAgICAgInByb3ZpZGVySWQiOiAiZm9ybS1mbG93IiwKICAgICAgInRvcExldmVsIjogZmFsc2UsCiAgICAgICJidWlsdEluIjogdHJ1ZSwKICAgICAgImF1dGhlbnRpY2F0aW9uRXhlY3V0aW9ucyI6IFsKICAgICAgICB7CiAgICAgICAgICAiYXV0aGVudGljYXRvciI6ICJyZWdpc3RyYXRpb24tdXNlci1jcmVhdGlvbiIsCiAgICAgICAgICAicmVxdWlyZW1lbnQiOiAiUkVRVUlSRUQiLAogICAgICAgICAgInByaW9yaXR5IjogMjAsCiAgICAgICAgICAidXNlclNldHVwQWxsb3dlZCI6IGZhbHNlLAogICAgICAgICAgImF1dGhldGljYXRvckZsb3ciOiBmYWxzZQogICAgICAgIH0sCiAgICAgICAgewogICAgICAgICAgImF1dGhlbnRpY2F0b3IiOiAicmVnaXN0cmF0aW9uLXByb2ZpbGUtYWN0aW9uIiwKICAgICAgICAgICJyZXF1aXJlbWVudCI6ICJSRVFVSVJFRCIsCiAgICAgICAgICAicHJpb3JpdHkiOiA0MCwKICAgICAgICAgICJ1c2VyU2V0dXBBbGxvd2VkIjogZmFsc2UsCiAgICAgICAgICAiYXV0aGV0aWNhdG9yRmxvdyI6IGZhbHNlCiAgICAgICAgfSwKICAgICAgICB7CiAgICAgICAgICAiYXV0aGVudGljYXRvciI6ICJyZWdpc3RyYXRpb24tcGFzc3dvcmQtYWN0aW9uIiwKICAgICAgICAgICJyZXF1aXJlbWVudCI6ICJSRVFVSVJFRCIsCiAgICAgICAgICAicHJpb3JpdHkiOiA1MCwKICAgICAgICAgICJ1c2VyU2V0dXBBbGxvd2VkIjogZmFsc2UsCiAgICAgICAgICAiYXV0aGV0aWNhdG9yRmxvdyI6IGZhbHNlCiAgICAgICAgfSwKICAgICAgICB7CiAgICAgICAgICAiYXV0aGVudGljYXRvciI6ICJyZWdpc3RyYXRpb24tcmVjYXB0Y2hhLWFjdGlvbiIsCiAgICAgICAgICAicmVxdWlyZW1lbnQiOiAiRElTQUJMRUQiLAogICAgICAgICAgInByaW9yaXR5IjogNjAsCiAgICAgICAgICAidXNlclNldHVwQWxsb3dlZCI6IGZhbHNlLAogICAgICAgICAgImF1dGhldGljYXRvckZsb3ciOiBmYWxzZQogICAgICAgIH0KICAgICAgXQogICAgfSwKICAgIHsKICAgICAgImlkIjogIjZlODFjNDYzLWVmYjgtNGI0ZS1iNTE3LTRkNjBjOTM2YmEwMCIsCiAgICAgICJhbGlhcyI6ICJyZXNldCBjcmVkZW50aWFscyIsCiAgICAgICJkZXNjcmlwdGlvbiI6ICJSZXNldCBjcmVkZW50aWFscyBmb3IgYSB1c2VyIGlmIHRoZXkgZm9yZ290IHRoZWlyIHBhc3N3b3JkIG9yIHNvbWV0aGluZyIsCiAgICAgICJwcm92aWRlcklkIjogImJhc2ljLWZsb3ciLAogICAgICAidG9wTGV2ZWwiOiB0cnVlLAogICAgICAiYnVpbHRJbiI6IHRydWUsCiAgICAgICJhdXRoZW50aWNhdGlvbkV4ZWN1dGlvbnMiOiBbCiAgICAgICAgewogICAgICAgICAgImF1dGhlbnRpY2F0b3IiOiAicmVzZXQtY3JlZGVudGlhbHMtY2hvb3NlLXVzZXIiLAogICAgICAgICAgInJlcXVpcmVtZW50IjogIlJFUVVJUkVEIiwKICAgICAgICAgICJwcmlvcml0eSI6IDEwLAogICAgICAgICAgInVzZXJTZXR1cEFsbG93ZWQiOiBmYWxzZSwKICAgICAgICAgICJhdXRoZXRpY2F0b3JGbG93IjogZmFsc2UKICAgICAgICB9LAogICAgICAgIHsKICAgICAgICAgICJhdXRoZW50aWNhdG9yIjogInJlc2V0LWNyZWRlbnRpYWwtZW1haWwiLAogICAgICAgICAgInJlcXVpcmVtZW50IjogIlJFUVVJUkVEIiwKICAgICAgICAgICJwcmlvcml0eSI6IDIwLAogICAgICAgICAgInVzZXJTZXR1cEFsbG93ZWQiOiBmYWxzZSwKICAgICAgICAgICJhdXRoZXRpY2F0b3JGbG93IjogZmFsc2UKICAgICAgICB9LAogICAgICAgIHsKICAgICAgICAgICJhdXRoZW50aWNhdG9yIjogInJlc2V0LXBhc3N3b3JkIiwKICAgICAgICAgICJyZXF1aXJlbWVudCI6ICJSRVFVSVJFRCIsCiAgICAgICAgICAicHJpb3JpdHkiOiAzMCwKICAgICAgICAgICJ1c2VyU2V0dXBBbGxvd2VkIjogZmFsc2UsCiAgICAgICAgICAiYXV0aGV0aWNhdG9yRmxvdyI6IGZhbHNlCiAgICAgICAgfSwKICAgICAgICB7CiAgICAgICAgICAicmVxdWlyZW1lbnQiOiAiQ09ORElUSU9OQUwiLAogICAgICAgICAgInByaW9yaXR5IjogNDAsCiAgICAgICAgICAiZmxvd0FsaWFzIjogIlJlc2V0IC0gQ29uZGl0aW9uYWwgT1RQIiwKICAgICAgICAgICJ1c2VyU2V0dXBBbGxvd2VkIjogZmFsc2UsCiAgICAgICAgICAiYXV0aGV0aWNhdG9yRmxvdyI6IHRydWUKICAgICAgICB9CiAgICAgIF0KICAgIH0sCiAgICB7CiAgICAgICJpZCI6ICIwNWZlODE3OS05OTk1LTQ4ZmMtYmZhMi00M2NmZmEzNWVhODkiLAogICAgICAiYWxpYXMiOiAic2FtbCBlY3AiLAogICAgICAiZGVzY3JpcHRpb24iOiAiU0FNTCBFQ1AgUHJvZmlsZSBBdXRoZW50aWNhdGlvbiBGbG93IiwKICAgICAgInByb3ZpZGVySWQiOiAiYmFzaWMtZmxvdyIsCiAgICAgICJ0b3BMZXZlbCI6IHRydWUsCiAgICAgICJidWlsdEluIjogdHJ1ZSwKICAgICAgImF1dGhlbnRpY2F0aW9uRXhlY3V0aW9ucyI6IFsKICAgICAgICB7CiAgICAgICAgICAiYXV0aGVudGljYXRvciI6ICJodHRwLWJhc2ljLWF1dGhlbnRpY2F0b3IiLAogICAgICAgICAgInJlcXVpcmVtZW50IjogIlJFUVVJUkVEIiwKICAgICAgICAgICJwcmlvcml0eSI6IDEwLAogICAgICAgICAgInVzZXJTZXR1cEFsbG93ZWQiOiBmYWxzZSwKICAgICAgICAgICJhdXRoZXRpY2F0b3JGbG93IjogZmFsc2UKICAgICAgICB9CiAgICAgIF0KICAgIH0KICBdLAogICJhdXRoZW50aWNhdG9yQ29uZmlnIjogWwogICAgewogICAgICAiaWQiOiAiMjFkMzk0YzEtMzI0ZS00ZWQ2LTkxNjMtY2E0YThlNGZhMTM0IiwKICAgICAgImFsaWFzIjogImNyZWF0ZSB1bmlxdWUgdXNlciBjb25maWciLAogICAgICAiY29uZmlnIjogewogICAgICAgICJyZXF1aXJlLnBhc3N3b3JkLnVwZGF0ZS5hZnRlci5yZWdpc3RyYXRpb24iOiAiZmFsc2UiCiAgICAgIH0KICAgIH0sCiAgICB7CiAgICAgICJpZCI6ICJiZjY0ZTdjZC0yYTE5LTQzZTgtYWEwZi1kODdiOTg0MzVmNTMiLAogICAgICAiYWxpYXMiOiAicmV2aWV3IHByb2ZpbGUgY29uZmlnIiwKICAgICAgImNvbmZpZyI6IHsKICAgICAgICAidXBkYXRlLnByb2ZpbGUub24uZmlyc3QubG9naW4iOiAibWlzc2luZyIKICAgICAgfQogICAgfQogIF0sCiAgInJlcXVpcmVkQWN0aW9ucyI6IFsKICAgIHsKICAgICAgImFsaWFzIjogIkNPTkZJR1VSRV9UT1RQIiwKICAgICAgIm5hbWUiOiAiQ29uZmlndXJlIE9UUCIsCiAgICAgICJwcm92aWRlcklkIjogIkNPTkZJR1VSRV9UT1RQIiwKICAgICAgImVuYWJsZWQiOiB0cnVlLAogICAgICAiZGVmYXVsdEFjdGlvbiI6IGZhbHNlLAogICAgICAicHJpb3JpdHkiOiAxMCwKICAgICAgImNvbmZpZyI6IHt9CiAgICB9LAogICAgewogICAgICAiYWxpYXMiOiAidGVybXNfYW5kX2NvbmRpdGlvbnMiLAogICAgICAibmFtZSI6ICJUZXJtcyBhbmQgQ29uZGl0aW9ucyIsCiAgICAgICJwcm92aWRlcklkIjogInRlcm1zX2FuZF9jb25kaXRpb25zIiwKICAgICAgImVuYWJsZWQiOiBmYWxzZSwKICAgICAgImRlZmF1bHRBY3Rpb24iOiBmYWxzZSwKICAgICAgInByaW9yaXR5IjogMjAsCiAgICAgICJjb25maWciOiB7fQogICAgfSwKICAgIHsKICAgICAgImFsaWFzIjogIlVQREFURV9QQVNTV09SRCIsCiAgICAgICJuYW1lIjogIlVwZGF0ZSBQYXNzd29yZCIsCiAgICAgICJwcm92aWRlcklkIjogIlVQREFURV9QQVNTV09SRCIsCiAgICAgICJlbmFibGVkIjogdHJ1ZSwKICAgICAgImRlZmF1bHRBY3Rpb24iOiBmYWxzZSwKICAgICAgInByaW9yaXR5IjogMzAsCiAgICAgICJjb25maWciOiB7fQogICAgfSwKICAgIHsKICAgICAgImFsaWFzIjogIlVQREFURV9QUk9GSUxFIiwKICAgICAgIm5hbWUiOiAiVXBkYXRlIFByb2ZpbGUiLAogICAgICAicHJvdmlkZXJJZCI6ICJVUERBVEVfUFJPRklMRSIsCiAgICAgICJlbmFibGVkIjogdHJ1ZSwKICAgICAgImRlZmF1bHRBY3Rpb24iOiBmYWxzZSwKICAgICAgInByaW9yaXR5IjogNDAsCiAgICAgICJjb25maWciOiB7fQogICAgfSwKICAgIHsKICAgICAgImFsaWFzIjogIlZFUklGWV9FTUFJTCIsCiAgICAgICJuYW1lIjogIlZlcmlmeSBFbWFpbCIsCiAgICAgICJwcm92aWRlcklkIjogIlZFUklGWV9FTUFJTCIsCiAgICAgICJlbmFibGVkIjogdHJ1ZSwKICAgICAgImRlZmF1bHRBY3Rpb24iOiBmYWxzZSwKICAgICAgInByaW9yaXR5IjogNTAsCiAgICAgICJjb25maWciOiB7fQogICAgfQogIF0sCiAgImJyb3dzZXJGbG93IjogImJyb3dzZXIiLAogICJyZWdpc3RyYXRpb25GbG93IjogInJlZ2lzdHJhdGlvbiIsCiAgImRpcmVjdEdyYW50RmxvdyI6ICJkaXJlY3QgZ3JhbnQiLAogICJyZXNldENyZWRlbnRpYWxzRmxvdyI6ICJyZXNldCBjcmVkZW50aWFscyIsCiAgImNsaWVudEF1dGhlbnRpY2F0aW9uRmxvdyI6ICJjbGllbnRzIiwKICAiZG9ja2VyQXV0aGVudGljYXRpb25GbG93IjogImRvY2tlciBhdXRoIiwKICAiYXR0cmlidXRlcyI6IHsKICAgICJ3ZWJBdXRoblBvbGljeUF1dGhlbnRpY2F0b3JBdHRhY2htZW50IjogIm5vdCBzcGVjaWZpZWQiLAogICAgIl9icm93c2VyX2hlYWRlci54Um9ib3RzVGFnIjogIm5vbmUiLAogICAgIndlYkF1dGhuUG9saWN5UnBFbnRpdHlOYW1lIjogImtleWNsb2FrIiwKICAgICJmYWlsdXJlRmFjdG9yIjogIjMwIiwKICAgICJhY3Rpb25Ub2tlbkdlbmVyYXRlZEJ5VXNlckxpZmVzcGFuIjogIjMwMCIsCiAgICAibWF4RGVsdGFUaW1lU2Vjb25kcyI6ICI0MzIwMCIsCiAgICAid2ViQXV0aG5Qb2xpY3lTaWduYXR1cmVBbGdvcml0aG1zIjogIkVTMjU2IiwKICAgICJvZmZsaW5lU2Vzc2lvbk1heExpZmVzcGFuIjogIjUxODQwMDAiLAogICAgIl9icm93c2VyX2hlYWRlci5jb250ZW50U2VjdXJpdHlQb2xpY3lSZXBvcnRPbmx5IjogIiIsCiAgICAiYnJ1dGVGb3JjZVByb3RlY3RlZCI6ICJmYWxzZSIsCiAgICAiX2Jyb3dzZXJfaGVhZGVyLmNvbnRlbnRTZWN1cml0eVBvbGljeSI6ICJmcmFtZS1zcmMgJ3NlbGYnOyBmcmFtZS1hbmNlc3RvcnMgJ3NlbGYnOyBvYmplY3Qtc3JjICdub25lJzsiLAogICAgIl9icm93c2VyX2hlYWRlci54WFNTUHJvdGVjdGlvbiI6ICIxOyBtb2RlPWJsb2NrIiwKICAgICJfYnJvd3Nlcl9oZWFkZXIueEZyYW1lT3B0aW9ucyI6ICJTQU1FT1JJR0lOIiwKICAgICJfYnJvd3Nlcl9oZWFkZXIuc3RyaWN0VHJhbnNwb3J0U2VjdXJpdHkiOiAibWF4LWFnZT0zMTUzNjAwMDsgaW5jbHVkZVN1YkRvbWFpbnMiLAogICAgIndlYkF1dGhuUG9saWN5VXNlclZlcmlmaWNhdGlvblJlcXVpcmVtZW50IjogIm5vdCBzcGVjaWZpZWQiLAogICAgInBlcm1hbmVudExvY2tvdXQiOiAiZmFsc2UiLAogICAgInF1aWNrTG9naW5DaGVja01pbGxpU2Vjb25kcyI6ICIxMDAwIiwKICAgICJ3ZWJBdXRoblBvbGljeUNyZWF0ZVRpbWVvdXQiOiAiMCIsCiAgICAid2ViQXV0aG5Qb2xpY3lSZXF1aXJlUmVzaWRlbnRLZXkiOiAibm90IHNwZWNpZmllZCIsCiAgICAid2ViQXV0aG5Qb2xpY3lScElkIjogIiIsCiAgICAid2ViQXV0aG5Qb2xpY3lBdHRlc3RhdGlvbkNvbnZleWFuY2VQcmVmZXJlbmNlIjogIm5vdCBzcGVjaWZpZWQiLAogICAgIm1heEZhaWx1cmVXYWl0U2Vjb25kcyI6ICI5MDAiLAogICAgIm1pbmltdW1RdWlja0xvZ2luV2FpdFNlY29uZHMiOiAiNjAiLAogICAgIndlYkF1dGhuUG9saWN5QXZvaWRTYW1lQXV0aGVudGljYXRvclJlZ2lzdGVyIjogImZhbHNlIiwKICAgICJfYnJvd3Nlcl9oZWFkZXIueENvbnRlbnRUeXBlT3B0aW9ucyI6ICJub3NuaWZmIiwKICAgICJhY3Rpb25Ub2tlbkdlbmVyYXRlZEJ5QWRtaW5MaWZlc3BhbiI6ICI0MzIwMCIsCiAgICAid2FpdEluY3JlbWVudFNlY29uZHMiOiAiNjAiLAogICAgIm9mZmxpbmVTZXNzaW9uTWF4TGlmZXNwYW5FbmFibGVkIjogImZhbHNlIgogIH0sCiAgImtleWNsb2FrVmVyc2lvbiI6ICI4LjAuMSIsCiAgInVzZXJNYW5hZ2VkQWNjZXNzQWxsb3dlZCI6IGZhbHNlCn0K
  client_id: Ymtwcg==
  client_secret: NmU5ZDRhNDMtMDc5OS00ZTE1LWI5NmQtYWRkN2I4NDJiZDRl
  db_password: ekU5MGllUXlqVEo5WC9uR1pubDNMMXpnQlh6K0dRbW0=
  group: ""
kind: Secret
metadata:
  annotations: {}
  labels:
    name: keycloak
  name: keycloak-b2d6c6b
  namespace: kubeprod
type: Opaque
---
apiVersion: v1
kind: ServiceAccount
metadata:
  annotations: {}
  labels:
    name: keycloak
  name: keycloak
  namespace: kubeprod
---
apiVersion: apps/v1
kind: StatefulSet
metadata:
  annotations: {}
  labels:
    name: keycloak
  name: keycloak
  namespace: kubeprod
spec:
  podManagementPolicy: Parallel
  replicas: 1
  selector:
    matchLabels:
      name: keycloak
  serviceName: keycloak
  template:
    metadata:
      annotations:
        prometheus.io/path: /auth/realms/master/metrics
        prometheus.io/port: "8080"
        prometheus.io/scrape: "true"
      labels:
        name: keycloak
    spec:
      affinity:
        podAntiAffinity:
          preferredDuringSchedulingIgnoredDuringExecution:
          - podAffinityTerm:
              labelSelector:
                matchLabels:
                  name: keycloak
              topologyKey: kubernetes.io/hostname
            weight: 70
          - podAffinityTerm:
              labelSelector:
                matchLabels:
                  name: keycloak
              topologyKey: failure-domain.beta.kubernetes.io/zone
            weight: 70
          - podAffinityTerm:
              labelSelector:
                matchLabels:
                  name: keycloak
              topologyKey: failure-domain.beta.kubernetes.io/region
            weight: 70
      containers:
      - args:
        - -b=0.0.0.0
        - -c=standalone.xml
        - -Dkeycloak.import=/realm/bkpr-realm.json
        command:
        - /opt/jboss/tools/docker-entrypoint.sh
        env:
        - name: DB_ADDR
          value: mariadb-galera.kubeprod.svc
        - name: DB_DATABASE
          value: keycloak
        - name: DB_PASSWORD
          valueFrom:
            secretKeyRef:
              key: db_password
              name: keycloak-b2d6c6b
        - name: DB_PORT
          value: "3306"
        - name: DB_USER
          value: keycloak
        - name: DB_VENDOR
          value: mariadb
        - name: KEYCLOAK_PASSWORD
          valueFrom:
            secretKeyRef:
              key: admin_password
              name: keycloak-b2d6c6b
        - name: KEYCLOAK_USER
          value: admin
        - name: PROXY_ADDRESS_FORWARDING
          value: "true"
        image: jboss/keycloak:8.0.1
        imagePullPolicy: IfNotPresent
        livenessProbe:
          failureThreshold: 3
          httpGet:
            path: /auth/
            port: http
          initialDelaySeconds: 300
          periodSeconds: 10
          successThreshold: 1
        name: keycloak
        ports:
        - containerPort: 8080
          name: http
        - containerPort: 8443
          name: https
        readinessProbe:
          failureThreshold: 3
          httpGet:
            path: /auth/realms/master
            port: http
          initialDelaySeconds: 30
          periodSeconds: 10
          successThreshold: 1
        resources:
          limits:
            cpu: "1"
            memory: 2Gi
          requests:
            cpu: 100m
            memory: 1Gi
        securityContext:
          runAsNonRoot: true
          runAsUser: 1001
        stdin: false
        tty: false
        volumeMounts:
        - mountPath: /opt/jboss/keycloak/standalone/deployments
          name: deployments
        - mountPath: /realm/
          name: secret
          readOnly: true
      imagePullSecrets: []
      initContainers:
      - args: []
        command:
        - sh
        - -c
        - wget -O /deployments/keycloak-metrics-spi.jar https://github.com/aerogear/keycloak-metrics-spi/releases/download/1.0.4/keycloak-metrics-spi-1.0.4.jar
        env: []
        image: busybox
        imagePullPolicy: IfNotPresent
        name: extensions
        ports: []
        stdin: false
        tty: false
        volumeMounts:
        - mountPath: /deployments
          name: deployments
      - args: []
        command:
        - /scripts/setup-db.sh
        env:
        - name: KEYCLOAK_DB_DATABASE
          value: keycloak
        - name: KEYCLOAK_DB_HOST
          value: mariadb-galera.kubeprod.svc
        - name: KEYCLOAK_DB_PASSWORD
          valueFrom:
            secretKeyRef:
              key: db_password
              name: keycloak-b2d6c6b
        - name: KEYCLOAK_DB_PORT
          value: "3306"
        - name: KEYCLOAK_DB_ROOT_PASSWORD
          valueFrom:
            secretKeyRef:
              key: root_password
              name: mariadb-galera-dc69b99
        - name: KEYCLOAK_DB_ROOT_USER
          value: root
        - name: KEYCLOAK_DB_USER
          value: keycloak
        image: bitnami/mariadb-galera:10.5.4-debian-10-r2
        imagePullPolicy: IfNotPresent
        name: setup-db
        ports: []
        stdin: false
        tty: false
        volumeMounts:
        - mountPath: /scripts
          name: scripts
          readOnly: true
      securityContext:
        fsGroup: 1001
      serviceAccountName: keycloak
      terminationGracePeriodSeconds: 60
      volumes:
      - emptyDir: {}
        name: deployments
      - configMap:
          defaultMode: 493
          name: keycloak-sh-1dedc24
        name: scripts
      - name: secret
        secret:
          secretName: keycloak-b2d6c6b
  updateStrategy:
    type: RollingUpdate
  volumeClaimTemplates: []
---
apiVersion: v1
kind: Service
metadata:
  annotations: {}
  labels:
    name: keycloak
  name: keycloak
  namespace: kubeprod
spec:
  ports:
  - name: http
    port: 8080
    targetPort: 8080
  selector:
    name: keycloak
  type: ClusterIP
---
apiVersion: v1
kind: ServiceAccount
metadata:
  annotations: {}
  labels:
    name: kibana
  name: kibana
  namespace: kubeprod
---
apiVersion: v1
kind: Service
metadata:
  annotations: {}
  labels:
    name: kibana-logging
  name: kibana-logging
  namespace: kubeprod
spec:
  ports:
  - name: ui
    port: 5601
    targetPort: 5601
  selector:
    name: kibana
  type: ClusterIP
---
apiVersion: apps/v1
kind: Deployment
metadata:
  annotations: {}
  labels:
    name: kibana
  name: kibana
  namespace: kubeprod
spec:
  minReadySeconds: 30
  replicas: 1
  revisionHistoryLimit: 10
  selector:
    matchLabels:
      name: kibana
  strategy:
    rollingUpdate:
      maxSurge: 0
      maxUnavailable: 1
    type: RollingUpdate
  template:
    metadata:
      annotations: {}
      labels:
        name: kibana
    spec:
      containers:
      - args: []
        env:
        - name: KIBANA_ELASTICSEARCH_URL
          value: elasticsearch-logging.kubeprod.svc
        - name: KIBANA_HOST
          value: 0.0.0.0
        - name: SERVER_BASEPATH
          value: ""
        - name: XPACK_MONITORING_ENABLED
          value: "false"
        - name: XPACK_SECURITY_ENABLED
          value: "false"
        image: bitnami/kibana:7.8.0-debian-10-r2
        imagePullPolicy: IfNotPresent
        name: kibana
        ports:
        - containerPort: 5601
          name: ui
        resources:
          limits:
            cpu: 1000m
          requests:
            cpu: 10m
        securityContext:
          runAsUser: 1001
        stdin: false
        tty: false
        volumeMounts:
        - mountPath: /opt/bitnami/kibana/plugins
          name: plugins
      imagePullSecrets: []
      initContainers:
      - args: []
        command:
        - /bin/sh
        - -c
        - |
          set -e
          rm -rf /opt/bitnami/kibana/plugins/lost+found
          echo '' | sort > /tmp/wanted.list
          /opt/bitnami/kibana/bin/kibana-plugin list | grep @ | sort > /tmp/installed.list
          join -v2 -t, -j1 /tmp/wanted.list /tmp/installed.list | while read plugin; do
            ${plugin:+/opt/bitnami/kibana/bin/kibana-plugin remove "${plugin%@*}"}
          done
          join -v1 -t, -j1 -o1.2 /tmp/wanted.list /tmp/installed.list | while read url; do
            ${url:+/opt/bitnami/kibana/bin/kibana-plugin install --no-optimize "$url"}
          done
        env: []
        image: bitnami/kibana:7.8.0-debian-10-r2
        imagePullPolicy: IfNotPresent
        name: kibana-plugins-install
        ports: []
        securityContext:
          allowPrivilegeEscalation: false
        stdin: false
        tty: false
        volumeMounts:
        - mountPath: /opt/bitnami/kibana/plugins
          name: plugins
      securityContext:
        fsGroup: 1001
      terminationGracePeriodSeconds: 30
      volumes:
      - name: plugins
        persistentVolumeClaim:
          claimName: kibana-plugins
---
apiVersion: networking.k8s.io/v1beta1
kind: Ingress
metadata:
  annotations:
    kubernetes.io/ingress.class: nginx
    kubernetes.io/tls-acme: "true"
    nginx.ingress.kubernetes.io/auth-response-headers: X-Auth-Request-User, X-Auth-Request-Email
    nginx.ingress.kubernetes.io/auth-signin: https://auth.hosteaching.ovh/oauth2/start?rd=%2F$server_name$escaped_request_uri
    nginx.ingress.kubernetes.io/auth-url: https://auth.hosteaching.ovh/oauth2/auth
  labels:
    name: kibana-logging
  name: kibana-logging
  namespace: kubeprod
spec:
  rules:
  - host: kibana.hosteaching.ovh
    http:
      paths:
      - backend:
          serviceName: kibana-logging
          servicePort: 5601
        path: /
  tls:
  - hosts:
    - kibana.hosteaching.ovh
    secretName: kibana-logging-tls
---
apiVersion: v1
kind: PersistentVolumeClaim
metadata:
  annotations: {}
  labels:
    name: kibana-plugins
  name: kibana-plugins
  namespace: kubeprod
spec:
  accessModes:
  - ReadWriteOnce
  resources:
    requests:
      storage: 2Gi
  storageClassName: rook-cephfs
---
apiVersion: v1
kind: ServiceAccount
metadata:
  annotations: {}
  labels:
    name: prometheus
  name: prometheus
  namespace: kubeprod
---
apiVersion: v1
kind: Service
metadata:
  annotations: {}
  labels:
    name: prometheus
  name: prometheus
  namespace: kubeprod
spec:
  ports:
  - name: web
    port: 9090
    targetPort: 9090
  selector:
    name: prometheus
  type: ClusterIP
---
apiVersion: v1
data:
  basic.yaml: |
    groups:
    - name: basic.rules
      rules:
      - alert: CrashLooping
        annotations:
          message: Pod {{ $labels.namespace }}/{{ $labels.pod }} ({{ $labels.container
            }}) is restarting {{ $value }} times / 5 minutes.
        expr: rate(kube_pod_container_status_restarts_total[15m]) * 60 * 5 > 0
        for: 1h
        labels:
          severity: critical
      - alert: K8sApiUnavailable
        annotations:
          message: Kubernetes API has disappeared from Prometheus target discovery
        expr: absent(up{job="kubernetes-apiservers"} == 1)
        for: 15m
        labels:
          severity: critical
  monitoring.yml: |
    groups:
    - name: monitoring.rules
      rules:
      - alert: AlertmanagerBadConfig
        annotations:
          message: Reloading Alertmanager's configuration has failed for {{ $labels.namespace
            }}/{{ $labels.pod }}.
        expr: alertmanager_config_last_reload_successful{kubernetes_namespace="kubeprod"}
          == 0
        for: 10m
        labels:
          severity: warning
      - alert: PrometheusBadConfig
        annotations:
          message: Prometheus {{ $labels.namespace }}/{{ $labels.pod }} has failed to
            reload its configuration.
        expr: max_over_time(prometheus_config_last_reload_successful{kubernetes_namespace="kubeprod"}[5m])
          == 0
        for: 10m
        labels:
          severity: critical
  prometheus.yml: |
    alerting:
      alertmanagers:
      - kubernetes_sd_configs:
        - role: endpoints
        path_prefix: /alertmanager
        relabel_configs:
        - action: keep
          regex: kubeprod;alertmanager;alertmanager
          source_labels:
          - __meta_kubernetes_namespace
          - __meta_kubernetes_service_name
          - __meta_kubernetes_endpoint_port_name
    global:
      evaluation_interval: 60s
      scrape_interval: 60s
    rule_files:
    - basic.yaml
    - monitoring.yml
    scrape_configs:
    - bearer_token_file: /var/run/secrets/kubernetes.io/serviceaccount/token
      job_name: kubernetes-apiservers
      kubernetes_sd_configs:
      - role: endpoints
      relabel_configs:
      - action: keep
        regex: default;kubernetes;https
        source_labels:
        - __meta_kubernetes_namespace
        - __meta_kubernetes_service_name
        - __meta_kubernetes_endpoint_port_name
      scheme: https
      tls_config:
        ca_file: /var/run/secrets/kubernetes.io/serviceaccount/ca.crt
    - bearer_token_file: /var/run/secrets/kubernetes.io/serviceaccount/token
      job_name: kubernetes-cadvisor
      kubernetes_sd_configs:
      - role: node
      relabel_configs:
      - action: labelmap
        regex: __meta_kubernetes_node_label_(.+)
      - replacement: kubernetes.default.svc:443
        target_label: __address__
      - regex: (.+)
        replacement: /api/v1/nodes/${1}/proxy/metrics/cadvisor
        source_labels:
        - __meta_kubernetes_node_name
        target_label: __metrics_path__
      scheme: https
      tls_config:
        ca_file: /var/run/secrets/kubernetes.io/serviceaccount/ca.crt
    - job_name: kubernetes-ingresses
      kubernetes_sd_configs:
      - role: ingress
      metrics_path: /probe
      params:
        module:
        - http_2xx
      relabel_configs:
      - action: keep
        regex: true
        source_labels:
        - __meta_kubernetes_ingress_annotation_prometheus_io_probe
      - regex: (.+);(.+);(.+)
        replacement: ${1}://${2}${3}
        source_labels:
        - __meta_kubernetes_ingress_scheme
        - __address__
        - __meta_kubernetes_ingress_path
        target_label: __param_target
      - replacement: blackbox-exporter:9115
        target_label: __address__
      - source_labels:
        - __param_target
        target_label: instance
      - action: labelmap
        regex: __meta_kubernetes_ingress_label_(.+)
      - source_labels:
        - __meta_kubernetes_namespace
        target_label: kubernetes_namespace
      - source_labels:
        - __meta_kubernetes_ingress_name
        target_label: kubernetes_name
    - bearer_token_file: /var/run/secrets/kubernetes.io/serviceaccount/token
      job_name: kubernetes-nodes
      kubernetes_sd_configs:
      - role: node
      relabel_configs:
      - action: labelmap
        regex: __meta_kubernetes_node_label_(.+)
      - replacement: kubernetes.default.svc:443
        target_label: __address__
      - regex: (.+)
        replacement: /api/v1/nodes/${1}/proxy/metrics
        source_labels:
        - __meta_kubernetes_node_name
        target_label: __metrics_path__
      scheme: https
      tls_config:
        ca_file: /var/run/secrets/kubernetes.io/serviceaccount/ca.crt
    - job_name: kubernetes-pods
      kubernetes_sd_configs:
      - role: pod
      relabel_configs:
      - action: keep
        regex: true
        source_labels:
        - __meta_kubernetes_pod_annotation_prometheus_io_scrape
      - action: replace
        regex: (.+)
        source_labels:
        - __meta_kubernetes_pod_annotation_prometheus_io_path
        target_label: __metrics_path__
      - action: replace
        regex: ([^:]+)(?::\d+)?;(\d+)
        replacement: $1:$2
        source_labels:
        - __address__
        - __meta_kubernetes_pod_annotation_prometheus_io_port
        target_label: __address__
      - action: labelmap
        regex: __meta_kubernetes_pod_label_(.+)
      - action: replace
        source_labels:
        - __meta_kubernetes_namespace
        target_label: kubernetes_namespace
      - action: replace
        source_labels:
        - __meta_kubernetes_pod_name
        target_label: kubernetes_pod_name
    - job_name: prometheus
      static_configs:
      - targets:
        - localhost:9090
    - bearer_token_file: /var/run/secrets/kubernetes.io/serviceaccount/token
      job_name: kubernetes-service-endpoints
      kubernetes_sd_configs:
      - role: endpoints
      relabel_configs:
      - action: keep
        regex: true
        source_labels:
        - __meta_kubernetes_service_annotation_prometheus_io_scrape
      - action: replace
        regex: (https?)
        source_labels:
        - __meta_kubernetes_service_annotation_prometheus_io_scheme
        target_label: __scheme__
      - action: replace
        regex: (.+)
        source_labels:
        - __meta_kubernetes_service_annotation_prometheus_io_path
        target_label: __metrics_path__
      - action: replace
        regex: ([^:]+)(?::\d+)?;(\d+)
        replacement: $1:$2
        source_labels:
        - __address__
        - __meta_kubernetes_service_annotation_prometheus_io_port
        target_label: __address__
      - action: labelmap
        regex: __meta_kubernetes_service_label_(.+)
      - action: replace
        source_labels:
        - __meta_kubernetes_namespace
        target_label: kubernetes_namespace
      - action: replace
        source_labels:
        - __meta_kubernetes_service_name
        target_label: kubernetes_name
      scheme: http
      tls_config:
        ca_file: /var/run/secrets/kubernetes.io/serviceaccount/ca.crt
    - job_name: kubernetes-services
      kubernetes_sd_configs:
      - role: service
      metrics_path: /probe
      params:
        module:
        - http_2xx
      relabel_configs:
      - action: keep
        regex: true
        source_labels:
        - __meta_kubernetes_service_annotation_prometheus_io_probe
      - source_labels:
        - __address__
        target_label: __param_target
      - replacement: blackbox-exporter:9115
        target_label: __address__
      - source_labels:
        - __param_target
        target_label: instance
      - action: labelmap
        regex: __meta_kubernetes_service_label_(.+)
      - source_labels:
        - __meta_kubernetes_namespace
        target_label: kubernetes_namespace
      - source_labels:
        - __meta_kubernetes_service_name
        target_label: kubernetes_name
kind: ConfigMap
metadata:
  annotations: {}
  labels:
    name: prometheus
  name: prometheus
  namespace: kubeprod
---
apiVersion: apps/v1
kind: StatefulSet
metadata:
  annotations: {}
  labels:
    name: prometheus
  name: prometheus
  namespace: kubeprod
spec:
  replicas: 1
  selector:
    matchLabels:
      name: prometheus
  serviceName: prometheus
  template:
    metadata:
      annotations:
        prometheus.io/path: /metrics
        prometheus.io/port: "9090"
        prometheus.io/scrape: "true"
      labels:
        name: prometheus
    spec:
      containers:
      - args:
        - --config.file=/opt/bitnami/prometheus/conf/custom/prometheus.yml
        - --storage.tsdb.retention.time=183d
        - --web.console.libraries=/opt/bitnami/prometheus/conf/console_libraries
        - --web.console.templates=/opt/bitnami/prometheus/conf/consoles
        - --web.external-url=http://prometheus.hosteaching.ovh/
        - --web.enable-lifecycle
        env: []
        image: bitnami/prometheus:2.19.2-debian-10-r1
        imagePullPolicy: IfNotPresent
        livenessProbe:
          httpGet:
            path: /
            port: web
          initialDelaySeconds: 1200
          successThreshold: 1
        name: prometheus
        ports:
        - containerPort: 9090
          name: web
        readinessProbe:
          httpGet:
            path: /
            port: web
          initialDelaySeconds: 5
          successThreshold: 2
        resources:
          requests:
            cpu: 500m
            memory: 500Mi
        securityContext:
          runAsUser: 1001
        stdin: false
        tty: false
        volumeMounts:
        - mountPath: /opt/bitnami/prometheus/conf/custom
          name: config
          readOnly: true
        - mountPath: /opt/bitnami/prometheus/data
          name: data
      - args:
        - --volume-dir=/config
        - --webhook-method=POST
        - --webhook-url=http://localhost:9090/-/reload
        env: []
        image: bitnami/configmap-reload:0.4.0-debian-10-r1
        imagePullPolicy: IfNotPresent
        name: configmap-reload
        ports: []
        stdin: false
        tty: false
        volumeMounts:
        - mountPath: /config
          name: config
          readOnly: true
      imagePullSecrets: []
      initContainers: []
      securityContext:
        fsGroup: 1001
      serviceAccountName: prometheus
      terminationGracePeriodSeconds: 300
      volumes:
      - configMap:
          name: prometheus
        name: config
  updateStrategy:
    rollingUpdate:
      partition: 0
    type: RollingUpdate
  volumeClaimTemplates:
  - metadata:
      labels:
        name: data
      name: data
    spec:
      accessModes:
      - ReadWriteOnce
      storageClassName: "rook-cephfs"
      resources:
        requests:
          storage: 7905Mi
---
apiVersion: rbac.authorization.k8s.io/v1beta1
kind: ClusterRoleBinding
metadata:
  annotations: {}
  labels:
    name: prometheus
  name: prometheus
roleRef:
  apiGroup: rbac.authorization.k8s.io
  kind: ClusterRole
  name: prometheus
subjects:
- kind: ServiceAccount
  name: prometheus
  namespace: kubeprod
---
apiVersion: rbac.authorization.k8s.io/v1beta1
kind: ClusterRole
metadata:
  annotations: {}
  labels:
    name: prometheus
  name: prometheus
rules:
- apiGroups:
  - ""
  resources:
  - nodes
  - nodes/proxy
  - nodes/metrics
  - services
  - endpoints
  - pods
  - ingresses
  - configmaps
  verbs:
  - get
  - list
  - watch
- apiGroups:
  - extensions
  resources:
  - ingresses
  - ingresses/status
  verbs:
  - get
  - list
  - watch
- nonResourceURLs:
  - /metrics
  verbs:
  - get
---
apiVersion: v1
data:
  config.yml: |
    global:
      resolve_timeout: 5m
    inhibit_rules:
    - equal:
      - alertname
      - cluster
      - service
      source_match:
        severity: critical
      target_match:
        severity: warning
    receivers:
    - name: email
    route:
      group_by:
      - alertname
      - cluster
      - service
      group_interval: 5m
      group_wait: 30s
      receiver: email
      repeat_interval: 7d
      routes: []
kind: ConfigMap
metadata:
  annotations: {}
  labels:
    name: alertmanager
  name: alertmanager
  namespace: kubeprod
---
apiVersion: apps/v1
kind: StatefulSet
metadata:
  annotations: {}
  labels:
    name: alertmanager
  name: alertmanager
  namespace: kubeprod
spec:
  replicas: 1
  selector:
    matchLabels:
      name: alertmanager
  serviceName: alertmanager
  template:
    metadata:
      annotations:
        prometheus.io/path: /alertmanager/metrics
        prometheus.io/port: "9093"
        prometheus.io/scrape: "true"
      labels:
        name: alertmanager
    spec:
      containers:
      - args:
        - --config.file=/opt/bitnami/alertmanager/conf/config.yml
        - --storage.path=/opt/bitnami/alertmanager/data
        - --web.external-url=http://prometheus.hosteaching.ovh/alertmanager
        env: []
        image: bitnami/alertmanager:0.21.0-debian-10-r4
        imagePullPolicy: IfNotPresent
        livenessProbe:
          failureThreshold: 10
          httpGet:
            path: /alertmanager/-/healthy
            port: 9093
          initialDelaySeconds: 60
        name: alertmanager
        ports:
        - containerPort: 9093
          name: alertmanager
        readinessProbe:
          failureThreshold: 10
          httpGet:
            path: /alertmanager/-/healthy
            port: 9093
          initialDelaySeconds: 3
          periodSeconds: 3
          timeoutSeconds: 3
        stdin: false
        tty: false
        volumeMounts:
        - mountPath: /opt/bitnami/alertmanager/conf
          name: config
          readOnly: true
        - mountPath: /opt/bitnami/alertmanager/data
          name: storage
      - args:
        - --volume-dir=/config
        - --webhook-method=POST
        - --webhook-url=http://localhost:9093/alertmanager/-/reload
        env: []
        image: bitnami/configmap-reload:0.4.0-debian-10-r1
        imagePullPolicy: IfNotPresent
        name: configmap-reload
        ports: []
        stdin: false
        tty: false
        volumeMounts:
        - mountPath: /config
          name: config
          readOnly: true
      imagePullSecrets: []
      initContainers: []
      securityContext:
        fsGroup: 1001
        runAsUser: 1001
      terminationGracePeriodSeconds: 30
      volumes:
      - configMap:
          name: alertmanager
        name: config
  updateStrategy:
    rollingUpdate:
      partition: 0
    type: RollingUpdate
  volumeClaimTemplates:
  - metadata:
      labels:
        name: storage
      name: storage
    spec:
      accessModes:
      - ReadWriteOnce
      storageClassName: "rook-cephfs"
      resources:
        requests:
          storage: 5Gi
---
apiVersion: v1
kind: Service
metadata:
  annotations: {}
  labels:
    name: alertmanager
  name: alertmanager
  namespace: kubeprod
spec:
  ports:
  - name: alertmanager
    port: 9093
    targetPort: 9093
  selector:
    name: alertmanager
  type: ClusterIP
---
apiVersion: networking.k8s.io/v1beta1
kind: Ingress
metadata:
  annotations:
    kubernetes.io/ingress.class: nginx
    kubernetes.io/tls-acme: "true"
    nginx.ingress.kubernetes.io/auth-response-headers: X-Auth-Request-User, X-Auth-Request-Email
    nginx.ingress.kubernetes.io/auth-signin: https://auth.hosteaching.ovh/oauth2/start?rd=%2F$server_name$escaped_request_uri
    nginx.ingress.kubernetes.io/auth-url: https://auth.hosteaching.ovh/oauth2/auth
  labels:
    name: prometheus
  name: prometheus
  namespace: kubeprod
spec:
  rules:
  - host: prometheus.hosteaching.ovh
    http:
      paths:
      - backend:
          serviceName: prometheus
          servicePort: 9090
        path: /
      - backend:
          serviceName: alertmanager
          servicePort: 9093
        path: /alertmanager
  tls:
  - hosts:
    - prometheus.hosteaching.ovh
    secretName: prometheus-tls
---
apiVersion: rbac.authorization.k8s.io/v1beta1
kind: Role
metadata:
  annotations: {}
  labels:
    name: kube-state-metrics-resizer
  name: kube-state-metrics-resizer
  namespace: kubeprod
rules:
- apiGroups:
  - ""
  resources:
  - pods
  verbs:
  - get
- apiGroups:
  - extensions
  resourceNames:
  - kube-state-metrics
  resources:
  - deployments
  verbs:
  - get
  - update
---
apiVersion: rbac.authorization.k8s.io/v1beta1
kind: RoleBinding
metadata:
  annotations: {}
  labels:
    name: kube-state-metrics
  name: kube-state-metrics
  namespace: kubeprod
roleRef:
  apiGroup: rbac.authorization.k8s.io
  kind: Role
  name: kube-state-metrics-resizer
subjects:
- kind: ServiceAccount
  name: kube-state-metrics
  namespace: kubeprod
---
apiVersion: v1
kind: ServiceAccount
metadata:
  annotations: {}
  labels:
    name: kube-state-metrics
  name: kube-state-metrics
  namespace: kubeprod
---
apiVersion: rbac.authorization.k8s.io/v1beta1
kind: ClusterRole
metadata:
  annotations: {}
  labels:
    name: kube-state-metrics
  name: kube-state-metrics
rules:
- apiGroups:
  - ""
  resources:
  - configmaps
  - endpoints
  - limitranges
  - namespaces
  - nodes
  - persistentvolumeclaims
  - persistentvolumes
  - pods
  - replicationcontrollers
  - resourcequotas
  - secrets
  - services
  verbs:
  - list
  - watch
- apiGroups:
  - admissionregistration.k8s.io
  resources:
  - mutatingwebhookconfigurations
  - validatingwebhookconfigurations
  verbs:
  - list
  - watch
- apiGroups:
  - apps
  resources:
  - daemonsets
  - deployments
  - replicasets
  - statefulsets
  verbs:
  - list
  - watch
- apiGroups:
  - autoscaling
  resources:
  - horizontalpodautoscalers
  verbs:
  - list
  - watch
- apiGroups:
  - autoscaling.k8s.io
  resources:
  - verticalpodautoscalers
  verbs:
  - list
  - watch
- apiGroups:
  - batch
  resources:
  - cronjobs
  - jobs
  verbs:
  - list
  - watch
- apiGroups:
  - certificates.k8s.io
  resources:
  - certificatesigningrequests
  verbs:
  - list
  - watch
- apiGroups:
  - extensions
  resources:
  - daemonsets
  - deployments
  - ingresses
  - replicasets
  verbs:
  - list
  - watch
- apiGroups:
  - networking.k8s.io
  resources:
  - ingresses
  - networkpolicies
  verbs:
  - list
  - watch
- apiGroups:
  - policy
  resources:
  - poddisruptionbudgets
  verbs:
  - list
  - watch
- apiGroups:
  - storage.k8s.io
  resources:
  - storageclasses
  - volumeattachments
  verbs:
  - list
  - watch
- apiGroups:
  - storageclasses.k8s.io
  resources:
  - storageclasses
  verbs:
  - list
  - watch
---
apiVersion: rbac.authorization.k8s.io/v1beta1
kind: ClusterRoleBinding
metadata:
  annotations: {}
  labels:
    name: kube-state-metrics
  name: kube-state-metrics
roleRef:
  apiGroup: rbac.authorization.k8s.io
  kind: ClusterRole
  name: kube-state-metrics
subjects:
- kind: ServiceAccount
  name: kube-state-metrics
  namespace: kubeprod
---
apiVersion: apps/v1
kind: Deployment
metadata:
  annotations: {}
  labels:
    name: kube-state-metrics
  name: kube-state-metrics
  namespace: kubeprod
spec:
  minReadySeconds: 30
  replicas: 1
  revisionHistoryLimit: 10
  selector:
    matchLabels:
      name: kube-state-metrics
  strategy:
    rollingUpdate:
      maxSurge: 25%
      maxUnavailable: 25%
    type: RollingUpdate
  template:
    metadata:
      annotations:
        prometheus.io/port: "8080"
        prometheus.io/scrape: "true"
      labels:
        name: kube-state-metrics
    spec:
      containers:
      - args:
        - --collectors=certificatesigningrequests,configmaps,cronjobs,daemonsets,deployments,endpoints,horizontalpodautoscalers,ingresses,jobs,limitranges,mutatingwebhookconfigurations,namespaces,networkpolicies,nodes,persistentvolumeclaims,persistentvolumes,poddisruptionbudgets,pods,replicasets,replicationcontrollers,resourcequotas,secrets,services,statefulsets,storageclasses,validatingwebhookconfigurations,volumeattachments
        env: []
        image: bitnami/kube-state-metrics:1.9.7-debian-10-r18
        imagePullPolicy: IfNotPresent
        name: ksm
        ports:
        - containerPort: 8080
          name: metrics
        readinessProbe:
          httpGet:
            path: /healthz
            port: 8080
          initialDelaySeconds: 5
          timeoutSeconds: 5
        stdin: false
        tty: false
        volumeMounts: []
      - args:
        - --container=ksm
        - --cpu=100m
        - --deployment=kube-state-metrics
        - --extra-cpu=1m
        - --extra-memory=2Mi
        - --memory=100Mi
        - --threshold=5
        command:
        - /pod_nanny
        env:
        - name: MY_POD_NAME
          valueFrom:
            fieldRef:
              apiVersion: v1
              fieldPath: metadata.name
        - name: MY_POD_NAMESPACE
          valueFrom:
            fieldRef:
              apiVersion: v1
              fieldPath: metadata.namespace
        image: k8s.gcr.io/addon-resizer:1.8.7
        imagePullPolicy: IfNotPresent
        name: addon-resizer
        ports: []
        resources:
          limits:
            cpu: 100m
            memory: 30Mi
          requests:
            cpu: 100m
            memory: 30Mi
        stdin: false
        tty: false
        volumeMounts: []
      imagePullSecrets: []
      initContainers: []
      serviceAccountName: kube-state-metrics
      terminationGracePeriodSeconds: 30
      volumes: []
---
apiVersion: apps/v1
kind: DaemonSet
metadata:
  annotations: {}
  labels:
    name: node-exporter
  name: node-exporter
  namespace: kubeprod
spec:
  selector:
    matchLabels:
      name: node-exporter
  template:
    metadata:
      annotations:
        prometheus.io/path: /metrics
        prometheus.io/port: "9100"
        prometheus.io/scrape: "true"
      labels:
        name: node-exporter
    spec:
      containers:
      - args:
        - --collector.filesystem.ignored-fs-types=^(sys|proc|auto|cgroup|devpts|ns|au|fuse\.lxc|mqueue)(fs)?$
        - --collector.filesystem.ignored-mount-points=^(/rootfs|/host)?/(sys|proc|dev|host|etc)($|/)
        - --path.procfs=/host/proc
        - --path.sysfs=/host/sys
        env: []
        image: bitnami/node-exporter:1.0.1-debian-10-r4
        imagePullPolicy: IfNotPresent
        livenessProbe:
          httpGet:
            path: /
            port: scrape
        name: node-exporter
        ports:
        - containerPort: 9100
          name: scrape
        readinessProbe:
          httpGet:
            path: /
            port: scrape
          successThreshold: 2
        stdin: false
        tty: false
        volumeMounts:
        - mountPath: /host/proc
          name: procfs
          readOnly: true
        - mountPath: /rootfs
          name: root
          readOnly: true
        - mountPath: /host/sys
          name: sysfs
          readOnly: true
      hostNetwork: true
      hostPID: true
      imagePullSecrets: []
      initContainers: []
      terminationGracePeriodSeconds: 30
      tolerations:
      - effect: NoSchedule
        key: node-role.kubernetes.io/master
      volumes:
      - hostPath:
          path: /proc
          type: ""
        name: procfs
      - hostPath:
          path: /
          type: ""
        name: root
      - hostPath:
          path: /sys
          type: ""
        name: sysfs
  updateStrategy:
    rollingUpdate:
      maxUnavailable: 1
    type: RollingUpdate
---
apiVersion: policy/v1beta1
kind: PodDisruptionBudget
metadata:
  annotations: {}
  labels:
    k8s-app: elasticsearch-logging
    name: elasticsearch-logging
  name: elasticsearch-logging
  namespace: kubeprod
spec:
  maxUnavailable: 1
  selector:
    matchLabels:
      k8s-app: elasticsearch-logging
      name: elasticsearch-logging
---
apiVersion: rbac.authorization.k8s.io/v1beta1
kind: ClusterRoleBinding
metadata:
  annotations: {}
  labels:
    k8s-app: elasticsearch-logging
    name: elasticsearch-logging
  name: elasticsearch-logging
roleRef:
  apiGroup: rbac.authorization.k8s.io
  kind: ClusterRole
  name: elasticsearch-logging
subjects:
- kind: ServiceAccount
  name: elasticsearch-logging
  namespace: kubeprod
---
apiVersion: rbac.authorization.k8s.io/v1beta1
kind: ClusterRole
metadata:
  annotations: {}
  labels:
    k8s-app: elasticsearch-logging
    name: elasticsearch-logging
  name: elasticsearch-logging
rules:
- apiGroups:
  - ""
  resources:
  - services
  - namespaces
  - endpoints
  verbs:
  - get
---
apiVersion: v1
data:
  java.security: |
    #
    # This is an alternate "security properties file".
    #
    # An alternate java.security properties file may be specified
    # from the command line via the system property
    #
    #    -Djava.security.properties=<URL>
    #

    # The JVM defaults to caching positive hostname resolutions indefinitely.
    # Elasticsearch nodes rely on DNS (Kubernetes headless service), where DNS
    # resolutions vary with time (e.g., for node-to-node discovery). This
    # behaviour can be modified by adding networkaddress.cache.ttl=<timeout>
    # to an alternate Java security properties file.
    # https://www.elastic.co/guide/en/elasticsearch/reference/6.3/networkaddress-cache-ttl.html
    networkaddress.cache.ttl=60
kind: ConfigMap
metadata:
  annotations: {}
  labels:
    k8s-app: elasticsearch-logging
    name: java-elasticsearch-logging
  name: java-elasticsearch-logging-13cadd4
  namespace: kubeprod
---
apiVersion: v1
kind: ServiceAccount
metadata:
  annotations: {}
  labels:
    k8s-app: elasticsearch-logging
    name: elasticsearch-logging
  name: elasticsearch-logging
  namespace: kubeprod
---
apiVersion: apps/v1
kind: StatefulSet
metadata:
  annotations: {}
  labels:
    k8s-app: elasticsearch-logging
    name: elasticsearch-logging
  name: elasticsearch-logging
  namespace: kubeprod
spec:
  podManagementPolicy: Parallel
  replicas: 3
  selector:
    matchLabels:
      k8s-app: elasticsearch-logging
      name: elasticsearch-logging
  serviceName: elasticsearch-logging
  template:
    metadata:
      annotations:
        prometheus.io/port: "9102"
        prometheus.io/scrape: "true"
      labels:
        k8s-app: elasticsearch-logging
        name: elasticsearch-logging
    spec:
      affinity:
        podAntiAffinity:
          preferredDuringSchedulingIgnoredDuringExecution:
          - podAffinityTerm:
              labelSelector:
                matchLabels:
                  k8s-app: elasticsearch-logging
                  name: elasticsearch-logging
              topologyKey: kubernetes.io/hostname
            weight: 70
          - podAffinityTerm:
              labelSelector:
                matchLabels:
                  k8s-app: elasticsearch-logging
                  name: elasticsearch-logging
              topologyKey: failure-domain.beta.kubernetes.io/zone
            weight: 70
          - podAffinityTerm:
              labelSelector:
                matchLabels:
                  k8s-app: elasticsearch-logging
                  name: elasticsearch-logging
              topologyKey: failure-domain.beta.kubernetes.io/region
            weight: 70
      containers:
      - args: []
        env:
        - name: ELASTICSEARCH_CLUSTER_HOSTS
          value: elasticsearch-logging
        - name: ELASTICSEARCH_CLUSTER_MASTER_HOSTS
          value: elasticsearch-logging-0
        - name: ELASTICSEARCH_CLUSTER_NAME
          value: elasticsearch-cluster
        - name: ELASTICSEARCH_MINIMUM_MASTER_NODES
          value: "2"
        - name: ELASTICSEARCH_NODE_PORT_NUMBER
          value: "9300"
        - name: ELASTICSEARCH_PORT_NUMBER
          value: "9200"
        - name: ES_JAVA_OPTS
          value: -Djava.security.properties=/opt/bitnami/java/lib/security/java.security.custom
            -Xms1200m -Xmx1200m -XshowSettings:vm
        image: bitnami/elasticsearch:7.8.0-debian-10-r1
        imagePullPolicy: IfNotPresent
        livenessProbe:
          failureThreshold: 4
          httpGet:
            path: /_cluster/health?local=true
            port: db
          initialDelaySeconds: 300
          periodSeconds: 30
          successThreshold: 1
        name: elasticsearch-logging
        ports:
        - containerPort: 9200
          name: db
        - containerPort: 9300
          name: transport
        readinessProbe:
          failureThreshold: 4
          httpGet:
            path: /_cluster/health?local=true
            port: db
          initialDelaySeconds: 120
          periodSeconds: 30
          successThreshold: 2
        resources:
          limits:
            cpu: "1"
            memory: 2Gi
          requests:
            cpu: 100m
            memory: 1200Mi
        securityContext:
          runAsUser: 1001
        stdin: false
        tty: false
        volumeMounts:
        - mountPath: /bitnami/elasticsearch/data
          name: data
        - mountPath: /opt/bitnami/java/lib/security/java.security.custom
          name: java-security
          readOnly: true
          subPath: java.security
      - args:
        - --es.timeout=20s
        - --es.uri=http://localhost:9200/
        - --web.listen-address=:9102
        - --web.telemetry-path=/metrics
        command:
        - elasticsearch_exporter
        env: []
        image: bitnami/elasticsearch-exporter:1.1.0-debian-10-r84
        imagePullPolicy: IfNotPresent
        livenessProbe:
          httpGet:
            path: /
            port: metrics
        name: prom-exporter
        ports:
        - containerPort: 9102
          name: metrics
        stdin: false
        tty: false
        volumeMounts: []
      imagePullSecrets: []
      initContainers:
      - args: []
        command:
        - sh
        - -c
        - install_packages procps && sysctl -w vm.max_map_count=262144
        env: []
        image: bitnami/minideb:stretch
        imagePullPolicy: IfNotPresent
        name: elasticsearch-logging-init
        ports: []
        securityContext:
          privileged: true
        stdin: false
        tty: false
        volumeMounts: []
      securityContext:
        fsGroup: 1001
      serviceAccountName: elasticsearch-logging
      terminationGracePeriodSeconds: 300
      volumes:
      - configMap:
          name: java-elasticsearch-logging-13cadd4
        name: java-security
  updateStrategy:
    type: RollingUpdate
  volumeClaimTemplates:
  - metadata:
      labels:
        name: data
      name: data
    spec:
      accessModes:
      - ReadWriteOnce
      storageClassName: "rook-cephfs"
      resources:
        requests:
          storage: 10Gi
---
apiVersion: v1
kind: Service
metadata:
  annotations:
    service.alpha.kubernetes.io/tolerate-unready-endpoints: "true"
  labels:
    k8s-app: elasticsearch-logging
    kubernetes.io/name: Elasticsearch
    name: elasticsearch-logging
  name: elasticsearch-logging
  namespace: kubeprod
spec:
  clusterIP: None
  ports:
  - name: db
    port: 9200
    targetPort: 9200
  publishNotReadyAddresses: true
  selector:
    k8s-app: elasticsearch-logging
    name: elasticsearch-logging
  sessionAffinity: None
  type: ClusterIP
---
apiVersion: v1
data:
  action_file.yml: |
    ---
    # Remember, leave a key empty if there is no value.  None will be a string,
    # not a Python "NoneType"
    #
    # Also remember that all examples have 'disable_action' set to True.  If you
    # want to use this action as a template, be sure to set this to False after
    # copying it.
    actions:
      1:
        action: delete_indices
        description: "Clean up ES by deleting old indices"
        options:
          timeout_override:
          continue_if_exception: False
          disable_action: False
          ignore_empty_list: True
        filters:
        - filtertype: age
          source: name
          direction: older
          timestring: '%Y.%m.%d'
          unit: days
          unit_count: 90
          field:
          stats_result:
          epoch:
          exclude: False
  config.yml: |
    ---
    # Remember, leave a key empty if there is no value.  None will be a string,
    # not a Python "NoneType"
    client:
      hosts:
        - elasticsearch-logging.kubeprod.svc
      port: 9200
      url_prefix:
      use_ssl: False
      certificate:
      client_cert:
      client_key:
      ssl_no_validate: False
      http_auth:
      timeout: 30
      master_only: False

    logging:
      loglevel: INFO
      logfile:
      logformat: default
      blacklist: ['elasticsearch', 'urllib3']
kind: ConfigMap
metadata:
  annotations: {}
  labels:
    name: elasticsearch-curator
  name: elasticsearch-curator-4f52cd0
  namespace: kubeprod
---
apiVersion: batch/v1beta1
kind: CronJob
metadata:
  annotations: {}
  labels:
    name: elasticsearch-curator
  name: elasticsearch-curator
  namespace: kubeprod
spec:
  concurrencyPolicy: Forbid
  failedJobsHistoryLimit: 20
  jobTemplate:
    spec:
      completions: 1
      parallelism: 1
      template:
        metadata:
          labels:
            name: elasticsearch-curator
        spec:
          containers:
          - args:
            - --config
            - /etc/config/config.yml
            - /etc/config/action_file.yml
            env: []
            image: bitnami/elasticsearch-curator:5.8.1-debian-10-r85
            imagePullPolicy: IfNotPresent
            name: curator
            ports: []
            stdin: false
            tty: false
            volumeMounts:
            - mountPath: /etc/config
              name: config-vol
              readOnly: true
          imagePullSecrets: []
          initContainers: []
          restartPolicy: OnFailure
          terminationGracePeriodSeconds: 30
          volumes:
          - configMap:
              name: elasticsearch-curator-4f52cd0
            name: config-vol
  schedule: 10 10 * * *
  successfulJobsHistoryLimit: 10
---
apiVersion: v1
data:
  my.cnf: |
    [client]
    port=3306
    socket=/opt/bitnami/mariadb/tmp/mysql.sock
    plugin_dir=/opt/bitnami/mariadb/plugin

    [mysqld]
    default-storage-engine=InnoDB
    basedir=/opt/bitnami/mariadb
    datadir=/bitnami/mariadb/data
    plugin_dir=/opt/bitnami/mariadb/plugin
    tmpdir=/opt/bitnami/mariadb/tmp
    socket=/opt/bitnami/mariadb/tmp/mysql.sock
    pid-file=/opt/bitnami/mariadb/tmp/mysqld.pid
    bind-address=0.0.0.0

    ## Character set
    collation-server=utf8_unicode_ci
    init-connect='SET NAMES utf8'
    character-set-server=utf8

    ## MyISAM
    key-buffer-size=32M
    myisam-recover-options=FORCE,BACKUP

    ## safety
    skip-host-cache
    skip-name-resolve
    max-allowed-packet=16M
    max-connect-errors=1000000
    sql-mode=STRICT_TRANS_TABLES,ERROR_FOR_DIVISION_BY_ZERO,NO_AUTO_CREATE_USER,NO_AUTO_VALUE_ON_ZERO,NO_ENGINE_SUBSTITUTION,NO_ZERO_DATE,NO_ZERO_IN_DATE,ONLY_FULL_GROUP_BY
    sysdate-is-now=1
    innodb=FORCE
    innodb-strict-mode=1
    innodb_file_per_table=1

    # Mandatory per https://github.com/codership/documentation/issues/25
    innodb-autoinc-lock-mode=2

    # Per https://www.percona.com/blog/2006/08/04/innodb-double-write/
    innodb-doublewrite=1

    # Not fully ACID compliant, up to 1sec transaction loss in the event of total cluster failure (across both regions)
    # Enabled for performance per https://mariadb.com/kb/en/mariadb/getting-started-with-mariadb-galera-cluster/
    innodb_flush_log_at_trx_commit=0

    ## binary logging
    log-bin=mysql-bin
    expire-logs-days=14

    # Disabling for performance per http://severalnines.com/blog/9-tips-going-production-galera-cluster-mysql
    sync-binlog=0

    # Required for Galera
    binlog-format=row

    ## Caches and limits
    tmp-table-size=32M
    max-heap-table-size=32M

    # Re-enabling as now works with Maria 10.1.2
    query-cache-type=1
    query-cache-limit=4M
    query-cache-size=256M
    max-connections=500
    thread-cache-size=50
    open-files-limit=65535
    table-definition-cache=4096
    table-open-cache=4096

    ## innodb
    innodb-flush-method=O_DIRECT
    innodb-log-files-in-group=2
    innodb-log-file-size=128M
    innodb-flush-log-at-trx-commit=1
    innodb-file-per-table=1

    # 80% Memory is default reco.
    # Need to re-evaluate when DB size grows
    innodb-buffer-pool-size=2G
    innodb_file_format=Barracuda

    ## logging
    log_warnings=2
    log-queries-not-using-indexes=1
    slow-query-log=1

    [galera]
    wsrep_on=ON
    wsrep_provider=/opt/bitnami/mariadb/lib/libgalera_smm.so
    wsrep_sst_method=mariabackup
    wsrep_slave_threads=4
    wsrep_cluster_address=gcomm://
    wsrep_cluster_name=galera
    wsrep_sst_auth="root:"
    innodb-flush-log-at-trx-commit=2
    wsrep_replicate_myisam=ON

    [mariadb]
    plugin_load_add=auth_pam
kind: ConfigMap
metadata:
  annotations: {}
  labels:
    name: mariadb-galera
  name: mariadb-galera-ece316e
  namespace: kubeprod
---
apiVersion: v1
kind: Service
metadata:
  annotations: {}
  labels:
    name: mariadb-galera-headless
  name: mariadb-galera-headless
  namespace: kubeprod
spec:
  clusterIP: None
  ports:
  - name: galera
    port: 4567
    protocol: TCP
  - name: ist
    port: 4568
    protocol: TCP
  - name: sst
    port: 4444
    protocol: TCP
  selector:
    name: mariadb-galera
  type: ClusterIP
---
apiVersion: rbac.authorization.k8s.io/v1beta1
kind: Role
metadata:
  annotations: {}
  labels:
    name: mariadb-galera
  name: mariadb-galera
  namespace: kubeprod
rules:
- apiGroups:
  - ""
  resources:
  - endpoints
  verbs:
  - get
---
apiVersion: rbac.authorization.k8s.io/v1beta1
kind: RoleBinding
metadata:
  annotations: {}
  labels:
    name: mariadb-galera
  name: mariadb-galera
  namespace: kubeprod
roleRef:
  apiGroup: rbac.authorization.k8s.io
  kind: Role
  name: mariadb-galera
subjects:
- kind: ServiceAccount
  name: mariadb-galera
  namespace: kubeprod
---
apiVersion: v1
kind: ServiceAccount
metadata:
  annotations: {}
  labels:
    name: mariadb-galera
  name: mariadb-galera
  namespace: kubeprod
---
apiVersion: v1
data:
  mariabackup_password: cWxhZlhrYjZYd0h1MEpFRG5hbi9RZ3lxM3ptV3Zlbng=
  root_password: TXM1RjJ4R3NsQXpsWjZtZ3JUY1Nod0ZucklwRWNEcTc=
kind: Secret
metadata:
  annotations: {}
  labels:
    name: mariadb-galera
  name: mariadb-galera-dc69b99
  namespace: kubeprod
type: Opaque
---
apiVersion: apps/v1
kind: StatefulSet
metadata:
  annotations: {}
  labels:
    name: mariadb-galera
  name: mariadb-galera
  namespace: kubeprod
spec:
  replicas: 3
  selector:
    matchLabels:
      name: mariadb-galera
  serviceName: mariadb-galera
  template:
    metadata:
      annotations: {}
      labels:
        name: mariadb-galera
    spec:
      affinity:
        podAntiAffinity:
          preferredDuringSchedulingIgnoredDuringExecution:
          - podAffinityTerm:
              labelSelector:
                matchLabels:
                  name: mariadb-galera
              topologyKey: kubernetes.io/hostname
            weight: 70
          - podAffinityTerm:
              labelSelector:
                matchLabels:
                  name: mariadb-galera
              topologyKey: failure-domain.beta.kubernetes.io/zone
            weight: 70
          - podAffinityTerm:
              labelSelector:
                matchLabels:
                  name: mariadb-galera
              topologyKey: failure-domain.beta.kubernetes.io/region
            weight: 70
      containers:
      - args: []
        env:
        - name: MARIADB_GALERA_CLUSTER_ADDRESS
          value: gcomm://mariadb-galera-headless.kubeprod.svc
        - name: MARIADB_GALERA_CLUSTER_NAME
          value: galera
        - name: MARIADB_GALERA_MARIABACKUP_PASSWORD
          valueFrom:
            secretKeyRef:
              key: mariabackup_password
              name: mariadb-galera-dc69b99
        - name: MARIADB_GALERA_MARIABACKUP_USER
          value: mariabackup
        - name: MARIADB_ROOT_PASSWORD
          valueFrom:
            secretKeyRef:
              key: root_password
              name: mariadb-galera-dc69b99
        image: bitnami/mariadb-galera:10.5.4-debian-10-r2
        imagePullPolicy: IfNotPresent
        livenessProbe:
          exec:
            command:
            - /bin/bash
            - -ec
            - |
              exec mysqladmin status -uroot -p$MARIADB_ROOT_PASSWORD
          failureThreshold: 3
          initialDelaySeconds: 120
          periodSeconds: 10
          successThreshold: 1
          timeoutSeconds: 1
        name: mariadb-galera
        ports:
        - containerPort: 4567
          name: galera
        - containerPort: 4568
          name: ist
        - containerPort: 3306
          name: mysql
        - containerPort: 4444
          name: sst
        readinessProbe:
          exec:
            command:
            - /bin/bash
            - -ec
            - |
              exec mysqladmin status -uroot -p$MARIADB_ROOT_PASSWORD
          failureThreshold: 3
          initialDelaySeconds: 30
          periodSeconds: 10
          successThreshold: 1
          timeoutSeconds: 1
        stdin: false
        tty: false
        volumeMounts:
        - mountPath: /opt/bitnami/mariadb/conf/my.cnf
          name: config
          readOnly: true
          subPath: my.cnf
        - mountPath: /bitnami/mariadb
          name: data
      - args: []
        command:
        - sh
        - -c
        - |
          DATA_SOURCE_NAME="root:$MARIADB_ROOT_PASSWORD@(localhost:3306)/" /bin/mysqld_exporter
        env:
        - name: MARIADB_ROOT_PASSWORD
          valueFrom:
            secretKeyRef:
              key: root_password
              name: mariadb-galera-dc69b99
        image: bitnami/mysqld-exporter:0.12.1-debian-10-r86
        imagePullPolicy: IfNotPresent
        livenessProbe:
          httpGet:
            path: /metrics
            port: metrics
          initialDelaySeconds: 30
          timeoutSeconds: 5
        name: metrics
        ports:
        - containerPort: 9104
          name: metrics
        readinessProbe:
          httpGet:
            path: /metrics
            port: metrics
          initialDelaySeconds: 5
          timeoutSeconds: 1
        resources:
          limits:
            cpu: 100m
            memory: 512Mi
          requests:
            cpu: 100m
            memory: 512Mi
        stdin: false
        tty: false
        volumeMounts: []
      imagePullSecrets: []
      initContainers: []
      securityContext:
        fsGroup: 1001
        runAsUser: 1001
      serviceAccountName: mariadb-galera
      terminationGracePeriodSeconds: 30
      volumes:
      - configMap:
          name: mariadb-galera-ece316e
        name: config
  updateStrategy:
    type: RollingUpdate
  volumeClaimTemplates:
  - metadata:
      labels:
        name: data
      name: data
    spec:
      accessModes:
      - ReadWriteOnce
      storageClassName: "rook-cephfs"
      resources:
        requests:
          storage: 10Gi
---
apiVersion: v1
kind: Service
metadata:
  annotations:
    prometheus.io/port: "9104"
    prometheus.io/scrape: "true"
  labels:
    name: mariadb-galera
  name: mariadb-galera
  namespace: kubeprod
spec:
  ports:
  - name: mysql
    port: 3306
    protocol: TCP
  - name: metrics
    port: 9104
    protocol: TCP
  selector:
    name: mariadb-galera
  type: ClusterIP
---
apiVersion: v1
kind: Namespace
metadata:
  annotations: {}
  labels:
    name: kubeprod
  name: kubeprod
---
apiVersion: autoscaling/v1
kind: HorizontalPodAutoscaler
metadata:
  annotations: {}
  labels:
    name: oauth2-proxy
  name: oauth2-proxy
  namespace: kubeprod
spec:
  maxReplicas: 10
  minReplicas: 2
  scaleTargetRef:
    apiVersion: apps/v1
    kind: Deployment
    name: oauth2-proxy
---
apiVersion: networking.k8s.io/v1beta1
kind: Ingress
metadata:
  annotations:
    kubernetes.io/ingress.class: nginx
    kubernetes.io/tls-acme: "true"
    nginx.ingress.kubernetes.io/configuration-snippet: |
      location "~^/(?<target_host>[^/]+\.hosteaching\.ovh)(?<remaining_uri>.*)$" {
        rewrite ^ $scheme://$target_host$remaining_uri;
      }
  labels:
    name: oauth2-ingress
  name: oauth2-ingress
  namespace: kubeprod
spec:
  rules:
  - host: auth.hosteaching.ovh
    http:
      paths:
      - backend:
          serviceName: oauth2-proxy
          servicePort: 4180
        path: /oauth2/
      - backend:
          serviceName: oauth2-proxy
          servicePort: 4180
        path: /
  tls:
  - hosts:
    - auth.hosteaching.ovh
    secretName: oauth2-ingress-tls
---
apiVersion: policy/v1beta1
kind: PodDisruptionBudget
metadata:
  annotations: {}
  labels:
    name: oauth2-proxy
  name: oauth2-proxy
  namespace: kubeprod
spec:
  minAvailable: 1
  selector:
    matchLabels:
      name: oauth2-proxy
---
apiVersion: v1
data:
  authz_domain: aG9zdGVhY2hpbmcub3Zo
  client_id: Ymtwcg==
  client_secret: NmU5ZDRhNDMtMDc5OS00ZTE1LWI5NmQtYWRkN2I4NDJiZDRl
  cookie_secret: RHF5MGRCblUzUCtVRTdDVVhxTk5iTHkxNTJhaXNLd3Q=
kind: Secret
metadata:
  annotations: {}
  labels:
    name: oauth2-proxy
  name: oauth2-proxy-1f85277
  namespace: kubeprod
type: Opaque
---
apiVersion: v1
kind: Service
metadata:
  annotations: {}
  labels:
    name: oauth2-proxy
  name: oauth2-proxy
  namespace: kubeprod
spec:
  ports:
  - name: http
    port: 4180
    targetPort: 4180
  selector:
    name: oauth2-proxy
  type: ClusterIP
---
apiVersion: apps/v1
kind: Deployment
metadata:
  annotations: {}
  labels:
    name: oauth2-proxy
  name: oauth2-proxy
  namespace: kubeprod
spec:
  minReadySeconds: 30
  replicas: 2
  revisionHistoryLimit: 10
  selector:
    matchLabels:
      name: oauth2-proxy
  strategy:
    rollingUpdate:
      maxSurge: 25%
      maxUnavailable: 25%
    type: RollingUpdate
  template:
    metadata:
      annotations: {}
      labels:
        name: oauth2-proxy
    spec:
      affinity:
        podAntiAffinity:
          preferredDuringSchedulingIgnoredDuringExecution:
          - podAffinityTerm:
              labelSelector:
                matchLabels:
                  name: oauth2-proxy
              topologyKey: kubernetes.io/hostname
            weight: 70
          - podAffinityTerm:
              labelSelector:
                matchLabels:
                  name: oauth2-proxy
              topologyKey: failure-domain.beta.kubernetes.io/zone
            weight: 70
          - podAffinityTerm:
              labelSelector:
                matchLabels:
                  name: oauth2-proxy
              topologyKey: failure-domain.beta.kubernetes.io/region
            weight: 70
      containers:
      - args:
        - --cookie-domain=hosteaching.ovh
        - --cookie-refresh=3h
        - --cookie-secure=true
        - --email-domain=hosteaching.ovh
        - --http-address=0.0.0.0:4180
        - --keycloak-group=
        - --login-url=https://id.hosteaching.ovh/auth/realms/BKPR/protocol/openid-connect/auth
        - --provider=keycloak
        - --redeem-url=https://id.hosteaching.ovh/auth/realms/BKPR/protocol/openid-connect/token
        - --redirect-url=https://auth.hosteaching.ovh/oauth2/callback
        - --set-xauthrequest=true
        - --ssl-insecure-skip-verify=false
        - --tls-cert-file=
        - --upstream=file:///dev/null
        - --validate-url=https://id.hosteaching.ovh/auth/realms/BKPR/protocol/openid-connect/userinfo
        env:
        - name: OAUTH2_PROXY_CLIENT_ID
          valueFrom:
            secretKeyRef:
              key: client_id
              name: oauth2-proxy-1f85277
        - name: OAUTH2_PROXY_CLIENT_SECRET
          valueFrom:
            secretKeyRef:
              key: client_secret
              name: oauth2-proxy-1f85277
        - name: OAUTH2_PROXY_COOKIE_SECRET
          valueFrom:
            secretKeyRef:
              key: cookie_secret
              name: oauth2-proxy-1f85277
        image: bitnami/oauth2-proxy:5.1.1-debian-10-r46
        imagePullPolicy: IfNotPresent
        livenessProbe:
          httpGet:
            path: /ping
            port: http
          initialDelaySeconds: 30
        name: oauth2-proxy
        ports:
        - containerPort: 4180
          name: http
        readinessProbe:
          httpGet:
            path: /ping
            port: http
        resources:
          requests:
            cpu: 10m
        stdin: false
        tty: false
        volumeMounts: []
      imagePullSecrets: []
      initContainers: []
      terminationGracePeriodSeconds: 30
      volumes: []
